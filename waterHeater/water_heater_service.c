/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: waterHeater.proto */

#include <errno.h>
#include <assert.h>
#include "waterHeater.pb-c.h"
#include "water_heater_service.h"
#include "hey/schema.h"

#define WATER_HEATER_SERVICE (16 * 256)
#define PROP_IID_CNT 64
#define ACT_IID_CNT 4

static const struct hey_schema_property water_heater_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_GENERIC },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 9, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 11, .type = HEY_PROPERTY_TYPE_GENERIC },
    [11] = { .iid = 12, .type = HEY_PROPERTY_TYPE_GENERIC },
    [12] = { .iid = 13, .type = HEY_PROPERTY_TYPE_GENERIC },
    [13] = { .iid = 14, .type = HEY_PROPERTY_TYPE_GENERIC },
    [14] = { .iid = 15, .type = HEY_PROPERTY_TYPE_GENERIC },
    [15] = { .iid = 16, .type = HEY_PROPERTY_TYPE_GENERIC },
    [16] = { .iid = 17, .type = HEY_PROPERTY_TYPE_ARRAY },
    [17] = { .iid = 18, .type = HEY_PROPERTY_TYPE_GENERIC },
    [18] = { .iid = 19, .type = HEY_PROPERTY_TYPE_GENERIC },
    [19] = { .iid = 20, .type = HEY_PROPERTY_TYPE_GENERIC },
    [20] = { .iid = 21, .type = HEY_PROPERTY_TYPE_GENERIC },
    [21] = { .iid = 22, .type = HEY_PROPERTY_TYPE_GENERIC },
    [22] = { .iid = 23, .type = HEY_PROPERTY_TYPE_GENERIC },
    [23] = { .iid = 24, .type = HEY_PROPERTY_TYPE_GENERIC },
    [24] = { .iid = 25, .type = HEY_PROPERTY_TYPE_GENERIC },
    [25] = { .iid = 26, .type = HEY_PROPERTY_TYPE_GENERIC },
    [26] = { .iid = 27, .type = HEY_PROPERTY_TYPE_GENERIC },
    [27] = { .iid = 28, .type = HEY_PROPERTY_TYPE_GENERIC },
    [28] = { .iid = 31, .type = HEY_PROPERTY_TYPE_GENERIC },
    [29] = { .iid = 32, .type = HEY_PROPERTY_TYPE_GENERIC },
    [30] = { .iid = 33, .type = HEY_PROPERTY_TYPE_GENERIC },
    [31] = { .iid = 34, .type = HEY_PROPERTY_TYPE_GENERIC },
    [32] = { .iid = 35, .type = HEY_PROPERTY_TYPE_GENERIC },
    [33] = { .iid = 36, .type = HEY_PROPERTY_TYPE_GENERIC },
    [34] = { .iid = 37, .type = HEY_PROPERTY_TYPE_GENERIC },
    [35] = { .iid = 38, .type = HEY_PROPERTY_TYPE_GENERIC },
    [36] = { .iid = 39, .type = HEY_PROPERTY_TYPE_GENERIC },
    [37] = { .iid = 40, .type = HEY_PROPERTY_TYPE_GENERIC },
    [38] = { .iid = 41, .type = HEY_PROPERTY_TYPE_GENERIC },
    [39] = { .iid = 42, .type = HEY_PROPERTY_TYPE_GENERIC },
    [40] = { .iid = 43, .type = HEY_PROPERTY_TYPE_GENERIC },
    [41] = { .iid = 44, .type = HEY_PROPERTY_TYPE_GENERIC },
    [42] = { .iid = 45, .type = HEY_PROPERTY_TYPE_GENERIC },
    [43] = { .iid = 46, .type = HEY_PROPERTY_TYPE_GENERIC },
    [44] = { .iid = 47, .type = HEY_PROPERTY_TYPE_GENERIC },
    [45] = { .iid = 48, .type = HEY_PROPERTY_TYPE_GENERIC },
    [46] = { .iid = 49, .type = HEY_PROPERTY_TYPE_GENERIC },
    [47] = { .iid = 50, .type = HEY_PROPERTY_TYPE_GENERIC },
    [48] = { .iid = 52, .type = HEY_PROPERTY_TYPE_GENERIC },
    [49] = { .iid = 53, .type = HEY_PROPERTY_TYPE_GENERIC },
    [50] = { .iid = 54, .type = HEY_PROPERTY_TYPE_GENERIC },
    [51] = { .iid = 55, .type = HEY_PROPERTY_TYPE_GENERIC },
    [52] = { .iid = 57, .type = HEY_PROPERTY_TYPE_GENERIC },
    [53] = { .iid = 58, .type = HEY_PROPERTY_TYPE_GENERIC },
    [54] = { .iid = 59, .type = HEY_PROPERTY_TYPE_GENERIC },
    [55] = { .iid = 60, .type = HEY_PROPERTY_TYPE_GENERIC },
    [56] = { .iid = 61, .type = HEY_PROPERTY_TYPE_GENERIC },
    [57] = { .iid = 62, .type = HEY_PROPERTY_TYPE_GENERIC },
    [58] = { .iid = 63, .type = HEY_PROPERTY_TYPE_GENERIC },
    [59] = { .iid = 64, .type = HEY_PROPERTY_TYPE_GENERIC },
    [60] = { .iid = 65, .type = HEY_PROPERTY_TYPE_ARRAY },
    [61] = { .iid = 66, .type = HEY_PROPERTY_TYPE_ARRAY },
    [62] = { .iid = 67, .type = HEY_PROPERTY_TYPE_GENERIC },
    [63] = { .iid = 68, .type = HEY_PROPERTY_TYPE_GENERIC },
};
static struct hey_service *water_heater_service;

static int32_t action_water_quality_reset_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__WaterHeater__ActionInWaterQualityReset *water_quality_reset = iot__service__water_heater__action_in_water_quality_reset__unpack(NULL, len, value);
    if (NULL == water_quality_reset) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct water_heater_water_quality_reset_in action = { 0 };
    ret = water_heater_water_quality_reset_start_cb(ctx, &action, user_context);

    iot__service__water_heater__action_in_water_quality_reset__free_unpacked(water_quality_reset, NULL);
    return ret;
}

static void action_water_quality_reset_stop_cb(void *cb_data, void *user_context)
{
    water_heater_water_quality_reset_stop_cb(user_context);
}

/**
 * @brief water quality reset action send message of water heater service
 * @param ctx      [action context]
 * @param action   [water quality reset action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t water_heater_water_quality_reset_send(struct hey_action_ctx *ctx, struct water_heater_water_quality_reset_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief water quality reset action stop of water heater service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t water_heater_water_quality_reset_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_mg_reset_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__WaterHeater__ActionInMgReset *mg_reset = iot__service__water_heater__action_in_mg_reset__unpack(NULL, len, value);
    if (NULL == mg_reset) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct water_heater_mg_reset_in action = { 0 };
    ret = water_heater_mg_reset_start_cb(ctx, &action, user_context);

    iot__service__water_heater__action_in_mg_reset__free_unpacked(mg_reset, NULL);
    return ret;
}

static void action_mg_reset_stop_cb(void *cb_data, void *user_context)
{
    water_heater_mg_reset_stop_cb(user_context);
}

/**
 * @brief mg reset action send message of water heater service
 * @param ctx      [action context]
 * @param action   [mg reset action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t water_heater_mg_reset_send(struct hey_action_ctx *ctx, struct water_heater_mg_reset_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief mg reset action stop of water heater service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t water_heater_mg_reset_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_water_consumption_reset_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__WaterHeater__ActionInWaterConsumptionReset *water_consumption_reset = iot__service__water_heater__action_in_water_consumption_reset__unpack(NULL, len, value);
    if (NULL == water_consumption_reset) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct water_heater_water_consumption_reset_in action = { 0 };
    ret = water_heater_water_consumption_reset_start_cb(ctx, &action, user_context);

    iot__service__water_heater__action_in_water_consumption_reset__free_unpacked(water_consumption_reset, NULL);
    return ret;
}

static void action_water_consumption_reset_stop_cb(void *cb_data, void *user_context)
{
    water_heater_water_consumption_reset_stop_cb(user_context);
}

/**
 * @brief water consumption reset action send message of water heater service
 * @param ctx      [action context]
 * @param action   [water consumption reset action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t water_heater_water_consumption_reset_send(struct hey_action_ctx *ctx, struct water_heater_water_consumption_reset_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief water consumption reset action stop of water heater service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t water_heater_water_consumption_reset_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_device_factory_restore_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__WaterHeater__ActionInDeviceFactoryRestore *device_factory_restore = iot__service__water_heater__action_in_device_factory_restore__unpack(NULL, len, value);
    if (NULL == device_factory_restore) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct water_heater_device_factory_restore_in action = { 0 };
    ret = water_heater_device_factory_restore_start_cb(ctx, &action, user_context);

    iot__service__water_heater__action_in_device_factory_restore__free_unpacked(device_factory_restore, NULL);
    return ret;
}

static void action_device_factory_restore_stop_cb(void *cb_data, void *user_context)
{
    water_heater_device_factory_restore_stop_cb(user_context);
}

/**
 * @brief device factory restore action send message of water heater service
 * @param ctx      [action context]
 * @param action   [device factory restore action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t water_heater_device_factory_restore_send(struct hey_action_ctx *ctx, struct water_heater_device_factory_restore_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief device factory restore action stop of water heater service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t water_heater_device_factory_restore_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static Iot__Service__WaterHeater__UserDefineTemp *_water_heater_user_define_temp = NULL;
struct water_heater_user_define_temp *water_heater_user_define_temp_unpack(const uint8_t *data, size_t len)
{
    _water_heater_user_define_temp = iot__service__water_heater__user_define_temp__unpack(NULL, len, data);
    if (NULL == _water_heater_user_define_temp) {
        return NULL;
    }
    struct water_heater_user_define_temp *hey_struct = malloc(sizeof(struct water_heater_user_define_temp));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->status = _water_heater_user_define_temp->status;
    hey_struct->temperature = _water_heater_user_define_temp->temperature;
    return hey_struct;
out1:
    iot__service__water_heater__user_define_temp__free_unpacked(_water_heater_user_define_temp, NULL);
    return NULL;
}

void water_heater_user_define_temp_free_unpacked(struct water_heater_user_define_temp *data)
{
    assert(NULL != data);
    iot__service__water_heater__user_define_temp__free_unpacked(_water_heater_user_define_temp, NULL);
    free(data);
}

int32_t water_heater_user_define_temp_get_packed_size(const struct water_heater_user_define_temp *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__UserDefineTemp *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__UserDefineTemp));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__user_define_temp__init(pb_struct);
    pb_struct->status = data->status;
    pb_struct->temperature = data->temperature;
    ret = iot__service__water_heater__user_define_temp__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t water_heater_user_define_temp_pack(const struct water_heater_user_define_temp *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__UserDefineTemp *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__UserDefineTemp));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__user_define_temp__init(pb_struct);
    pb_struct->status = data->status;
    pb_struct->temperature = data->temperature;
    ret = iot__service__water_heater__user_define_temp__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__WaterHeater__ColdWaterAppointment *_water_heater_cold_water_appointment = NULL;
struct water_heater_cold_water_appointment *water_heater_cold_water_appointment_unpack(const uint8_t *data, size_t len)
{
    _water_heater_cold_water_appointment = iot__service__water_heater__cold_water_appointment__unpack(NULL, len, data);
    if (NULL == _water_heater_cold_water_appointment) {
        return NULL;
    }
    struct water_heater_cold_water_appointment *hey_struct = malloc(sizeof(struct water_heater_cold_water_appointment));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->enable = _water_heater_cold_water_appointment->enable;
    hey_struct->week = _water_heater_cold_water_appointment->week;
    hey_struct->fromsecond = _water_heater_cold_water_appointment->fromsecond;
    hey_struct->frommin = _water_heater_cold_water_appointment->frommin;
    hey_struct->fromhour = _water_heater_cold_water_appointment->fromhour;
    hey_struct->tosecond = _water_heater_cold_water_appointment->tosecond;
    hey_struct->tomin = _water_heater_cold_water_appointment->tomin;
    hey_struct->tohour = _water_heater_cold_water_appointment->tohour;
    return hey_struct;
out1:
    iot__service__water_heater__cold_water_appointment__free_unpacked(_water_heater_cold_water_appointment, NULL);
    return NULL;
}

void water_heater_cold_water_appointment_free_unpacked(struct water_heater_cold_water_appointment *data)
{
    assert(NULL != data);
    iot__service__water_heater__cold_water_appointment__free_unpacked(_water_heater_cold_water_appointment, NULL);
    free(data);
}

int32_t water_heater_cold_water_appointment_get_packed_size(const struct water_heater_cold_water_appointment *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__ColdWaterAppointment *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__ColdWaterAppointment));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__cold_water_appointment__init(pb_struct);
    pb_struct->enable = data->enable;
    pb_struct->week = data->week;
    pb_struct->fromsecond = data->fromsecond;
    pb_struct->frommin = data->frommin;
    pb_struct->fromhour = data->fromhour;
    pb_struct->tosecond = data->tosecond;
    pb_struct->tomin = data->tomin;
    pb_struct->tohour = data->tohour;
    ret = iot__service__water_heater__cold_water_appointment__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t water_heater_cold_water_appointment_pack(const struct water_heater_cold_water_appointment *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__ColdWaterAppointment *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__ColdWaterAppointment));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__cold_water_appointment__init(pb_struct);
    pb_struct->enable = data->enable;
    pb_struct->week = data->week;
    pb_struct->fromsecond = data->fromsecond;
    pb_struct->frommin = data->frommin;
    pb_struct->fromhour = data->fromhour;
    pb_struct->tosecond = data->tosecond;
    pb_struct->tomin = data->tomin;
    pb_struct->tohour = data->tohour;
    ret = iot__service__water_heater__cold_water_appointment__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__WaterHeater__ColdWaterPowerAppointment *_water_heater_cold_water_power_appointment = NULL;
struct water_heater_cold_water_power_appointment *water_heater_cold_water_power_appointment_unpack(const uint8_t *data, size_t len)
{
    _water_heater_cold_water_power_appointment = iot__service__water_heater__cold_water_power_appointment__unpack(NULL, len, data);
    if (NULL == _water_heater_cold_water_power_appointment) {
        return NULL;
    }
    struct water_heater_cold_water_power_appointment *hey_struct = malloc(sizeof(struct water_heater_cold_water_power_appointment));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->enable = _water_heater_cold_water_power_appointment->enable;
    hey_struct->week = _water_heater_cold_water_power_appointment->week;
    hey_struct->fromsecond = _water_heater_cold_water_power_appointment->fromsecond;
    hey_struct->frommin = _water_heater_cold_water_power_appointment->frommin;
    hey_struct->fromhour = _water_heater_cold_water_power_appointment->fromhour;
    hey_struct->tosecond = _water_heater_cold_water_power_appointment->tosecond;
    hey_struct->tomin = _water_heater_cold_water_power_appointment->tomin;
    hey_struct->tohour = _water_heater_cold_water_power_appointment->tohour;
    return hey_struct;
out1:
    iot__service__water_heater__cold_water_power_appointment__free_unpacked(_water_heater_cold_water_power_appointment, NULL);
    return NULL;
}

void water_heater_cold_water_power_appointment_free_unpacked(struct water_heater_cold_water_power_appointment *data)
{
    assert(NULL != data);
    iot__service__water_heater__cold_water_power_appointment__free_unpacked(_water_heater_cold_water_power_appointment, NULL);
    free(data);
}

int32_t water_heater_cold_water_power_appointment_get_packed_size(const struct water_heater_cold_water_power_appointment *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__ColdWaterPowerAppointment *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__ColdWaterPowerAppointment));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__cold_water_power_appointment__init(pb_struct);
    pb_struct->enable = data->enable;
    pb_struct->week = data->week;
    pb_struct->fromsecond = data->fromsecond;
    pb_struct->frommin = data->frommin;
    pb_struct->fromhour = data->fromhour;
    pb_struct->tosecond = data->tosecond;
    pb_struct->tomin = data->tomin;
    pb_struct->tohour = data->tohour;
    ret = iot__service__water_heater__cold_water_power_appointment__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t water_heater_cold_water_power_appointment_pack(const struct water_heater_cold_water_power_appointment *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__WaterHeater__ColdWaterPowerAppointment *pb_struct = malloc(sizeof(Iot__Service__WaterHeater__ColdWaterPowerAppointment));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__water_heater__cold_water_power_appointment__init(pb_struct);
    pb_struct->enable = data->enable;
    pb_struct->week = data->week;
    pb_struct->fromsecond = data->fromsecond;
    pb_struct->frommin = data->frommin;
    pb_struct->fromhour = data->fromhour;
    pb_struct->tosecond = data->tosecond;
    pb_struct->tomin = data->tomin;
    pb_struct->tohour = data->tohour;
    ret = iot__service__water_heater__cold_water_power_appointment__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static int32_t service_water_heater_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                        size_t len, uint8_t *value)
{
    Iot__Service__WaterHeater__Properties *props = iot__service__water_heater__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct water_heater_properties properties = { 0 };
    struct hey_array_node **userdefinetemp = NULL;
    struct hey_array_node **coldwaterappointment = NULL;
    struct hey_array_node **coldwaterpowerappointment = NULL;
    properties.power = props->power;
    properties.currenttemperature = props->currenttemperature;
    properties.targettemperature = props->targettemperature;
    properties.remaintime = props->remaintime;
    properties.hotwaterlevel = props->hotwaterlevel;
    properties.heaterstatus = props->heaterstatus;
    properties.heatingmode = props->heatingmode;
    properties.waterheatermode = props->waterheatermode;
    properties.waterheaterscene = props->waterheaterscene;
    properties.sterilizationenabled = props->sterilizationenabled;
    properties.eco = props->eco;
    properties.sleep = props->sleep;
    properties.volume = props->volume;
    properties.childlockenabled = props->childlockenabled;
    properties.screendisplayenabled = props->screendisplayenabled;
    properties.mgusedpercent = props->mgusedpercent;
    if (props->n_userdefinetemp) {
        userdefinetemp = calloc(props->n_userdefinetemp, sizeof(struct hey_array_node *));
        if (userdefinetemp == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_userdefinetemp; i++) {
            userdefinetemp[i] = malloc(sizeof(struct hey_array_node));
            if (userdefinetemp[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            userdefinetemp[i]->id = props->userdefinetemp[i]->id;
            userdefinetemp[i]->data.data = props->userdefinetemp[i]->data.data;
            userdefinetemp[i]->data.len = props->userdefinetemp[i]->data.len;
        }
        properties.n_userdefinetemp = props->n_userdefinetemp;
        properties.userdefinetemp = userdefinetemp;
    }
    properties.heatingpower = props->heatingpower;
    properties.tplushot = props->tplushot;
    properties.autopoweroff = props->autopoweroff;
    properties.alwaystempdetection = props->alwaystempdetection;
    properties.scenemodeenabled = props->scenemodeenabled;
    properties.waterflowstatus = props->waterflowstatus;
    properties.frequencyhot = props->frequencyhot;
    properties.frequencyhotgear = props->frequencyhotgear;
    properties.sterilizationperiod = props->sterilizationperiod;
    properties.sterilizationleftdays = props->sterilizationleftdays;
    properties.waterquality = props->waterquality;
    properties.bathremainingtime = props->bathremainingtime;
    properties.morningnightbath = props->morningnightbath;
    properties.bathtubwaterlevel = props->bathtubwaterlevel;
    properties.bathtubup = props->bathtubup;
    properties.inflowtemp = props->inflowtemp;
    properties.watervolume = props->watervolume;
    properties.firestatus = props->firestatus;
    properties.smartchangelitres = props->smartchangelitres;
    properties.gasliftprecent = props->gasliftprecent;
    properties.smartchangelitresenabled = props->smartchangelitresenabled;
    properties.coldwaterdot = props->coldwaterdot;
    properties.coldwater = props->coldwater;
    properties.coldwatermaster = props->coldwatermaster;
    properties.coldwaterpressure = props->coldwaterpressure;
    properties.coldwaterai = props->coldwaterai;
    properties.coldwaterhightemp = props->coldwaterhightemp;
    properties.coldwaterconservation = props->coldwaterconservation;
    properties.coldwaterduration = props->coldwaterduration;
    properties.coldholdduration = props->coldholdduration;
    properties.coldconservationduration = props->coldconservationduration;
    properties.waterconsumptionenabled = props->waterconsumptionenabled;
    properties.bubblemode = props->bubblemode;
    properties.sterilizationmode = props->sterilizationmode;
    properties.displayingtempunit = props->displayingtempunit;
    properties.firecapacity = props->firecapacity;
    properties.lowtemp = props->lowtemp;
    properties.hightemp = props->hightemp;
    properties.waterconsumption = props->waterconsumption;
    properties.realtimepower = props->realtimepower;
    properties.inflowtds = props->inflowtds;
    properties.gestureenabled = props->gestureenabled;
    properties.gesturetype = props->gesturetype;
    if (props->n_coldwaterappointment) {
        coldwaterappointment = calloc(props->n_coldwaterappointment, sizeof(struct hey_array_node *));
        if (coldwaterappointment == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_coldwaterappointment; i++) {
            coldwaterappointment[i] = malloc(sizeof(struct hey_array_node));
            if (coldwaterappointment[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            coldwaterappointment[i]->id = props->coldwaterappointment[i]->id;
            coldwaterappointment[i]->data.data = props->coldwaterappointment[i]->data.data;
            coldwaterappointment[i]->data.len = props->coldwaterappointment[i]->data.len;
        }
        properties.n_coldwaterappointment = props->n_coldwaterappointment;
        properties.coldwaterappointment = coldwaterappointment;
    }
    if (props->n_coldwaterpowerappointment) {
        coldwaterpowerappointment = calloc(props->n_coldwaterpowerappointment, sizeof(struct hey_array_node *));
        if (coldwaterpowerappointment == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_coldwaterpowerappointment; i++) {
            coldwaterpowerappointment[i] = malloc(sizeof(struct hey_array_node));
            if (coldwaterpowerappointment[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            coldwaterpowerappointment[i]->id = props->coldwaterpowerappointment[i]->id;
            coldwaterpowerappointment[i]->data.data = props->coldwaterpowerappointment[i]->data.data;
            coldwaterpowerappointment[i]->data.len = props->coldwaterpowerappointment[i]->data.len;
        }
        properties.n_coldwaterpowerappointment = props->n_coldwaterpowerappointment;
        properties.coldwaterpowerappointment = coldwaterpowerappointment;
    }
    properties.outflowprotect = props->outflowprotect;
    properties.outflowprotectstatus = props->outflowprotectstatus;
    ret = water_heater_properties_write_cb(n_iid, iids, &properties);

out:
    if (userdefinetemp) {
        for (int i = 0; i < props->n_userdefinetemp; i++) {
            free(userdefinetemp[i]);
        }
        free(userdefinetemp);
    }
    if (coldwaterappointment) {
        for (int i = 0; i < props->n_coldwaterappointment; i++) {
            free(coldwaterappointment[i]);
        }
        free(coldwaterappointment);
    }
    if (coldwaterpowerappointment) {
        for (int i = 0; i < props->n_coldwaterpowerappointment; i++) {
            free(coldwaterpowerappointment[i]);
        }
        free(coldwaterpowerappointment);
    }
    iot__service__water_heater__properties__free_unpacked(props, NULL);
    return ret;
}

static int32_t service_water_heater_properties_array_add_cb(void *cb_data, uint32_t iid, size_t len, uint8_t *value)
{
    switch(iid) {
    case WATER_HEATER_PROPERTY_USERDEFINETEMP:
        return water_heater_userdefinetemp_array_add_cb(len, value);
    case WATER_HEATER_PROPERTY_COLDWATERAPPOINTMENT:
        return water_heater_coldwaterappointment_array_add_cb(len, value);
    case WATER_HEATER_PROPERTY_COLDWATERPOWERAPPOINTMENT:
        return water_heater_coldwaterpowerappointment_array_add_cb(len, value);
    default:
        return -1;
    }
}

static int32_t service_water_heater_properties_array_del_cb(void *cb_data, uint32_t iid, size_t n_id, uint32_t *ids)
{
    switch(iid) {
    case WATER_HEATER_PROPERTY_USERDEFINETEMP:
        return water_heater_userdefinetemp_array_del_cb(n_id, ids);
    case WATER_HEATER_PROPERTY_COLDWATERAPPOINTMENT:
        return water_heater_coldwaterappointment_array_del_cb(n_id, ids);
    case WATER_HEATER_PROPERTY_COLDWATERPOWERAPPOINTMENT:
        return water_heater_coldwaterpowerappointment_array_del_cb(n_id, ids);
    default:
        return -1;
    }
}

static int32_t service_water_heater_properties_array_replace_cb(void *cb_data, uint32_t iid, uint32_t id, size_t len, uint8_t *value)
{
    switch(iid) {
    case WATER_HEATER_PROPERTY_USERDEFINETEMP:
        return water_heater_userdefinetemp_array_replace_cb(id, len, value);
    case WATER_HEATER_PROPERTY_COLDWATERAPPOINTMENT:
        return water_heater_coldwaterappointment_array_replace_cb(id, len, value);
    case WATER_HEATER_PROPERTY_COLDWATERPOWERAPPOINTMENT:
        return water_heater_coldwaterpowerappointment_array_replace_cb(id, len, value);
    default:
        return -1;
    }
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_water_heater_properties_write_cb,
    .array_add = service_water_heater_properties_array_add_cb,
    .array_del = service_water_heater_properties_array_del_cb,
    .array_replace = service_water_heater_properties_array_replace_cb,
};

static const struct hey_action_ctx_callbacks water_quality_reset_cbs = {
    .start = action_water_quality_reset_start_cb,
    .stop = action_water_quality_reset_stop_cb
};

static const struct hey_action_ctx_callbacks mg_reset_cbs = {
    .start = action_mg_reset_start_cb,
    .stop = action_mg_reset_stop_cb
};

static const struct hey_action_ctx_callbacks water_consumption_reset_cbs = {
    .start = action_water_consumption_reset_start_cb,
    .stop = action_water_consumption_reset_stop_cb
};

static const struct hey_action_ctx_callbacks device_factory_restore_cbs = {
    .start = action_device_factory_restore_start_cb,
    .stop = action_device_factory_restore_stop_cb
};

static const struct hey_action_entry actions_iids[] = {
    [0] = { .iid = WATER_HEATER_ACTION_WATER_QUALITY_RESET, .type = HEY_ACTION_ONCE, .cbs = &water_quality_reset_cbs },
    [1] = { .iid = WATER_HEATER_ACTION_MG_RESET, .type = HEY_ACTION_ONCE, .cbs = &mg_reset_cbs },
    [2] = { .iid = WATER_HEATER_ACTION_WATER_CONSUMPTION_RESET, .type = HEY_ACTION_ONCE, .cbs = &water_consumption_reset_cbs },
    [3] = { .iid = WATER_HEATER_ACTION_DEVICE_FACTORY_RESTORE, .type = HEY_ACTION_ONCE, .cbs = &device_factory_restore_cbs },
};

static int water_heater_service_register(Iot__Service__WaterHeater__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__water_heater__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__water_heater__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)water_heater_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    schema_srv.actions.iids = (struct hey_action_entry *)actions_iids;
    schema_srv.actions.n_iid = ACT_IID_CNT;
    water_heater_service = hey_service_register(WATER_HEATER_SERVICE, &schema_srv, NULL);
    if (NULL == water_heater_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of water heater service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t water_heater_properties_update(size_t count, uint32_t *enumerate, struct water_heater_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__WaterHeater__Properties *props = NULL;
    uint8_t *buf = NULL;
    ArrayNode **userdefinetemp = NULL;
    ArrayNode **coldwaterappointment = NULL;
    ArrayNode **coldwaterpowerappointment = NULL;
    props = malloc(sizeof(Iot__Service__WaterHeater__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__water_heater__properties__init(props);
    if (properties->n_userdefinetemp) {
        userdefinetemp = calloc(properties->n_userdefinetemp, sizeof(ArrayNode *));
        if (NULL == userdefinetemp) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_userdefinetemp; i++) {
            userdefinetemp[i] = malloc(sizeof(ArrayNode));
            if (NULL == userdefinetemp[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(userdefinetemp[i]);
            userdefinetemp[i]->id = properties->userdefinetemp[i]->id;
            userdefinetemp[i]->data.data = properties->userdefinetemp[i]->data.data;
            userdefinetemp[i]->data.len = properties->userdefinetemp[i]->data.len;
        }
    }
    if (properties->n_coldwaterappointment) {
        coldwaterappointment = calloc(properties->n_coldwaterappointment, sizeof(ArrayNode *));
        if (NULL == coldwaterappointment) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_coldwaterappointment; i++) {
            coldwaterappointment[i] = malloc(sizeof(ArrayNode));
            if (NULL == coldwaterappointment[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(coldwaterappointment[i]);
            coldwaterappointment[i]->id = properties->coldwaterappointment[i]->id;
            coldwaterappointment[i]->data.data = properties->coldwaterappointment[i]->data.data;
            coldwaterappointment[i]->data.len = properties->coldwaterappointment[i]->data.len;
        }
    }
    if (properties->n_coldwaterpowerappointment) {
        coldwaterpowerappointment = calloc(properties->n_coldwaterpowerappointment, sizeof(ArrayNode *));
        if (NULL == coldwaterpowerappointment) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_coldwaterpowerappointment; i++) {
            coldwaterpowerappointment[i] = malloc(sizeof(ArrayNode));
            if (NULL == coldwaterpowerappointment[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(coldwaterpowerappointment[i]);
            coldwaterpowerappointment[i]->id = properties->coldwaterpowerappointment[i]->id;
            coldwaterpowerappointment[i]->data.data = properties->coldwaterpowerappointment[i]->data.data;
            coldwaterpowerappointment[i]->data.len = properties->coldwaterpowerappointment[i]->data.len;
        }
    }
    props->power = properties->power;
    props->currenttemperature = properties->currenttemperature;
    props->targettemperature = properties->targettemperature;
    props->remaintime = properties->remaintime;
    props->hotwaterlevel = properties->hotwaterlevel;
    props->heaterstatus = properties->heaterstatus;
    props->heatingmode = properties->heatingmode;
    props->waterheatermode = properties->waterheatermode;
    props->waterheaterscene = properties->waterheaterscene;
    props->sterilizationenabled = properties->sterilizationenabled;
    props->eco = properties->eco;
    props->sleep = properties->sleep;
    props->volume = properties->volume;
    props->childlockenabled = properties->childlockenabled;
    props->screendisplayenabled = properties->screendisplayenabled;
    props->mgusedpercent = properties->mgusedpercent;
    props->n_userdefinetemp = properties->n_userdefinetemp;
    props->userdefinetemp = userdefinetemp;
    props->heatingpower = properties->heatingpower;
    props->tplushot = properties->tplushot;
    props->autopoweroff = properties->autopoweroff;
    props->alwaystempdetection = properties->alwaystempdetection;
    props->scenemodeenabled = properties->scenemodeenabled;
    props->waterflowstatus = properties->waterflowstatus;
    props->frequencyhot = properties->frequencyhot;
    props->frequencyhotgear = properties->frequencyhotgear;
    props->sterilizationperiod = properties->sterilizationperiod;
    props->sterilizationleftdays = properties->sterilizationleftdays;
    props->waterquality = properties->waterquality;
    props->bathremainingtime = properties->bathremainingtime;
    props->morningnightbath = properties->morningnightbath;
    props->bathtubwaterlevel = properties->bathtubwaterlevel;
    props->bathtubup = properties->bathtubup;
    props->inflowtemp = properties->inflowtemp;
    props->watervolume = properties->watervolume;
    props->firestatus = properties->firestatus;
    props->smartchangelitres = properties->smartchangelitres;
    props->gasliftprecent = properties->gasliftprecent;
    props->smartchangelitresenabled = properties->smartchangelitresenabled;
    props->coldwaterdot = properties->coldwaterdot;
    props->coldwater = properties->coldwater;
    props->coldwatermaster = properties->coldwatermaster;
    props->coldwaterpressure = properties->coldwaterpressure;
    props->coldwaterai = properties->coldwaterai;
    props->coldwaterhightemp = properties->coldwaterhightemp;
    props->coldwaterconservation = properties->coldwaterconservation;
    props->coldwaterduration = properties->coldwaterduration;
    props->coldholdduration = properties->coldholdduration;
    props->coldconservationduration = properties->coldconservationduration;
    props->waterconsumptionenabled = properties->waterconsumptionenabled;
    props->bubblemode = properties->bubblemode;
    props->sterilizationmode = properties->sterilizationmode;
    props->displayingtempunit = properties->displayingtempunit;
    props->firecapacity = properties->firecapacity;
    props->lowtemp = properties->lowtemp;
    props->hightemp = properties->hightemp;
    props->waterconsumption = properties->waterconsumption;
    props->realtimepower = properties->realtimepower;
    props->inflowtds = properties->inflowtds;
    props->gestureenabled = properties->gestureenabled;
    props->gesturetype = properties->gesturetype;
    props->n_coldwaterappointment = properties->n_coldwaterappointment;
    props->coldwaterappointment = coldwaterappointment;
    props->n_coldwaterpowerappointment = properties->n_coldwaterpowerappointment;
    props->coldwaterpowerappointment = coldwaterpowerappointment;
    props->outflowprotect = properties->outflowprotect;
    props->outflowprotectstatus = properties->outflowprotectstatus;

    size_t buf_len;
    buf_len = iot__service__water_heater__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__water_heater__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(water_heater_service, &content);

out:
    free(props);
    free(buf);
    if (userdefinetemp) {
        for (int i = 0; i < properties->n_userdefinetemp; i++) {
            free(userdefinetemp[i]);
        }
        free(userdefinetemp);
    }
    if (coldwaterappointment) {
        for (int i = 0; i < properties->n_coldwaterappointment; i++) {
            free(coldwaterappointment[i]);
        }
        free(coldwaterappointment);
    }
    if (coldwaterpowerappointment) {
        for (int i = 0; i < properties->n_coldwaterpowerappointment; i++) {
            free(coldwaterpowerappointment[i]);
        }
        free(coldwaterpowerappointment);
    }
    return ret;
}

/**
 * @brief water heater service initialization
 * @param properties [water heater service properties]
 * @return int32_t   [initialize result]
*/
int32_t water_heater_service_init(const struct water_heater_properties *properties)
{
    int ret = 0;
    Iot__Service__WaterHeater__Properties *props = NULL;
    ArrayNode **userdefinetemp = NULL;
    ArrayNode **coldwaterappointment = NULL;
    ArrayNode **coldwaterpowerappointment = NULL;
    props = malloc(sizeof(Iot__Service__WaterHeater__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__water_heater__properties__init(props);
    if (NULL != properties) {
        if (properties->n_userdefinetemp) {
            userdefinetemp = calloc(properties->n_userdefinetemp, sizeof(ArrayNode *));
            if (NULL == userdefinetemp) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_userdefinetemp; i++) {
                userdefinetemp[i] = malloc(sizeof(ArrayNode));
                if (NULL == userdefinetemp[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(userdefinetemp[i]);
                userdefinetemp[i]->id = properties->userdefinetemp[i]->id;
                userdefinetemp[i]->data.data = properties->userdefinetemp[i]->data.data;
                userdefinetemp[i]->data.len = properties->userdefinetemp[i]->data.len;
            }
        }
        if (properties->n_coldwaterappointment) {
            coldwaterappointment = calloc(properties->n_coldwaterappointment, sizeof(ArrayNode *));
            if (NULL == coldwaterappointment) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_coldwaterappointment; i++) {
                coldwaterappointment[i] = malloc(sizeof(ArrayNode));
                if (NULL == coldwaterappointment[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(coldwaterappointment[i]);
                coldwaterappointment[i]->id = properties->coldwaterappointment[i]->id;
                coldwaterappointment[i]->data.data = properties->coldwaterappointment[i]->data.data;
                coldwaterappointment[i]->data.len = properties->coldwaterappointment[i]->data.len;
            }
        }
        if (properties->n_coldwaterpowerappointment) {
            coldwaterpowerappointment = calloc(properties->n_coldwaterpowerappointment, sizeof(ArrayNode *));
            if (NULL == coldwaterpowerappointment) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_coldwaterpowerappointment; i++) {
                coldwaterpowerappointment[i] = malloc(sizeof(ArrayNode));
                if (NULL == coldwaterpowerappointment[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(coldwaterpowerappointment[i]);
                coldwaterpowerappointment[i]->id = properties->coldwaterpowerappointment[i]->id;
                coldwaterpowerappointment[i]->data.data = properties->coldwaterpowerappointment[i]->data.data;
                coldwaterpowerappointment[i]->data.len = properties->coldwaterpowerappointment[i]->data.len;
            }
        }
        props->power = properties->power;
        props->currenttemperature = properties->currenttemperature;
        props->targettemperature = properties->targettemperature;
        props->remaintime = properties->remaintime;
        props->hotwaterlevel = properties->hotwaterlevel;
        props->heaterstatus = properties->heaterstatus;
        props->heatingmode = properties->heatingmode;
        props->waterheatermode = properties->waterheatermode;
        props->waterheaterscene = properties->waterheaterscene;
        props->sterilizationenabled = properties->sterilizationenabled;
        props->eco = properties->eco;
        props->sleep = properties->sleep;
        props->volume = properties->volume;
        props->childlockenabled = properties->childlockenabled;
        props->screendisplayenabled = properties->screendisplayenabled;
        props->mgusedpercent = properties->mgusedpercent;
        props->n_userdefinetemp = properties->n_userdefinetemp;
        props->userdefinetemp = userdefinetemp;
        props->heatingpower = properties->heatingpower;
        props->tplushot = properties->tplushot;
        props->autopoweroff = properties->autopoweroff;
        props->alwaystempdetection = properties->alwaystempdetection;
        props->scenemodeenabled = properties->scenemodeenabled;
        props->waterflowstatus = properties->waterflowstatus;
        props->frequencyhot = properties->frequencyhot;
        props->frequencyhotgear = properties->frequencyhotgear;
        props->sterilizationperiod = properties->sterilizationperiod;
        props->sterilizationleftdays = properties->sterilizationleftdays;
        props->waterquality = properties->waterquality;
        props->bathremainingtime = properties->bathremainingtime;
        props->morningnightbath = properties->morningnightbath;
        props->bathtubwaterlevel = properties->bathtubwaterlevel;
        props->bathtubup = properties->bathtubup;
        props->inflowtemp = properties->inflowtemp;
        props->watervolume = properties->watervolume;
        props->firestatus = properties->firestatus;
        props->smartchangelitres = properties->smartchangelitres;
        props->gasliftprecent = properties->gasliftprecent;
        props->smartchangelitresenabled = properties->smartchangelitresenabled;
        props->coldwaterdot = properties->coldwaterdot;
        props->coldwater = properties->coldwater;
        props->coldwatermaster = properties->coldwatermaster;
        props->coldwaterpressure = properties->coldwaterpressure;
        props->coldwaterai = properties->coldwaterai;
        props->coldwaterhightemp = properties->coldwaterhightemp;
        props->coldwaterconservation = properties->coldwaterconservation;
        props->coldwaterduration = properties->coldwaterduration;
        props->coldholdduration = properties->coldholdduration;
        props->coldconservationduration = properties->coldconservationduration;
        props->waterconsumptionenabled = properties->waterconsumptionenabled;
        props->bubblemode = properties->bubblemode;
        props->sterilizationmode = properties->sterilizationmode;
        props->displayingtempunit = properties->displayingtempunit;
        props->firecapacity = properties->firecapacity;
        props->lowtemp = properties->lowtemp;
        props->hightemp = properties->hightemp;
        props->waterconsumption = properties->waterconsumption;
        props->realtimepower = properties->realtimepower;
        props->inflowtds = properties->inflowtds;
        props->gestureenabled = properties->gestureenabled;
        props->gesturetype = properties->gesturetype;
        props->n_coldwaterappointment = properties->n_coldwaterappointment;
        props->coldwaterappointment = coldwaterappointment;
        props->n_coldwaterpowerappointment = properties->n_coldwaterpowerappointment;
        props->coldwaterpowerappointment = coldwaterpowerappointment;
        props->outflowprotect = properties->outflowprotect;
        props->outflowprotectstatus = properties->outflowprotectstatus;
    }

    ret = water_heater_service_register(props);

out:
    free(props);
    if (userdefinetemp) {
        for (int i = 0; i < properties->n_userdefinetemp; i++) {
            free(userdefinetemp[i]);
        }
        free(userdefinetemp);
    }
    if (coldwaterappointment) {
        for (int i = 0; i < properties->n_coldwaterappointment; i++) {
            free(coldwaterappointment[i]);
        }
        free(coldwaterappointment);
    }
    if (coldwaterpowerappointment) {
        for (int i = 0; i < properties->n_coldwaterpowerappointment; i++) {
            free(coldwaterpowerappointment[i]);
        }
        free(coldwaterpowerappointment);
    }
    return ret;
}
