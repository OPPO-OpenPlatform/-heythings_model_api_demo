/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: devInfo.proto */

#include <errno.h>
#include <assert.h>
#include "devInfo.pb-c.h"
#include "dev_info_service.h"
#include "hey/schema.h"

#define DEV_INFO_SERVICE (1 * 256)
#define PROP_IID_CNT 24

static const struct hey_schema_property dev_info_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_GENERIC },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 9, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 11, .type = HEY_PROPERTY_TYPE_GENERIC },
    [11] = { .iid = 12, .type = HEY_PROPERTY_TYPE_GENERIC },
    [12] = { .iid = 13, .type = HEY_PROPERTY_TYPE_GENERIC },
    [13] = { .iid = 14, .type = HEY_PROPERTY_TYPE_GENERIC },
    [14] = { .iid = 15, .type = HEY_PROPERTY_TYPE_GENERIC },
    [15] = { .iid = 16, .type = HEY_PROPERTY_TYPE_GENERIC },
    [16] = { .iid = 17, .type = HEY_PROPERTY_TYPE_GENERIC },
    [17] = { .iid = 18, .type = HEY_PROPERTY_TYPE_GENERIC },
    [18] = { .iid = 19, .type = HEY_PROPERTY_TYPE_GENERIC },
    [19] = { .iid = 21, .type = HEY_PROPERTY_TYPE_GENERIC },
    [20] = { .iid = 22, .type = HEY_PROPERTY_TYPE_GENERIC },
    [21] = { .iid = 23, .type = HEY_PROPERTY_TYPE_GENERIC },
    [22] = { .iid = 24, .type = HEY_PROPERTY_TYPE_GENERIC },
    [23] = { .iid = 26, .type = HEY_PROPERTY_TYPE_GENERIC },
};
static struct hey_service *dev_info_service;

static int32_t service_dev_info_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                    size_t len, uint8_t *value)
{
    Iot__Service__DevInfo__Properties *props = iot__service__dev_info__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct dev_info_properties properties = { 0 };
    struct dev_info_dev_capability devcapability = { 0 };
    if (props->devcapability) {
        devcapability.n_network = props->devcapability->n_network;
        if (devcapability.n_network) {
            devcapability.network = malloc(devcapability.n_network * sizeof(int));
            if (devcapability.network == NULL) {
                goto out;
            }
            for (int i = 0; i < devcapability.n_network; i++) {
                devcapability.network[i] = props->devcapability->network[i];
            }
        }
        devcapability.cloudconnectable = props->devcapability->cloudconnectable;
    }
    properties.devname = props->devname;
    properties.manufacturer = props->manufacturer;
    properties.model = props->model;
    properties.brand = props->brand;
    properties.softvername = props->softvername;
    properties.did = props->did;
    properties.pid = props->pid;
    properties.cid = props->cid;
    properties.mac = props->mac;
    properties.hardver = props->hardver;
    properties.sn = props->sn;
    properties.parentdid = props->parentdid;
    properties.rssi = props->rssi;
    properties.bssid = props->bssid;
    properties.ip = props->ip;
    properties.devtime = props->devtime;
    properties.utc = props->utc;
    properties.timezone = props->timezone;
    properties.softvercode = props->softvercode;
    properties.ssid = props->ssid;
    properties.devpubkey.data = props->devpubkey.data;
    properties.devpubkey.len = props->devpubkey.len;
    properties.vendordevid = props->vendordevid;
    properties.devcapability = &devcapability;
    properties.offlinethreshold = props->offlinethreshold;
    ret = dev_info_properties_write_cb(n_iid, iids, &properties);

out:
    free(devcapability.network);
    iot__service__dev_info__properties__free_unpacked(props, NULL);
    return ret;
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_dev_info_properties_write_cb
};

static int dev_info_service_register(Iot__Service__DevInfo__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__dev_info__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__dev_info__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)dev_info_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    dev_info_service = hey_service_register(DEV_INFO_SERVICE, &schema_srv, NULL);
    if (NULL == dev_info_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of dev info service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t dev_info_properties_update(size_t count, uint32_t *enumerate, struct dev_info_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__DevInfo__Properties *props = NULL;
    uint8_t *buf = NULL;
    Iot__Service__DevInfo__DevCapability *devcapability = NULL;
    props = malloc(sizeof(Iot__Service__DevInfo__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__dev_info__properties__init(props);
    if (properties->devcapability) {
        devcapability = malloc(sizeof(Iot__Service__DevInfo__DevCapability));
        if (NULL == devcapability) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__dev_info__dev_capability__init(devcapability);
        devcapability->n_network = properties->devcapability->n_network;
        if (devcapability->n_network) {
            devcapability->network = malloc(devcapability->n_network * sizeof(int));
            if (devcapability->network == NULL) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < devcapability->n_network; i++) {
                devcapability->network[i] = properties->devcapability->network[i];
            }
        }
        devcapability->cloudconnectable = properties->devcapability->cloudconnectable;
    }
    props->devname = properties->devname;
    props->manufacturer = properties->manufacturer;
    props->model = properties->model;
    props->brand = properties->brand;
    props->softvername = properties->softvername;
    props->did = properties->did;
    props->pid = properties->pid;
    props->cid = properties->cid;
    props->mac = properties->mac;
    props->hardver = properties->hardver;
    props->sn = properties->sn;
    props->parentdid = properties->parentdid;
    props->rssi = properties->rssi;
    props->bssid = properties->bssid;
    props->ip = properties->ip;
    props->devtime = properties->devtime;
    props->utc = properties->utc;
    props->timezone = properties->timezone;
    props->softvercode = properties->softvercode;
    props->ssid = properties->ssid;
    props->devpubkey.data = properties->devpubkey.data;
    props->devpubkey.len = properties->devpubkey.len;
    props->vendordevid = properties->vendordevid;
    props->devcapability = devcapability;
    props->offlinethreshold = properties->offlinethreshold;

    size_t buf_len;
    buf_len = iot__service__dev_info__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__dev_info__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(dev_info_service, &content);

out:
    if (devcapability && devcapability->network) {
        free(devcapability->network);
    }
    free(props);
    free(buf);
    free(devcapability);
    return ret;
}

/**
 * @brief dev info service initialization
 * @param properties [dev info service properties]
 * @return int32_t   [initialize result]
*/
int32_t dev_info_service_init(const struct dev_info_properties *properties)
{
    int ret = 0;
    Iot__Service__DevInfo__Properties *props = NULL;
    Iot__Service__DevInfo__DevCapability *devcapability = NULL;
    props = malloc(sizeof(Iot__Service__DevInfo__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__dev_info__properties__init(props);
    if (NULL != properties) {
        if (properties->devcapability) {
            devcapability = malloc(sizeof(Iot__Service__DevInfo__DevCapability));
            if (NULL == devcapability) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__dev_info__dev_capability__init(devcapability);
            devcapability->n_network = properties->devcapability->n_network;
            devcapability->network = malloc(devcapability->n_network * sizeof(int));
            if (devcapability->network == NULL) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < devcapability->n_network; i++) {
                devcapability->network[i] = properties->devcapability->network[i];
            }
            devcapability->cloudconnectable = properties->devcapability->cloudconnectable;
        }
        props->devname = properties->devname;
        props->manufacturer = properties->manufacturer;
        props->model = properties->model;
        props->brand = properties->brand;
        props->softvername = properties->softvername;
        props->did = properties->did;
        props->pid = properties->pid;
        props->cid = properties->cid;
        props->mac = properties->mac;
        props->hardver = properties->hardver;
        props->sn = properties->sn;
        props->parentdid = properties->parentdid;
        props->rssi = properties->rssi;
        props->bssid = properties->bssid;
        props->ip = properties->ip;
        props->devtime = properties->devtime;
        props->utc = properties->utc;
        props->timezone = properties->timezone;
        props->softvercode = properties->softvercode;
        props->ssid = properties->ssid;
        props->devpubkey.data = properties->devpubkey.data;
        props->devpubkey.len = properties->devpubkey.len;
        props->vendordevid = properties->vendordevid;
        props->devcapability = devcapability;
        props->offlinethreshold = properties->offlinethreshold;
    }

    ret = dev_info_service_register(props);

out:
    if (devcapability && devcapability->network) {
        free(devcapability->network);
    }
    free(props);
    free(devcapability);
    return ret;
}
