/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: light.proto */

#ifndef LIGHT_SERVICE_H
#define LIGHT_SERVICE_H

#include "hey/types.h"

enum light_action_light_language_mode {
    LIGHT_ACTION_LIGHT_LANGUAGE_MODE_MISS_YOU = 0,
    LIGHT_ACTION_LIGHT_LANGUAGE_MODE_SLEEP_NOW = 1,
    LIGHT_ACTION_LIGHT_LANGUAGE_MODE_ALMOST_HOME = 2
};

enum light_study_mode_mode {
    LIGHT_STUDY_MODE_MODE_INIT = 0,
    LIGHT_STUDY_MODE_MODE_SELF_DEFINE = 1,
  /*
   *番茄钟，25分钟
   */
    LIGHT_STUDY_MODE_MODE_POMODORO = 2,
  /*
   *课堂模式，45分钟
   */
    LIGHT_STUDY_MODE_MODE_CLASSROOM = 3
};

enum light_light_mode {
    LIGHT_LIGHT_MODE_MANUAL = 0,
    LIGHT_LIGHT_MODE_READING = 1,
    LIGHT_LIGHT_MODE_SCREEN_READING = 2,
    LIGHT_LIGHT_MODE_SLEEP = 3,
    LIGHT_LIGHT_MODE_LEISURE = 4,
  /*
   *感光模式
   */
    LIGHT_LIGHT_MODE_PHOTOSENSITIVE = 5
};

struct light_rgb {
    uint32_t r;
    uint32_t g;
    uint32_t b;
};

struct light_light_language_in {
    enum light_action_light_language_mode mode;
};

struct light_light_language_out {
    char __place_holder__; // make compiler happy
};

struct light_free_control_night_light {
    bool enable;
    uint32_t starthour;
    uint32_t startmin;
    uint32_t endhour;
    uint32_t endmin;
};

struct light_scene_ctt_brightness {
    enum light_light_mode lightmode;
    uint32_t colortemp;
    uint32_t brightness;
};

struct light_study_time_setting {
    uint32_t repeatnum;
    uint32_t studytime;
    uint32_t breaktime;
};

struct light_light_study_mode {
    enum light_study_mode_mode mode;
    uint32_t duration;
    uint32_t settingtime;
};

enum LIGHT_PROPERTY {
    LIGHT_PROPERTY_POWER = 1,
    LIGHT_PROPERTY_BRIGHTNESS = 2,
    LIGHT_PROPERTY_CCT = 3,
    LIGHT_PROPERTY_LIGHTMODE = 4,
    LIGHT_PROPERTY_AUTOCOLORTEMPERATURE = 5,
    LIGHT_PROPERTY_COLORRGB = 6,
    LIGHT_PROPERTY_COLORSATURATION = 7,
    LIGHT_PROPERTY_AUTOBRIGHTNESS = 9,
    LIGHT_PROPERTY_FREECONTROLNIGHTLIGHT = 11,
    LIGHT_PROPERTY_SCENECTTBRIGHTNESS = 12,
    LIGHT_PROPERTY_COLORCTTMODE = 13,
    LIGHT_PROPERTY_STUDYTIMESETTING = 14,
    LIGHT_PROPERTY_APPOINTMENTPOWERON = 15,
    LIGHT_PROPERTY_APPOINTMENTPOWEROFF = 16,
    LIGHT_PROPERTY_LIGHTTURNOFFDELAYENABLED = 17,
    LIGHT_PROPERTY_LIGHTSTUDYMODE = 18
};

enum LIGHT_ACTION {
    LIGHT_ACTION_LIGHT_LANGUAGE = 8
};

struct light_properties {
    bool power;
    uint32_t brightness;
    uint32_t cct;
    enum light_light_mode lightmode;
    bool autocolortemperature;
    struct light_rgb *colorrgb;
    uint32_t colorsaturation;
    bool autobrightness;
    struct light_free_control_night_light *freecontrolnightlight;
    size_t n_scenecttbrightness;
    struct hey_array_node **scenecttbrightness;
    bool colorcttmode;
    struct light_study_time_setting *studytimesetting;
    uint32_t appointmentpoweron;
    uint32_t appointmentpoweroff;
    bool lightturnoffdelayenabled;
    struct light_light_study_mode *lightstudymode;
};

/**
 * @brief light service initialization
 * @param properties [light service properties]
 * @return int32_t   [initialize result]
*/
int32_t light_service_init(const struct light_properties *properties);

/**
 * @brief data at "struct hey_array_node" pack and unpack
*/
struct light_scene_ctt_brightness *light_scene_ctt_brightness_unpack(const uint8_t *data, size_t len);
void light_scene_ctt_brightness_free_unpacked(struct light_scene_ctt_brightness *data);
// less than 0 means failure
int32_t light_scene_ctt_brightness_get_packed_size(const struct light_scene_ctt_brightness *data);
// less than 0 means failure
int32_t light_scene_ctt_brightness_pack(const struct light_scene_ctt_brightness *data, uint8_t *out);

/**
 * @brief properties write callback of light service
 * @param count      [the number of properties will be written]
 * @param enumerate  [the iid enumeration of properties will be written]
 * @param properties [properties structure with written content]
 * @return int32_t   [be writed result, 0 means success]
*/
int32_t light_properties_write_cb(size_t count, uint32_t *enumerate, struct light_properties *properties);

/**
 * @brief arrayNode properties add callback of light service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t light_scenecttbrightness_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of light service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t light_scenecttbrightness_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of light service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t light_scenecttbrightness_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief update properties of light service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t light_properties_update(size_t count, uint32_t *enumerate, struct light_properties *properties);

/**
 * @brief light language action start callback of light service
 * @param ctx          [action context]
 * @param action       [light language action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t light_light_language_start_cb(struct hey_action_ctx *ctx, struct light_light_language_in *action, void **user_context);

/**
 * @brief light language action send message of light service
 * @param ctx      [action context]
 * @param action   [light language action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t light_light_language_send(struct hey_action_ctx *ctx, struct light_light_language_out *action);

/**
 * @brief light language action stop of light service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t light_light_language_stop(struct hey_action_ctx *ctx);

/**
 * @brief light language action stop callback of light service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void light_light_language_stop_cb(void *user_context);

#endif /* LIGHT_SERVICE_H */
