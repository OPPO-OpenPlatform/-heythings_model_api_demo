/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: burner.proto */

#ifndef BURNER_SERVICE_H
#define BURNER_SERVICE_H

#include "hey/types.h"

enum burner_machine_status {
    BURNER_MACHINE_STATUS_IDLE = 0,
    BURNER_MACHINE_STATUS_PREACTIVE = 1,
    BURNER_MACHINE_STATUS_ACTIVE = 2,
    BURNER_MACHINE_STATUS_STOPPED = 3,
    BURNER_MACHINE_STATUS_ERROR = 4
};

enum burner_menu_mode {
    BURNER_MENU_MODE_NONE_MODE = 0,
    BURNER_MENU_MODE_FISH_SOUP = 1,
    BURNER_MENU_MODE_CHICKEN_SOUP = 2,
    BURNER_MENU_MODE_PORKRIB_SOUP = 3,
    BURNER_MENU_MODE_STEAMING_FISH = 4,
    BURNER_MENU_MODE_STEAMING_EGG = 5,
    BURNER_MENU_MODE_DUMPLING = 6,
    BURNER_MENU_MODE_NOODLE = 7,
    BURNER_MENU_MODE_STEAK = 8
};

enum burner_steak_level {
    BURNER_STEAK_LEVEL_NONE = 0,
    BURNER_STEAK_LEVEL_RARE = 1,
    BURNER_STEAK_LEVEL_MEDIUM_RARE = 2,
    BURNER_STEAK_LEVEL_MEDIUM = 3,
    BURNER_STEAK_LEVEL_MEDIUM_WELL = 4,
    BURNER_STEAK_LEVEL_WELL_DONE = 5
};

enum burner_concentration {
    BURNER_CONCENTRATION_NONE_LEVEL = 0,
    BURNER_CONCENTRATION_LEVEL_ONE = 1,
    BURNER_CONCENTRATION_LEVEL_TWO = 2,
    BURNER_CONCENTRATION_LEVEL_THREE = 3,
    BURNER_CONCENTRATION_LEVEL_FOUR = 4
};

struct burner_turn_off_fire_in {
    char __place_holder__; // make compiler happy
};

struct burner_turn_off_fire_out {
    char __place_holder__; // make compiler happy
};

struct burner_event_dry_braised {
    char __place_holder__; // make compiler happy
};

struct burner_event_gas_detected {
    char __place_holder__; // make compiler happy
};

struct burner_event_burner_event_information {
    uint32_t messageno;
};

enum BURNER_PROPERTY {
    BURNER_PROPERTY_HEATINGLEVEL = 2,
    BURNER_PROPERTY_TARGETTEMPERATURE = 3,
    BURNER_PROPERTY_MENUMODE = 4,
    BURNER_PROPERTY_WEIGHT = 5,
    BURNER_PROPERTY_THICKNESS = 6,
    BURNER_PROPERTY_STEAKLEVEL = 7,
    BURNER_PROPERTY_CONCENTRATION = 8,
    BURNER_PROPERTY_OPERATIONTIME = 9,
    BURNER_PROPERTY_CURRENTTEMPERATURE = 10,
    BURNER_PROPERTY_MACHINESTATUS = 11,
    BURNER_PROPERTY_CONSTANTTEMPENABLED = 15,
    BURNER_PROPERTY_APPOINTMENTPOWEROFF = 16,
    BURNER_PROPERTY_FIRESTATUS = 17,
    BURNER_PROPERTY_RUNNINGDURATION = 18,
    BURNER_PROPERTY_REMAINTIME = 19
};

enum BURNER_ACTION {
    BURNER_ACTION_TURN_OFF_FIRE = 1
};

enum BURNER_EVENT {
    BURNER_EVENT_DRY_BRAISED = 12,
    BURNER_EVENT_GAS_DETECTED = 13,
    BURNER_EVENT_BURNER_EVENT_INFORMATION = 14
};

struct burner_properties {
    uint32_t heatinglevel;
    uint32_t targettemperature;
    enum burner_menu_mode menumode;
    uint32_t weight;
    uint32_t thickness;
    enum burner_steak_level steaklevel;
    enum burner_concentration concentration;
    uint32_t operationtime;
    uint32_t currenttemperature;
    enum burner_machine_status machinestatus;
    bool constanttempenabled;
    uint32_t appointmentpoweroff;
    bool firestatus;
    uint32_t runningduration;
    uint32_t remaintime;
};

/**
 * @brief burner service initialization
 * @param properties [burner service properties]
 * @return int32_t   [initialize result]
*/
int32_t burner_service_init(const struct burner_properties *properties);

/**
 * @brief data at "struct hey_array_node" pack and unpack
*/
/**
 * @brief properties write callback of burner service
 * @param count      [the number of properties will be written]
 * @param enumerate  [the iid enumeration of properties will be written]
 * @param properties [properties structure with written content]
 * @return int32_t   [be writed result, 0 means success]
*/
int32_t burner_properties_write_cb(size_t count, uint32_t *enumerate, struct burner_properties *properties);

/**
 * @brief update properties of burner service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t burner_properties_update(size_t count, uint32_t *enumerate, struct burner_properties *properties);

/**
 * @brief turn off fire action start callback of burner service
 * @param ctx          [action context]
 * @param action       [turn off fire action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t burner_turn_off_fire_start_cb(struct hey_action_ctx *ctx, struct burner_turn_off_fire_in *action, void **user_context);

/**
 * @brief turn off fire action send message of burner service
 * @param ctx      [action context]
 * @param action   [turn off fire action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t burner_turn_off_fire_send(struct hey_action_ctx *ctx, struct burner_turn_off_fire_out *action);

/**
 * @brief turn off fire action stop of burner service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t burner_turn_off_fire_stop(struct hey_action_ctx *ctx);

/**
 * @brief turn off fire action stop callback of burner service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void burner_turn_off_fire_stop_cb(void *user_context);

/**
 * @brief dry braised notify of burner service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t burner_dry_braised_notify(struct burner_event_dry_braised *event, struct hey_event_notify_attr *attr);

/**
 * @brief dry braised notify result callback of burner service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void burner_dry_braised_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief gas detected notify of burner service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t burner_gas_detected_notify(struct burner_event_gas_detected *event, struct hey_event_notify_attr *attr);

/**
 * @brief gas detected notify result callback of burner service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void burner_gas_detected_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief burner event information notify of burner service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t burner_burner_event_information_notify(struct burner_event_burner_event_information *event, struct hey_event_notify_attr *attr);

/**
 * @brief burner event information notify result callback of burner service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void burner_burner_event_information_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

#endif /* BURNER_SERVICE_H */
