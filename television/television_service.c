/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: television.proto */

#include <errno.h>
#include <assert.h>
#include "television.pb-c.h"
#include "television_service.h"
#include "hey/schema.h"

#define TELEVISION_SERVICE (50 * 256)
#define PROP_IID_CNT 11
#define ACT_IID_CNT 9
#define EV_IID_CNT 4

static const struct hey_schema_property television_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_GENERIC },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 9, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 11, .type = HEY_PROPERTY_TYPE_ARRAY },
};
static const uint32_t television_event_iids[] = { 19, 20, 21, 22 };
static struct hey_service *television_service;

static int32_t action_channel_up_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInChannelUp *channel_up = iot__service__television__action_in_channel_up__unpack(NULL, len, value);
    if (NULL == channel_up) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_channel_up_in action = { 0 };
    ret = television_channel_up_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_channel_up__free_unpacked(channel_up, NULL);
    return ret;
}

static void action_channel_up_stop_cb(void *cb_data, void *user_context)
{
    television_channel_up_stop_cb(user_context);
}

/**
 * @brief channel up action send message of television service
 * @param ctx      [action context]
 * @param action   [channel up action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_channel_up_send(struct hey_action_ctx *ctx, struct television_channel_up_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief channel up action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_channel_up_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_channel_down_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInChannelDown *channel_down = iot__service__television__action_in_channel_down__unpack(NULL, len, value);
    if (NULL == channel_down) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_channel_down_in action = { 0 };
    ret = television_channel_down_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_channel_down__free_unpacked(channel_down, NULL);
    return ret;
}

static void action_channel_down_stop_cb(void *cb_data, void *user_context)
{
    television_channel_down_stop_cb(user_context);
}

/**
 * @brief channel down action send message of television service
 * @param ctx      [action context]
 * @param action   [channel down action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_channel_down_send(struct hey_action_ctx *ctx, struct television_channel_down_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief channel down action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_channel_down_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_parent_control_playlist_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInGetParentControlPlaylist *get_parent_control_playlist = iot__service__television__action_in_get_parent_control_playlist__unpack(NULL, len, value);
    if (NULL == get_parent_control_playlist) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_get_parent_control_playlist_in action = { 0 };
    ret = television_get_parent_control_playlist_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_get_parent_control_playlist__free_unpacked(get_parent_control_playlist, NULL);
    return ret;
}

static void action_get_parent_control_playlist_stop_cb(void *cb_data, void *user_context)
{
    television_get_parent_control_playlist_stop_cb(user_context);
}

/**
 * @brief get parent control playlist action send message of television service
 * @param ctx      [action context]
 * @param action   [get parent control playlist action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_get_parent_control_playlist_send(struct hey_action_ctx *ctx, struct television_get_parent_control_playlist_out *action)
{
    int32_t ret = 0;
    Iot__Service__Television__ActionOutGetParentControlPlaylist *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Television__ActionOutGetParentControlPlaylist));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__action_out_get_parent_control_playlist__init(out);
    if (action->n_playlist) {
        out->n_playlist  = action->n_playlist;
        out->playlist = calloc(out->n_playlist, sizeof(Iot__Service__Television__ActionOutGetParentControlPlaylist__Playlist *));
        if (NULL == out->playlist) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_playlist; i++) {
            out->playlist[i] = malloc(sizeof(Iot__Service__Television__ActionOutGetParentControlPlaylist__Playlist));
            if (NULL == out->playlist[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__television__action_out_get_parent_control_playlist__playlist__init(out->playlist[i]);
            out->playlist[i]->contentname = action->playlist[i]->contentname;
            out->playlist[i]->process = action->playlist[i]->process;
            out->playlist[i]->playtime = action->playlist[i]->playtime;
        }
    }
    size_t buf_len = iot__service__television__action_out_get_parent_control_playlist__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__television__action_out_get_parent_control_playlist__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->playlist) {
        for (int i = 0; i < out->n_playlist; i++) {
            if (out->playlist[i] == NULL)
                break;
            free(out->playlist[i]);
        }
        free(out->playlist);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get parent control playlist action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_get_parent_control_playlist_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_picture_list_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInGetPictureList *get_picture_list = iot__service__television__action_in_get_picture_list__unpack(NULL, len, value);
    if (NULL == get_picture_list) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_get_picture_list_in action = { 0 };
    action.fromtime = get_picture_list->fromtime;
    action.totime = get_picture_list->totime;
    action.count = get_picture_list->count;
    ret = television_get_picture_list_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_get_picture_list__free_unpacked(get_picture_list, NULL);
    return ret;
}

static void action_get_picture_list_stop_cb(void *cb_data, void *user_context)
{
    television_get_picture_list_stop_cb(user_context);
}

/**
 * @brief get picture list action send message of television service
 * @param ctx      [action context]
 * @param action   [get picture list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_get_picture_list_send(struct hey_action_ctx *ctx, struct television_get_picture_list_out *action)
{
    int32_t ret = 0;
    Iot__Service__Television__ActionOutGetPictureList *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Television__ActionOutGetPictureList));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__action_out_get_picture_list__init(out);
    out->totalcount = action->totalcount;
    if (action->n_pictureinfo) {
        out->n_pictureinfo  = action->n_pictureinfo;
        out->pictureinfo = calloc(out->n_pictureinfo, sizeof(Iot__Service__Television__ActionOutGetPictureList__PictureInfo *));
        if (NULL == out->pictureinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_pictureinfo; i++) {
            out->pictureinfo[i] = malloc(sizeof(Iot__Service__Television__ActionOutGetPictureList__PictureInfo));
            if (NULL == out->pictureinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__television__action_out_get_picture_list__picture_info__init(out->pictureinfo[i]);
            out->pictureinfo[i]->filename = action->pictureinfo[i]->filename;
            out->pictureinfo[i]->capturetime = action->pictureinfo[i]->capturetime;
        }
    }
    size_t buf_len = iot__service__television__action_out_get_picture_list__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__television__action_out_get_picture_list__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->pictureinfo) {
        for (int i = 0; i < out->n_pictureinfo; i++) {
            if (out->pictureinfo[i] == NULL)
                break;
            free(out->pictureinfo[i]);
        }
        free(out->pictureinfo);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get picture list action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_get_picture_list_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_record_list_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInGetRecordList *get_record_list = iot__service__television__action_in_get_record_list__unpack(NULL, len, value);
    if (NULL == get_record_list) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_get_record_list_in action = { 0 };
    action.fromtime = get_record_list->fromtime;
    action.totime = get_record_list->totime;
    action.recordcount = get_record_list->recordcount;
    ret = television_get_record_list_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_get_record_list__free_unpacked(get_record_list, NULL);
    return ret;
}

static void action_get_record_list_stop_cb(void *cb_data, void *user_context)
{
    television_get_record_list_stop_cb(user_context);
}

/**
 * @brief get record list action send message of television service
 * @param ctx      [action context]
 * @param action   [get record list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_get_record_list_send(struct hey_action_ctx *ctx, struct television_get_record_list_out *action)
{
    int32_t ret = 0;
    Iot__Service__Television__ActionOutGetRecordList *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Television__ActionOutGetRecordList));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__action_out_get_record_list__init(out);
    out->totalrecordcount = action->totalrecordcount;
    if (action->n_pictureinfo) {
        out->n_pictureinfo  = action->n_pictureinfo;
        out->pictureinfo = calloc(out->n_pictureinfo, sizeof(Iot__Service__Television__ActionOutGetRecordList__PictureInfo *));
        if (NULL == out->pictureinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_pictureinfo; i++) {
            out->pictureinfo[i] = malloc(sizeof(Iot__Service__Television__ActionOutGetRecordList__PictureInfo));
            if (NULL == out->pictureinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__television__action_out_get_record_list__picture_info__init(out->pictureinfo[i]);
            out->pictureinfo[i]->recordfilename = action->pictureinfo[i]->recordfilename;
            out->pictureinfo[i]->thumbnailfilename = action->pictureinfo[i]->thumbnailfilename;
            out->pictureinfo[i]->recordstarttime = action->pictureinfo[i]->recordstarttime;
            out->pictureinfo[i]->recordelapsedtime = action->pictureinfo[i]->recordelapsedtime;
            out->pictureinfo[i]->autodeleteenabled = action->pictureinfo[i]->autodeleteenabled;
            if (action->pictureinfo[i]->n_recordpoint) {
                out->pictureinfo[i]->n_recordpoint = action->pictureinfo[i]->n_recordpoint;
                out->pictureinfo[i]->recordpoint = calloc(out->pictureinfo[i]->n_recordpoint, sizeof(Iot__Service__Television__ActionOutGetRecordList__PictureInfo__RecordPoint *));
                if (NULL == out->pictureinfo[i]->recordpoint) {
                    ret = ENOMEM;
                    goto out;
                }
                for (int j = 0; j < out->pictureinfo[i]->n_recordpoint; j++) {
                    out->pictureinfo[i]->recordpoint[j] = malloc(sizeof(Iot__Service__Television__ActionOutGetRecordList__PictureInfo__RecordPoint));
                    if (NULL == out->pictureinfo[i]->recordpoint[j]) {
                        ret = ENOMEM;
                        goto out;
                    }
                    iot__service__television__action_out_get_record_list__picture_info__record_point__init(out->pictureinfo[i]->recordpoint[j]);
                    out->pictureinfo[i]->recordpoint[j]->recordtype = action->pictureinfo[i]->recordpoint[j]->recordtype;
                    out->pictureinfo[i]->recordpoint[j]->characteristicpoint = action->pictureinfo[i]->recordpoint[j]->characteristicpoint;
                }
            }
        }
    }
    size_t buf_len = iot__service__television__action_out_get_record_list__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__television__action_out_get_record_list__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->pictureinfo) {
        for (int i = 0; i < out->n_pictureinfo; i++) {
            if (out->pictureinfo[i] == NULL)
                break;
            if (out->pictureinfo[i]->recordpoint) {
                for (int j = 0; j < out->pictureinfo[i]->n_recordpoint; j++) {
                    if (out->pictureinfo[i]->recordpoint[j] == NULL)
                        break;
                    free(out->pictureinfo[i]->recordpoint[j]);
                }
                free(out->pictureinfo[i]->recordpoint);
            }
            free(out->pictureinfo[i]);
        }
        free(out->pictureinfo);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get record list action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_get_record_list_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_del_record_info_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInDelRecordInfo *del_record_info = iot__service__television__action_in_del_record_info__unpack(NULL, len, value);
    if (NULL == del_record_info) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_del_record_info_in action = { 0 };
    action.n_filename = del_record_info->n_filename;
    action.filename = del_record_info->filename;
    ret = television_del_record_info_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_del_record_info__free_unpacked(del_record_info, NULL);
    return ret;
}

static void action_del_record_info_stop_cb(void *cb_data, void *user_context)
{
    television_del_record_info_stop_cb(user_context);
}

/**
 * @brief del record info action send message of television service
 * @param ctx      [action context]
 * @param action   [del record info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_del_record_info_send(struct hey_action_ctx *ctx, struct television_del_record_info_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief del record info action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_del_record_info_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_del_picture_info_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInDelPictureInfo *del_picture_info = iot__service__television__action_in_del_picture_info__unpack(NULL, len, value);
    if (NULL == del_picture_info) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_del_picture_info_in action = { 0 };
    action.n_filename = del_picture_info->n_filename;
    action.filename = del_picture_info->filename;
    ret = television_del_picture_info_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_del_picture_info__free_unpacked(del_picture_info, NULL);
    return ret;
}

static void action_del_picture_info_stop_cb(void *cb_data, void *user_context)
{
    television_del_picture_info_stop_cb(user_context);
}

/**
 * @brief del picture info action send message of television service
 * @param ctx      [action context]
 * @param action   [del picture info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_del_picture_info_send(struct hey_action_ctx *ctx, struct television_del_picture_info_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief del picture info action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_del_picture_info_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_parent_control_time_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInGetParentControlTime *get_parent_control_time = iot__service__television__action_in_get_parent_control_time__unpack(NULL, len, value);
    if (NULL == get_parent_control_time) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_get_parent_control_time_in action = { 0 };
    ret = television_get_parent_control_time_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_get_parent_control_time__free_unpacked(get_parent_control_time, NULL);
    return ret;
}

static void action_get_parent_control_time_stop_cb(void *cb_data, void *user_context)
{
    television_get_parent_control_time_stop_cb(user_context);
}

/**
 * @brief get parent control time action send message of television service
 * @param ctx      [action context]
 * @param action   [get parent control time action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_get_parent_control_time_send(struct hey_action_ctx *ctx, struct television_get_parent_control_time_out *action)
{
    int32_t ret = 0;
    Iot__Service__Television__ActionOutGetParentControlTime *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Television__ActionOutGetParentControlTime));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__action_out_get_parent_control_time__init(out);
    out->parentcontroltime = action->parentcontroltime;
    out->totalparentcontroltime = action->totalparentcontroltime;
    size_t buf_len = iot__service__television__action_out_get_parent_control_time__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__television__action_out_get_parent_control_time__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get parent control time action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_get_parent_control_time_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_remain_in_parent_control_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Television__ActionInRemainInParentControl *remain_in_parent_control = iot__service__television__action_in_remain_in_parent_control__unpack(NULL, len, value);
    if (NULL == remain_in_parent_control) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct television_remain_in_parent_control_in action = { 0 };
    ret = television_remain_in_parent_control_start_cb(ctx, &action, user_context);

    iot__service__television__action_in_remain_in_parent_control__free_unpacked(remain_in_parent_control, NULL);
    return ret;
}

static void action_remain_in_parent_control_stop_cb(void *cb_data, void *user_context)
{
    television_remain_in_parent_control_stop_cb(user_context);
}

/**
 * @brief remain in parent control action send message of television service
 * @param ctx      [action context]
 * @param action   [remain in parent control action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t television_remain_in_parent_control_send(struct hey_action_ctx *ctx, struct television_remain_in_parent_control_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief remain in parent control action stop of television service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t television_remain_in_parent_control_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static Iot__Service__Television__Channel *_television_channel = NULL;
struct television_channel *television_channel_unpack(const uint8_t *data, size_t len)
{
    _television_channel = iot__service__television__channel__unpack(NULL, len, data);
    if (NULL == _television_channel) {
        return NULL;
    }
    struct television_channel *hey_struct = malloc(sizeof(struct television_channel));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->channelid = _television_channel->channelid;
    hey_struct->channelname = _television_channel->channelname;
    return hey_struct;
out1:
    iot__service__television__channel__free_unpacked(_television_channel, NULL);
    return NULL;
}

void television_channel_free_unpacked(struct television_channel *data)
{
    assert(NULL != data);
    iot__service__television__channel__free_unpacked(_television_channel, NULL);
    free(data);
}

int32_t television_channel_get_packed_size(const struct television_channel *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Television__Channel *pb_struct = malloc(sizeof(Iot__Service__Television__Channel));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__television__channel__init(pb_struct);
    pb_struct->channelid = data->channelid;
    pb_struct->channelname = data->channelname;
    ret = iot__service__television__channel__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t television_channel_pack(const struct television_channel *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Television__Channel *pb_struct = malloc(sizeof(Iot__Service__Television__Channel));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__television__channel__init(pb_struct);
    pb_struct->channelid = data->channelid;
    pb_struct->channelname = data->channelname;
    ret = iot__service__television__channel__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static int32_t service_television_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                      size_t len, uint8_t *value)
{
    Iot__Service__Television__Properties *props = iot__service__television__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct television_properties properties = { 0 };
    struct hey_array_node **channel = NULL;
    properties.power = props->power;
    properties.sleep = props->sleep;
    properties.soundvolume = props->soundvolume;
    properties.speechcontrolenabled = props->speechcontrolenabled;
    properties.sourceinput = props->sourceinput;
    properties.status = props->status;
    properties.parentcontrolsenabled = props->parentcontrolsenabled;
    properties.singlewatchingtvtime = props->singlewatchingtvtime;
    properties.mute = props->mute;
    properties.currentchannel = props->currentchannel;
    if (props->n_channel) {
        channel = calloc(props->n_channel, sizeof(struct hey_array_node *));
        if (channel == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_channel; i++) {
            channel[i] = malloc(sizeof(struct hey_array_node));
            if (channel[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            channel[i]->id = props->channel[i]->id;
            channel[i]->data.data = props->channel[i]->data.data;
            channel[i]->data.len = props->channel[i]->data.len;
        }
        properties.n_channel = props->n_channel;
        properties.channel = channel;
    }
    ret = television_properties_write_cb(n_iid, iids, &properties);

out:
    if (channel) {
        for (int i = 0; i < props->n_channel; i++) {
            free(channel[i]);
        }
        free(channel);
    }
    iot__service__television__properties__free_unpacked(props, NULL);
    return ret;
}

static int32_t service_television_properties_array_add_cb(void *cb_data, uint32_t iid, size_t len, uint8_t *value)
{
    switch(iid) {
    case TELEVISION_PROPERTY_CHANNEL:
        return television_channel_array_add_cb(len, value);
    default:
        return -1;
    }
}

static int32_t service_television_properties_array_del_cb(void *cb_data, uint32_t iid, size_t n_id, uint32_t *ids)
{
    switch(iid) {
    case TELEVISION_PROPERTY_CHANNEL:
        return television_channel_array_del_cb(n_id, ids);
    default:
        return -1;
    }
}

static int32_t service_television_properties_array_replace_cb(void *cb_data, uint32_t iid, uint32_t id, size_t len, uint8_t *value)
{
    switch(iid) {
    case TELEVISION_PROPERTY_CHANNEL:
        return television_channel_array_replace_cb(id, len, value);
    default:
        return -1;
    }
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_television_properties_write_cb,
    .array_add = service_television_properties_array_add_cb,
    .array_del = service_television_properties_array_del_cb,
    .array_replace = service_television_properties_array_replace_cb,
};

static const struct hey_action_ctx_callbacks channel_up_cbs = {
    .start = action_channel_up_start_cb,
    .stop = action_channel_up_stop_cb
};

static const struct hey_action_ctx_callbacks channel_down_cbs = {
    .start = action_channel_down_start_cb,
    .stop = action_channel_down_stop_cb
};

static const struct hey_action_ctx_callbacks get_parent_control_playlist_cbs = {
    .start = action_get_parent_control_playlist_start_cb,
    .stop = action_get_parent_control_playlist_stop_cb
};

static const struct hey_action_ctx_callbacks get_picture_list_cbs = {
    .start = action_get_picture_list_start_cb,
    .stop = action_get_picture_list_stop_cb
};

static const struct hey_action_ctx_callbacks get_record_list_cbs = {
    .start = action_get_record_list_start_cb,
    .stop = action_get_record_list_stop_cb
};

static const struct hey_action_ctx_callbacks del_record_info_cbs = {
    .start = action_del_record_info_start_cb,
    .stop = action_del_record_info_stop_cb
};

static const struct hey_action_ctx_callbacks del_picture_info_cbs = {
    .start = action_del_picture_info_start_cb,
    .stop = action_del_picture_info_stop_cb
};

static const struct hey_action_ctx_callbacks get_parent_control_time_cbs = {
    .start = action_get_parent_control_time_start_cb,
    .stop = action_get_parent_control_time_stop_cb
};

static const struct hey_action_ctx_callbacks remain_in_parent_control_cbs = {
    .start = action_remain_in_parent_control_start_cb,
    .stop = action_remain_in_parent_control_stop_cb
};

static const struct hey_action_entry actions_iids[] = {
    [0] = { .iid = TELEVISION_ACTION_CHANNEL_UP, .type = HEY_ACTION_ONCE, .cbs = &channel_up_cbs },
    [1] = { .iid = TELEVISION_ACTION_CHANNEL_DOWN, .type = HEY_ACTION_ONCE, .cbs = &channel_down_cbs },
    [2] = { .iid = TELEVISION_ACTION_GET_PARENT_CONTROL_PLAYLIST, .type = HEY_ACTION_ONCE, .cbs = &get_parent_control_playlist_cbs },
    [3] = { .iid = TELEVISION_ACTION_GET_PICTURE_LIST, .type = HEY_ACTION_IN_ONCE_OUT_STREAM, .cbs = &get_picture_list_cbs },
    [4] = { .iid = TELEVISION_ACTION_GET_RECORD_LIST, .type = HEY_ACTION_IN_ONCE_OUT_STREAM, .cbs = &get_record_list_cbs },
    [5] = { .iid = TELEVISION_ACTION_DEL_RECORD_INFO, .type = HEY_ACTION_ONCE, .cbs = &del_record_info_cbs },
    [6] = { .iid = TELEVISION_ACTION_DEL_PICTURE_INFO, .type = HEY_ACTION_ONCE, .cbs = &del_picture_info_cbs },
    [7] = { .iid = TELEVISION_ACTION_GET_PARENT_CONTROL_TIME, .type = HEY_ACTION_ONCE, .cbs = &get_parent_control_time_cbs },
    [8] = { .iid = TELEVISION_ACTION_REMAIN_IN_PARENT_CONTROL, .type = HEY_ACTION_ONCE, .cbs = &remain_in_parent_control_cbs },
};

static int television_service_register(Iot__Service__Television__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__television__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__television__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)television_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    schema_srv.actions.iids = (struct hey_action_entry *)actions_iids;
    schema_srv.actions.n_iid = ACT_IID_CNT;
    schema_srv.events.iids = (uint32_t *)television_event_iids;
    schema_srv.events.n_iid = EV_IID_CNT;
    television_service = hey_service_register(TELEVISION_SERVICE, &schema_srv, NULL);
    if (NULL == television_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of television service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t television_properties_update(size_t count, uint32_t *enumerate, struct television_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__Television__Properties *props = NULL;
    uint8_t *buf = NULL;
    ArrayNode **channel = NULL;
    props = malloc(sizeof(Iot__Service__Television__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__properties__init(props);
    if (properties->n_channel) {
        channel = calloc(properties->n_channel, sizeof(ArrayNode *));
        if (NULL == channel) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_channel; i++) {
            channel[i] = malloc(sizeof(ArrayNode));
            if (NULL == channel[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(channel[i]);
            channel[i]->id = properties->channel[i]->id;
            channel[i]->data.data = properties->channel[i]->data.data;
            channel[i]->data.len = properties->channel[i]->data.len;
        }
    }
    props->power = properties->power;
    props->sleep = properties->sleep;
    props->soundvolume = properties->soundvolume;
    props->speechcontrolenabled = properties->speechcontrolenabled;
    props->sourceinput = properties->sourceinput;
    props->status = properties->status;
    props->parentcontrolsenabled = properties->parentcontrolsenabled;
    props->singlewatchingtvtime = properties->singlewatchingtvtime;
    props->mute = properties->mute;
    props->currentchannel = properties->currentchannel;
    props->n_channel = properties->n_channel;
    props->channel = channel;

    size_t buf_len;
    buf_len = iot__service__television__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__television__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(television_service, &content);

out:
    free(props);
    free(buf);
    if (channel) {
        for (int i = 0; i < properties->n_channel; i++) {
            free(channel[i]);
        }
        free(channel);
    }
    return ret;
}

/**
 * @brief television service initialization
 * @param properties [television service properties]
 * @return int32_t   [initialize result]
*/
int32_t television_service_init(const struct television_properties *properties)
{
    int ret = 0;
    Iot__Service__Television__Properties *props = NULL;
    ArrayNode **channel = NULL;
    props = malloc(sizeof(Iot__Service__Television__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__television__properties__init(props);
    if (NULL != properties) {
        if (properties->n_channel) {
            channel = calloc(properties->n_channel, sizeof(ArrayNode *));
            if (NULL == channel) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_channel; i++) {
                channel[i] = malloc(sizeof(ArrayNode));
                if (NULL == channel[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(channel[i]);
                channel[i]->id = properties->channel[i]->id;
                channel[i]->data.data = properties->channel[i]->data.data;
                channel[i]->data.len = properties->channel[i]->data.len;
            }
        }
        props->power = properties->power;
        props->sleep = properties->sleep;
        props->soundvolume = properties->soundvolume;
        props->speechcontrolenabled = properties->speechcontrolenabled;
        props->sourceinput = properties->sourceinput;
        props->status = properties->status;
        props->parentcontrolsenabled = properties->parentcontrolsenabled;
        props->singlewatchingtvtime = properties->singlewatchingtvtime;
        props->mute = properties->mute;
        props->currentchannel = properties->currentchannel;
        props->n_channel = properties->n_channel;
        props->channel = channel;
    }

    ret = television_service_register(props);

out:
    free(props);
    if (channel) {
        for (int i = 0; i < properties->n_channel; i++) {
            free(channel[i]);
        }
        free(channel);
    }
    return ret;
}

/**
 * @brief record notify notify of television service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t television_record_notify_notify(struct television_event_record_notify *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Television__EventRecordNotify *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Television__EventRecordNotify));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__television__event_record_notify__init(ev);
    ev->filename = event->filename;
    ev->mediatype = event->mediatype;

    size_t buf_len;
    buf_len = iot__service__television__event_record_notify__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__television__event_record_notify__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = TELEVISION_EVENT_RECORD_NOTIFY,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(television_service, &content, television_record_notify_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief channel list change notify of television service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t television_channel_list_change_notify(struct television_event_channel_list_change *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    struct hey_event_notify_content content = {
        .iid = TELEVISION_EVENT_CHANNEL_LIST_CHANGE,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = 0,
        .value = NULL,
    };
    ret = hey_event_notify(television_service, &content, television_channel_list_change_notify_result_cb, attr->ctx);

    return ret;
}

/**
 * @brief parent controls mode start notify of television service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t television_parent_controls_mode_start_notify(struct television_event_parent_controls_mode_start *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    struct hey_event_notify_content content = {
        .iid = TELEVISION_EVENT_PARENT_CONTROLS_MODE_START,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = 0,
        .value = NULL,
    };
    ret = hey_event_notify(television_service, &content, television_parent_controls_mode_start_notify_result_cb, attr->ctx);

    return ret;
}

/**
 * @brief parent controls mode stop notify of television service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t television_parent_controls_mode_stop_notify(struct television_event_parent_controls_mode_stop *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    struct hey_event_notify_content content = {
        .iid = TELEVISION_EVENT_PARENT_CONTROLS_MODE_STOP,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = 0,
        .value = NULL,
    };
    ret = hey_event_notify(television_service, &content, television_parent_controls_mode_stop_notify_result_cb, attr->ctx);

    return ret;
}
