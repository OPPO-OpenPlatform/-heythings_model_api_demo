/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: mobileNetwork.proto */

#include <errno.h>
#include <assert.h>
#include "mobileNetwork.pb-c.h"
#include "mobile_network_service.h"
#include "hey/schema.h"

#define MOBILE_NETWORK_SERVICE (75 * 256)
#define PROP_IID_CNT 15
#define ACT_IID_CNT 2

static const struct hey_schema_property mobile_network_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_ARRAY },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 11, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 12, .type = HEY_PROPERTY_TYPE_GENERIC },
    [11] = { .iid = 13, .type = HEY_PROPERTY_TYPE_GENERIC },
    [12] = { .iid = 15, .type = HEY_PROPERTY_TYPE_ARRAY },
    [13] = { .iid = 16, .type = HEY_PROPERTY_TYPE_GENERIC },
    [14] = { .iid = 17, .type = HEY_PROPERTY_TYPE_GENERIC },
};
static struct hey_service *mobile_network_service;

static int32_t action_signal_test_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__MobileNetwork__ActionInSignalTest *signal_test = iot__service__mobile_network__action_in_signal_test__unpack(NULL, len, value);
    if (NULL == signal_test) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct mobile_network_signal_test_in action = { 0 };
    ret = mobile_network_signal_test_start_cb(ctx, &action, user_context);

    iot__service__mobile_network__action_in_signal_test__free_unpacked(signal_test, NULL);
    return ret;
}

static void action_signal_test_stop_cb(void *cb_data, void *user_context)
{
    mobile_network_signal_test_stop_cb(user_context);
}

/**
 * @brief signal test action send message of mobile network service
 * @param ctx      [action context]
 * @param action   [signal test action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t mobile_network_signal_test_send(struct hey_action_ctx *ctx, struct mobile_network_signal_test_out *action)
{
    int32_t ret = 0;
    Iot__Service__MobileNetwork__ActionOutSignalTest *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__MobileNetwork__ActionOutSignalTest));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__mobile_network__action_out_signal_test__init(out);
    out->signalscore = action->signalscore;
    size_t buf_len = iot__service__mobile_network__action_out_signal_test__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__mobile_network__action_out_signal_test__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief signal test action stop of mobile network service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t mobile_network_signal_test_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_modify_pin_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__MobileNetwork__ActionInModifyPIN *modify_pin = iot__service__mobile_network__action_in_modify_pin__unpack(NULL, len, value);
    if (NULL == modify_pin) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct mobile_network_modify_pin_in action = { 0 };
    action.oldpin = modify_pin->oldpin;
    action.newpin = modify_pin->newpin;
    ret = mobile_network_modify_pin_start_cb(ctx, &action, user_context);

    iot__service__mobile_network__action_in_modify_pin__free_unpacked(modify_pin, NULL);
    return ret;
}

static void action_modify_pin_stop_cb(void *cb_data, void *user_context)
{
    mobile_network_modify_pin_stop_cb(user_context);
}

/**
 * @brief modify pin action send message of mobile network service
 * @param ctx      [action context]
 * @param action   [modify pin action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t mobile_network_modify_pin_send(struct hey_action_ctx *ctx, struct mobile_network_modify_pin_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief modify pin action stop of mobile network service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t mobile_network_modify_pin_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static Iot__Service__MobileNetwork__NetworkInfo *_mobile_network_network_info = NULL;
struct mobile_network_network_info *mobile_network_network_info_unpack(const uint8_t *data, size_t len)
{
    _mobile_network_network_info = iot__service__mobile_network__network_info__unpack(NULL, len, data);
    if (NULL == _mobile_network_network_info) {
        return NULL;
    }
    struct mobile_network_network_info *hey_struct = malloc(sizeof(struct mobile_network_network_info));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->linkstatus = _mobile_network_network_info->linkstatus;
    hey_struct->operatorname = _mobile_network_network_info->operatorname;
    hey_struct->signalstrength = _mobile_network_network_info->signalstrength;
    hey_struct->uploadrate = _mobile_network_network_info->uploadrate;
    hey_struct->downloadrate = _mobile_network_network_info->downloadrate;
    return hey_struct;
out1:
    iot__service__mobile_network__network_info__free_unpacked(_mobile_network_network_info, NULL);
    return NULL;
}

void mobile_network_network_info_free_unpacked(struct mobile_network_network_info *data)
{
    assert(NULL != data);
    iot__service__mobile_network__network_info__free_unpacked(_mobile_network_network_info, NULL);
    free(data);
}

int32_t mobile_network_network_info_get_packed_size(const struct mobile_network_network_info *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__MobileNetwork__NetworkInfo *pb_struct = malloc(sizeof(Iot__Service__MobileNetwork__NetworkInfo));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__mobile_network__network_info__init(pb_struct);
    pb_struct->linkstatus = data->linkstatus;
    pb_struct->operatorname = data->operatorname;
    pb_struct->signalstrength = data->signalstrength;
    pb_struct->uploadrate = data->uploadrate;
    pb_struct->downloadrate = data->downloadrate;
    ret = iot__service__mobile_network__network_info__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t mobile_network_network_info_pack(const struct mobile_network_network_info *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__MobileNetwork__NetworkInfo *pb_struct = malloc(sizeof(Iot__Service__MobileNetwork__NetworkInfo));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__mobile_network__network_info__init(pb_struct);
    pb_struct->linkstatus = data->linkstatus;
    pb_struct->operatorname = data->operatorname;
    pb_struct->signalstrength = data->signalstrength;
    pb_struct->uploadrate = data->uploadrate;
    pb_struct->downloadrate = data->downloadrate;
    ret = iot__service__mobile_network__network_info__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__MobileNetwork__Apn *_mobile_network_apn = NULL;
struct mobile_network_apn *mobile_network_apn_unpack(const uint8_t *data, size_t len)
{
    _mobile_network_apn = iot__service__mobile_network__apn__unpack(NULL, len, data);
    if (NULL == _mobile_network_apn) {
        return NULL;
    }
    struct mobile_network_apn *hey_struct = malloc(sizeof(struct mobile_network_apn));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->username = _mobile_network_apn->username;
    hey_struct->password = _mobile_network_apn->password;
    hey_struct->certification = _mobile_network_apn->certification;
    hey_struct->apn = _mobile_network_apn->apn;
    return hey_struct;
out1:
    iot__service__mobile_network__apn__free_unpacked(_mobile_network_apn, NULL);
    return NULL;
}

void mobile_network_apn_free_unpacked(struct mobile_network_apn *data)
{
    assert(NULL != data);
    iot__service__mobile_network__apn__free_unpacked(_mobile_network_apn, NULL);
    free(data);
}

int32_t mobile_network_apn_get_packed_size(const struct mobile_network_apn *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__MobileNetwork__Apn *pb_struct = malloc(sizeof(Iot__Service__MobileNetwork__Apn));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__mobile_network__apn__init(pb_struct);
    pb_struct->username = data->username;
    pb_struct->password = data->password;
    pb_struct->certification = data->certification;
    pb_struct->apn = data->apn;
    ret = iot__service__mobile_network__apn__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t mobile_network_apn_pack(const struct mobile_network_apn *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__MobileNetwork__Apn *pb_struct = malloc(sizeof(Iot__Service__MobileNetwork__Apn));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__mobile_network__apn__init(pb_struct);
    pb_struct->username = data->username;
    pb_struct->password = data->password;
    pb_struct->certification = data->certification;
    pb_struct->apn = data->apn;
    ret = iot__service__mobile_network__apn__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static int32_t service_mobile_network_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                          size_t len, uint8_t *value)
{
    Iot__Service__MobileNetwork__Properties *props = iot__service__mobile_network__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct mobile_network_properties properties = { 0 };
    struct hey_array_node **networkinfo = NULL;
    struct hey_array_node **apn = NULL;
    if (props->n_networkinfo) {
        networkinfo = calloc(props->n_networkinfo, sizeof(struct hey_array_node *));
        if (networkinfo == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_networkinfo; i++) {
            networkinfo[i] = malloc(sizeof(struct hey_array_node));
            if (networkinfo[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            networkinfo[i]->id = props->networkinfo[i]->id;
            networkinfo[i]->data.data = props->networkinfo[i]->data.data;
            networkinfo[i]->data.len = props->networkinfo[i]->data.len;
        }
        properties.n_networkinfo = props->n_networkinfo;
        properties.networkinfo = networkinfo;
    }
    properties.mobilenetworkipv4 = props->mobilenetworkipv4;
    properties.mobilenetworkipv6 = props->mobilenetworkipv6;
    properties.cellid = props->cellid;
    properties.rsrp = props->rsrp;
    properties.plmn = props->plmn;
    properties.imei = props->imei;
    properties.imsi = props->imsi;
    properties.mobilenetworkenabled = props->mobilenetworkenabled;
    properties.mobilenetworkromingenabled = props->mobilenetworkromingenabled;
    properties.mobilenetworkmode = props->mobilenetworkmode;
    properties.simpin = props->simpin;
    if (props->n_apn) {
        apn = calloc(props->n_apn, sizeof(struct hey_array_node *));
        if (apn == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_apn; i++) {
            apn[i] = malloc(sizeof(struct hey_array_node));
            if (apn[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            apn[i]->id = props->apn[i]->id;
            apn[i]->data.data = props->apn[i]->data.data;
            apn[i]->data.len = props->apn[i]->data.len;
        }
        properties.n_apn = props->n_apn;
        properties.apn = apn;
    }
    properties.mobilegateway = props->mobilegateway;
    properties.mobiledns = props->mobiledns;
    ret = mobile_network_properties_write_cb(n_iid, iids, &properties);

out:
    if (networkinfo) {
        for (int i = 0; i < props->n_networkinfo; i++) {
            free(networkinfo[i]);
        }
        free(networkinfo);
    }
    if (apn) {
        for (int i = 0; i < props->n_apn; i++) {
            free(apn[i]);
        }
        free(apn);
    }
    iot__service__mobile_network__properties__free_unpacked(props, NULL);
    return ret;
}

static int32_t service_mobile_network_properties_array_add_cb(void *cb_data, uint32_t iid, size_t len, uint8_t *value)
{
    switch(iid) {
    case MOBILE_NETWORK_PROPERTY_NETWORKINFO:
        return mobile_network_networkinfo_array_add_cb(len, value);
    case MOBILE_NETWORK_PROPERTY_APN:
        return mobile_network_apn_array_add_cb(len, value);
    default:
        return -1;
    }
}

static int32_t service_mobile_network_properties_array_del_cb(void *cb_data, uint32_t iid, size_t n_id, uint32_t *ids)
{
    switch(iid) {
    case MOBILE_NETWORK_PROPERTY_NETWORKINFO:
        return mobile_network_networkinfo_array_del_cb(n_id, ids);
    case MOBILE_NETWORK_PROPERTY_APN:
        return mobile_network_apn_array_del_cb(n_id, ids);
    default:
        return -1;
    }
}

static int32_t service_mobile_network_properties_array_replace_cb(void *cb_data, uint32_t iid, uint32_t id, size_t len, uint8_t *value)
{
    switch(iid) {
    case MOBILE_NETWORK_PROPERTY_NETWORKINFO:
        return mobile_network_networkinfo_array_replace_cb(id, len, value);
    case MOBILE_NETWORK_PROPERTY_APN:
        return mobile_network_apn_array_replace_cb(id, len, value);
    default:
        return -1;
    }
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_mobile_network_properties_write_cb,
    .array_add = service_mobile_network_properties_array_add_cb,
    .array_del = service_mobile_network_properties_array_del_cb,
    .array_replace = service_mobile_network_properties_array_replace_cb,
};

static const struct hey_action_ctx_callbacks signal_test_cbs = {
    .start = action_signal_test_start_cb,
    .stop = action_signal_test_stop_cb
};

static const struct hey_action_ctx_callbacks modify_pin_cbs = {
    .start = action_modify_pin_start_cb,
    .stop = action_modify_pin_stop_cb
};

static const struct hey_action_entry actions_iids[] = {
    [0] = { .iid = MOBILE_NETWORK_ACTION_SIGNAL_TEST, .type = HEY_ACTION_ONCE, .cbs = &signal_test_cbs },
    [1] = { .iid = MOBILE_NETWORK_ACTION_MODIFY_PIN, .type = HEY_ACTION_ONCE, .cbs = &modify_pin_cbs },
};

static int mobile_network_service_register(Iot__Service__MobileNetwork__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__mobile_network__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__mobile_network__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)mobile_network_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    schema_srv.actions.iids = (struct hey_action_entry *)actions_iids;
    schema_srv.actions.n_iid = ACT_IID_CNT;
    mobile_network_service = hey_service_register(MOBILE_NETWORK_SERVICE, &schema_srv, NULL);
    if (NULL == mobile_network_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of mobile network service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t mobile_network_properties_update(size_t count, uint32_t *enumerate, struct mobile_network_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__MobileNetwork__Properties *props = NULL;
    uint8_t *buf = NULL;
    ArrayNode **networkinfo = NULL;
    ArrayNode **apn = NULL;
    props = malloc(sizeof(Iot__Service__MobileNetwork__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__mobile_network__properties__init(props);
    if (properties->n_networkinfo) {
        networkinfo = calloc(properties->n_networkinfo, sizeof(ArrayNode *));
        if (NULL == networkinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_networkinfo; i++) {
            networkinfo[i] = malloc(sizeof(ArrayNode));
            if (NULL == networkinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(networkinfo[i]);
            networkinfo[i]->id = properties->networkinfo[i]->id;
            networkinfo[i]->data.data = properties->networkinfo[i]->data.data;
            networkinfo[i]->data.len = properties->networkinfo[i]->data.len;
        }
    }
    if (properties->n_apn) {
        apn = calloc(properties->n_apn, sizeof(ArrayNode *));
        if (NULL == apn) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_apn; i++) {
            apn[i] = malloc(sizeof(ArrayNode));
            if (NULL == apn[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(apn[i]);
            apn[i]->id = properties->apn[i]->id;
            apn[i]->data.data = properties->apn[i]->data.data;
            apn[i]->data.len = properties->apn[i]->data.len;
        }
    }
    props->n_networkinfo = properties->n_networkinfo;
    props->networkinfo = networkinfo;
    props->mobilenetworkipv4 = properties->mobilenetworkipv4;
    props->mobilenetworkipv6 = properties->mobilenetworkipv6;
    props->cellid = properties->cellid;
    props->rsrp = properties->rsrp;
    props->plmn = properties->plmn;
    props->imei = properties->imei;
    props->imsi = properties->imsi;
    props->mobilenetworkenabled = properties->mobilenetworkenabled;
    props->mobilenetworkromingenabled = properties->mobilenetworkromingenabled;
    props->mobilenetworkmode = properties->mobilenetworkmode;
    props->simpin = properties->simpin;
    props->n_apn = properties->n_apn;
    props->apn = apn;
    props->mobilegateway = properties->mobilegateway;
    props->mobiledns = properties->mobiledns;

    size_t buf_len;
    buf_len = iot__service__mobile_network__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__mobile_network__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(mobile_network_service, &content);

out:
    free(props);
    free(buf);
    if (networkinfo) {
        for (int i = 0; i < properties->n_networkinfo; i++) {
            free(networkinfo[i]);
        }
        free(networkinfo);
    }
    if (apn) {
        for (int i = 0; i < properties->n_apn; i++) {
            free(apn[i]);
        }
        free(apn);
    }
    return ret;
}

/**
 * @brief mobile network service initialization
 * @param properties [mobile network service properties]
 * @return int32_t   [initialize result]
*/
int32_t mobile_network_service_init(const struct mobile_network_properties *properties)
{
    int ret = 0;
    Iot__Service__MobileNetwork__Properties *props = NULL;
    ArrayNode **networkinfo = NULL;
    ArrayNode **apn = NULL;
    props = malloc(sizeof(Iot__Service__MobileNetwork__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__mobile_network__properties__init(props);
    if (NULL != properties) {
        if (properties->n_networkinfo) {
            networkinfo = calloc(properties->n_networkinfo, sizeof(ArrayNode *));
            if (NULL == networkinfo) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_networkinfo; i++) {
                networkinfo[i] = malloc(sizeof(ArrayNode));
                if (NULL == networkinfo[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(networkinfo[i]);
                networkinfo[i]->id = properties->networkinfo[i]->id;
                networkinfo[i]->data.data = properties->networkinfo[i]->data.data;
                networkinfo[i]->data.len = properties->networkinfo[i]->data.len;
            }
        }
        if (properties->n_apn) {
            apn = calloc(properties->n_apn, sizeof(ArrayNode *));
            if (NULL == apn) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_apn; i++) {
                apn[i] = malloc(sizeof(ArrayNode));
                if (NULL == apn[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(apn[i]);
                apn[i]->id = properties->apn[i]->id;
                apn[i]->data.data = properties->apn[i]->data.data;
                apn[i]->data.len = properties->apn[i]->data.len;
            }
        }
        props->n_networkinfo = properties->n_networkinfo;
        props->networkinfo = networkinfo;
        props->mobilenetworkipv4 = properties->mobilenetworkipv4;
        props->mobilenetworkipv6 = properties->mobilenetworkipv6;
        props->cellid = properties->cellid;
        props->rsrp = properties->rsrp;
        props->plmn = properties->plmn;
        props->imei = properties->imei;
        props->imsi = properties->imsi;
        props->mobilenetworkenabled = properties->mobilenetworkenabled;
        props->mobilenetworkromingenabled = properties->mobilenetworkromingenabled;
        props->mobilenetworkmode = properties->mobilenetworkmode;
        props->simpin = properties->simpin;
        props->n_apn = properties->n_apn;
        props->apn = apn;
        props->mobilegateway = properties->mobilegateway;
        props->mobiledns = properties->mobiledns;
    }

    ret = mobile_network_service_register(props);

out:
    free(props);
    if (networkinfo) {
        for (int i = 0; i < properties->n_networkinfo; i++) {
            free(networkinfo[i]);
        }
        free(networkinfo);
    }
    if (apn) {
        for (int i = 0; i < properties->n_apn; i++) {
            free(apn[i]);
        }
        free(apn);
    }
    return ret;
}
