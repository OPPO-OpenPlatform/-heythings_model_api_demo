/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: camera.proto */

#include <errno.h>
#include <assert.h>
#include "camera.pb-c.h"
#include "camera_service.h"
#include "hey/schema.h"

#define CAMERA_SERVICE (45 * 256)
#define PROP_IID_CNT 64
#define ACT_IID_CNT 16
#define EV_IID_CNT 8

static const struct hey_schema_property camera_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_GENERIC },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 9, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 11, .type = HEY_PROPERTY_TYPE_GENERIC },
    [11] = { .iid = 12, .type = HEY_PROPERTY_TYPE_GENERIC },
    [12] = { .iid = 13, .type = HEY_PROPERTY_TYPE_GENERIC },
    [13] = { .iid = 14, .type = HEY_PROPERTY_TYPE_ARRAY },
    [14] = { .iid = 15, .type = HEY_PROPERTY_TYPE_ARRAY },
    [15] = { .iid = 16, .type = HEY_PROPERTY_TYPE_GENERIC },
    [16] = { .iid = 17, .type = HEY_PROPERTY_TYPE_GENERIC },
    [17] = { .iid = 18, .type = HEY_PROPERTY_TYPE_GENERIC },
    [18] = { .iid = 19, .type = HEY_PROPERTY_TYPE_GENERIC },
    [19] = { .iid = 20, .type = HEY_PROPERTY_TYPE_GENERIC },
    [20] = { .iid = 21, .type = HEY_PROPERTY_TYPE_GENERIC },
    [21] = { .iid = 22, .type = HEY_PROPERTY_TYPE_GENERIC },
    [22] = { .iid = 23, .type = HEY_PROPERTY_TYPE_GENERIC },
    [23] = { .iid = 24, .type = HEY_PROPERTY_TYPE_GENERIC },
    [24] = { .iid = 25, .type = HEY_PROPERTY_TYPE_ARRAY },
    [25] = { .iid = 26, .type = HEY_PROPERTY_TYPE_ARRAY },
    [26] = { .iid = 27, .type = HEY_PROPERTY_TYPE_ARRAY },
    [27] = { .iid = 28, .type = HEY_PROPERTY_TYPE_GENERIC },
    [28] = { .iid = 29, .type = HEY_PROPERTY_TYPE_GENERIC },
    [29] = { .iid = 30, .type = HEY_PROPERTY_TYPE_GENERIC },
    [30] = { .iid = 31, .type = HEY_PROPERTY_TYPE_GENERIC },
    [31] = { .iid = 32, .type = HEY_PROPERTY_TYPE_GENERIC },
    [32] = { .iid = 33, .type = HEY_PROPERTY_TYPE_GENERIC },
    [33] = { .iid = 34, .type = HEY_PROPERTY_TYPE_GENERIC },
    [34] = { .iid = 35, .type = HEY_PROPERTY_TYPE_GENERIC },
    [35] = { .iid = 36, .type = HEY_PROPERTY_TYPE_GENERIC },
    [36] = { .iid = 37, .type = HEY_PROPERTY_TYPE_ARRAY },
    [37] = { .iid = 38, .type = HEY_PROPERTY_TYPE_GENERIC },
    [38] = { .iid = 39, .type = HEY_PROPERTY_TYPE_GENERIC },
    [39] = { .iid = 40, .type = HEY_PROPERTY_TYPE_GENERIC },
    [40] = { .iid = 41, .type = HEY_PROPERTY_TYPE_GENERIC },
    [41] = { .iid = 42, .type = HEY_PROPERTY_TYPE_GENERIC },
    [42] = { .iid = 43, .type = HEY_PROPERTY_TYPE_GENERIC },
    [43] = { .iid = 44, .type = HEY_PROPERTY_TYPE_ARRAY },
    [44] = { .iid = 58, .type = HEY_PROPERTY_TYPE_ARRAY },
    [45] = { .iid = 63, .type = HEY_PROPERTY_TYPE_GENERIC },
    [46] = { .iid = 64, .type = HEY_PROPERTY_TYPE_GENERIC },
    [47] = { .iid = 65, .type = HEY_PROPERTY_TYPE_GENERIC },
    [48] = { .iid = 66, .type = HEY_PROPERTY_TYPE_ARRAY },
    [49] = { .iid = 67, .type = HEY_PROPERTY_TYPE_GENERIC },
    [50] = { .iid = 68, .type = HEY_PROPERTY_TYPE_GENERIC },
    [51] = { .iid = 69, .type = HEY_PROPERTY_TYPE_GENERIC },
    [52] = { .iid = 70, .type = HEY_PROPERTY_TYPE_GENERIC },
    [53] = { .iid = 71, .type = HEY_PROPERTY_TYPE_GENERIC },
    [54] = { .iid = 72, .type = HEY_PROPERTY_TYPE_GENERIC },
    [55] = { .iid = 76, .type = HEY_PROPERTY_TYPE_GENERIC },
    [56] = { .iid = 77, .type = HEY_PROPERTY_TYPE_GENERIC },
    [57] = { .iid = 78, .type = HEY_PROPERTY_TYPE_GENERIC },
    [58] = { .iid = 79, .type = HEY_PROPERTY_TYPE_GENERIC },
    [59] = { .iid = 80, .type = HEY_PROPERTY_TYPE_GENERIC },
    [60] = { .iid = 81, .type = HEY_PROPERTY_TYPE_ARRAY },
    [61] = { .iid = 83, .type = HEY_PROPERTY_TYPE_GENERIC },
    [62] = { .iid = 84, .type = HEY_PROPERTY_TYPE_GENERIC },
    [63] = { .iid = 88, .type = HEY_PROPERTY_TYPE_GENERIC },
};
static const uint32_t camera_event_iids[] = { 56, 57, 59, 60, 61, 62, 86, 87 };
static struct hey_service *camera_service;

static int32_t action_ptz_calibration_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInPtzCalibration *ptz_calibration = iot__service__camera__action_in_ptz_calibration__unpack(NULL, len, value);
    if (NULL == ptz_calibration) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_ptz_calibration_in action = { 0 };
    ret = camera_ptz_calibration_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_ptz_calibration__free_unpacked(ptz_calibration, NULL);
    return ret;
}

static void action_ptz_calibration_stop_cb(void *cb_data, void *user_context)
{
    camera_ptz_calibration_stop_cb(user_context);
}

/**
 * @brief ptz calibration action send message of camera service
 * @param ctx      [action context]
 * @param action   [ptz calibration action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_ptz_calibration_send(struct hey_action_ctx *ctx, struct camera_ptz_calibration_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief ptz calibration action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_ptz_calibration_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_linear_movement_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInLinearMovement *linear_movement = iot__service__camera__action_in_linear_movement__unpack(NULL, len, value);
    if (NULL == linear_movement) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_linear_movement_in action = { 0 };
    action.linearmovementtype = linear_movement->linearmovementtype;
    ret = camera_linear_movement_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_linear_movement__free_unpacked(linear_movement, NULL);
    return ret;
}

static void action_linear_movement_stop_cb(void *cb_data, void *user_context)
{
    camera_linear_movement_stop_cb(user_context);
}

/**
 * @brief linear movement action send message of camera service
 * @param ctx      [action context]
 * @param action   [linear movement action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_linear_movement_send(struct hey_action_ctx *ctx, struct camera_linear_movement_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutLinearMovement *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutLinearMovement));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_linear_movement__init(out);
    out->x = action->x;
    out->y = action->y;
    out->state = action->state;
    size_t buf_len = iot__service__camera__action_out_linear_movement__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_linear_movement__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief linear movement action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_linear_movement_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_record_list_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetRecordList *get_record_list = iot__service__camera__action_in_get_record_list__unpack(NULL, len, value);
    if (NULL == get_record_list) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_record_list_in action = { 0 };
    action.fromtime = get_record_list->fromtime;
    action.totime = get_record_list->totime;
    action.recordcount = get_record_list->recordcount;
    ret = camera_get_record_list_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_record_list__free_unpacked(get_record_list, NULL);
    return ret;
}

static void action_get_record_list_stop_cb(void *cb_data, void *user_context)
{
    camera_get_record_list_stop_cb(user_context);
}

/**
 * @brief get record list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get record list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_record_list_send(struct hey_action_ctx *ctx, struct camera_get_record_list_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetRecordList *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordList));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_record_list__init(out);
    out->totalrecordcount = action->totalrecordcount;
    if (action->n_pictureinfo) {
        out->n_pictureinfo  = action->n_pictureinfo;
        out->pictureinfo = calloc(out->n_pictureinfo, sizeof(Iot__Service__Camera__ActionOutGetRecordList__PictureInfo *));
        if (NULL == out->pictureinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_pictureinfo; i++) {
            out->pictureinfo[i] = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordList__PictureInfo));
            if (NULL == out->pictureinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__action_out_get_record_list__picture_info__init(out->pictureinfo[i]);
            out->pictureinfo[i]->recordfilename = action->pictureinfo[i]->recordfilename;
            out->pictureinfo[i]->thumbnailfilename = action->pictureinfo[i]->thumbnailfilename;
            out->pictureinfo[i]->recordstarttime = action->pictureinfo[i]->recordstarttime;
            out->pictureinfo[i]->recordelapsedtime = action->pictureinfo[i]->recordelapsedtime;
            out->pictureinfo[i]->autodeleteenabled = action->pictureinfo[i]->autodeleteenabled;
            if (action->pictureinfo[i]->n_recordpoint) {
                out->pictureinfo[i]->n_recordpoint = action->pictureinfo[i]->n_recordpoint;
                out->pictureinfo[i]->recordpoint = calloc(out->pictureinfo[i]->n_recordpoint, sizeof(Iot__Service__Camera__ActionOutGetRecordList__PictureInfo__RecordPoint *));
                if (NULL == out->pictureinfo[i]->recordpoint) {
                    ret = ENOMEM;
                    goto out;
                }
                for (int j = 0; j < out->pictureinfo[i]->n_recordpoint; j++) {
                    out->pictureinfo[i]->recordpoint[j] = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordList__PictureInfo__RecordPoint));
                    if (NULL == out->pictureinfo[i]->recordpoint[j]) {
                        ret = ENOMEM;
                        goto out;
                    }
                    iot__service__camera__action_out_get_record_list__picture_info__record_point__init(out->pictureinfo[i]->recordpoint[j]);
                    out->pictureinfo[i]->recordpoint[j]->type = action->pictureinfo[i]->recordpoint[j]->type;
                    out->pictureinfo[i]->recordpoint[j]->frameindex = action->pictureinfo[i]->recordpoint[j]->frameindex;
                }
            }
        }
    }
    size_t buf_len = iot__service__camera__action_out_get_record_list__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_record_list__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->pictureinfo) {
        for (int i = 0; i < out->n_pictureinfo; i++) {
            if (out->pictureinfo[i] == NULL)
                break;
            if (out->pictureinfo[i]->recordpoint) {
                for (int j = 0; j < out->pictureinfo[i]->n_recordpoint; j++) {
                    if (out->pictureinfo[i]->recordpoint[j] == NULL)
                        break;
                    free(out->pictureinfo[i]->recordpoint[j]);
                }
                free(out->pictureinfo[i]->recordpoint);
            }
            free(out->pictureinfo[i]);
        }
        free(out->pictureinfo);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get record list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_record_list_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_del_record_info_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInDelRecordInfo *del_record_info = iot__service__camera__action_in_del_record_info__unpack(NULL, len, value);
    if (NULL == del_record_info) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_del_record_info_in action = { 0 };
    action.n_recordstarttime = del_record_info->n_recordstarttime;
    action.recordstarttime = del_record_info->recordstarttime;
    ret = camera_del_record_info_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_del_record_info__free_unpacked(del_record_info, NULL);
    return ret;
}

static void action_del_record_info_stop_cb(void *cb_data, void *user_context)
{
    camera_del_record_info_stop_cb(user_context);
}

/**
 * @brief del record info action send message of camera service
 * @param ctx      [action context]
 * @param action   [del record info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_del_record_info_send(struct hey_action_ctx *ctx, struct camera_del_record_info_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief del record info action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_del_record_info_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_video_period_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetVideoPeriod *get_video_period = iot__service__camera__action_in_get_video_period__unpack(NULL, len, value);
    if (NULL == get_video_period) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_video_period_in action = { 0 };
    ret = camera_get_video_period_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_video_period__free_unpacked(get_video_period, NULL);
    return ret;
}

static void action_get_video_period_stop_cb(void *cb_data, void *user_context)
{
    camera_get_video_period_stop_cb(user_context);
}

/**
 * @brief get video period action send message of camera service
 * @param ctx      [action context]
 * @param action   [get video period action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_video_period_send(struct hey_action_ctx *ctx, struct camera_get_video_period_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetVideoPeriod *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetVideoPeriod));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_video_period__init(out);
    out->endtime = action->endtime;
    out->starttime = action->starttime;
    size_t buf_len = iot__service__camera__action_out_get_video_period__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_video_period__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get video period action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_video_period_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_take_photo_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInTakePhoto *take_photo = iot__service__camera__action_in_take_photo__unpack(NULL, len, value);
    if (NULL == take_photo) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_take_photo_in action = { 0 };
    ret = camera_take_photo_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_take_photo__free_unpacked(take_photo, NULL);
    return ret;
}

static void action_take_photo_stop_cb(void *cb_data, void *user_context)
{
    camera_take_photo_stop_cb(user_context);
}

/**
 * @brief take photo action send message of camera service
 * @param ctx      [action context]
 * @param action   [take photo action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_take_photo_send(struct hey_action_ctx *ctx, struct camera_take_photo_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutTakePhoto *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutTakePhoto));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_take_photo__init(out);
    out->filename = action->filename;
    size_t buf_len = iot__service__camera__action_out_take_photo__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_take_photo__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief take photo action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_take_photo_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_current_position_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetCurrentPosition *get_current_position = iot__service__camera__action_in_get_current_position__unpack(NULL, len, value);
    if (NULL == get_current_position) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_current_position_in action = { 0 };
    ret = camera_get_current_position_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_current_position__free_unpacked(get_current_position, NULL);
    return ret;
}

static void action_get_current_position_stop_cb(void *cb_data, void *user_context)
{
    camera_get_current_position_stop_cb(user_context);
}

/**
 * @brief get current position action send message of camera service
 * @param ctx      [action context]
 * @param action   [get current position action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_current_position_send(struct hey_action_ctx *ctx, struct camera_get_current_position_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetCurrentPosition *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetCurrentPosition));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_current_position__init(out);
    out->x = action->x;
    out->y = action->y;
    size_t buf_len = iot__service__camera__action_out_get_current_position__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_current_position__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get current position action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_current_position_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_picture_list_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetPictureList *get_picture_list = iot__service__camera__action_in_get_picture_list__unpack(NULL, len, value);
    if (NULL == get_picture_list) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_picture_list_in action = { 0 };
    action.fromtime = get_picture_list->fromtime;
    action.totime = get_picture_list->totime;
    action.count = get_picture_list->count;
    ret = camera_get_picture_list_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_picture_list__free_unpacked(get_picture_list, NULL);
    return ret;
}

static void action_get_picture_list_stop_cb(void *cb_data, void *user_context)
{
    camera_get_picture_list_stop_cb(user_context);
}

/**
 * @brief get picture list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get picture list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_picture_list_send(struct hey_action_ctx *ctx, struct camera_get_picture_list_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetPictureList *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetPictureList));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_picture_list__init(out);
    out->totalcount = action->totalcount;
    if (action->n_pictureinfo) {
        out->n_pictureinfo  = action->n_pictureinfo;
        out->pictureinfo = calloc(out->n_pictureinfo, sizeof(Iot__Service__Camera__ActionOutGetPictureList__PictureInfo *));
        if (NULL == out->pictureinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_pictureinfo; i++) {
            out->pictureinfo[i] = malloc(sizeof(Iot__Service__Camera__ActionOutGetPictureList__PictureInfo));
            if (NULL == out->pictureinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__action_out_get_picture_list__picture_info__init(out->pictureinfo[i]);
            out->pictureinfo[i]->filename = action->pictureinfo[i]->filename;
            out->pictureinfo[i]->capturetime = action->pictureinfo[i]->capturetime;
        }
    }
    size_t buf_len = iot__service__camera__action_out_get_picture_list__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_picture_list__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->pictureinfo) {
        for (int i = 0; i < out->n_pictureinfo; i++) {
            if (out->pictureinfo[i] == NULL)
                break;
            free(out->pictureinfo[i]);
        }
        free(out->pictureinfo);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get picture list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_picture_list_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_del_picture_info_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInDelPictureInfo *del_picture_info = iot__service__camera__action_in_del_picture_info__unpack(NULL, len, value);
    if (NULL == del_picture_info) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_del_picture_info_in action = { 0 };
    action.n_filename = del_picture_info->n_filename;
    action.filename = del_picture_info->filename;
    ret = camera_del_picture_info_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_del_picture_info__free_unpacked(del_picture_info, NULL);
    return ret;
}

static void action_del_picture_info_stop_cb(void *cb_data, void *user_context)
{
    camera_del_picture_info_stop_cb(user_context);
}

/**
 * @brief del picture info action send message of camera service
 * @param ctx      [action context]
 * @param action   [del picture info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_del_picture_info_send(struct hey_action_ctx *ctx, struct camera_del_picture_info_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief del picture info action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_del_picture_info_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_sound_alarm_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInSoundAlarm *sound_alarm = iot__service__camera__action_in_sound_alarm__unpack(NULL, len, value);
    if (NULL == sound_alarm) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_sound_alarm_in action = { 0 };
    ret = camera_sound_alarm_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_sound_alarm__free_unpacked(sound_alarm, NULL);
    return ret;
}

static void action_sound_alarm_stop_cb(void *cb_data, void *user_context)
{
    camera_sound_alarm_stop_cb(user_context);
}

/**
 * @brief sound alarm action send message of camera service
 * @param ctx      [action context]
 * @param action   [sound alarm action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_sound_alarm_send(struct hey_action_ctx *ctx, struct camera_sound_alarm_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief sound alarm action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_sound_alarm_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_play_voice_memo_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInPlayVoiceMemo *play_voice_memo = iot__service__camera__action_in_play_voice_memo__unpack(NULL, len, value);
    if (NULL == play_voice_memo) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_play_voice_memo_in action = { 0 };
    action.fileid = play_voice_memo->fileid;
    ret = camera_play_voice_memo_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_play_voice_memo__free_unpacked(play_voice_memo, NULL);
    return ret;
}

static void action_play_voice_memo_stop_cb(void *cb_data, void *user_context)
{
    camera_play_voice_memo_stop_cb(user_context);
}

/**
 * @brief play voice memo action send message of camera service
 * @param ctx      [action context]
 * @param action   [play voice memo action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_play_voice_memo_send(struct hey_action_ctx *ctx, struct camera_play_voice_memo_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief play voice memo action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_play_voice_memo_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_moving_to_fav_position_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInMovingToFavPosition *moving_to_fav_position = iot__service__camera__action_in_moving_to_fav_position__unpack(NULL, len, value);
    if (NULL == moving_to_fav_position) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_moving_to_fav_position_in action = { 0 };
    action.x = moving_to_fav_position->x;
    action.y = moving_to_fav_position->y;
    ret = camera_moving_to_fav_position_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_moving_to_fav_position__free_unpacked(moving_to_fav_position, NULL);
    return ret;
}

static void action_moving_to_fav_position_stop_cb(void *cb_data, void *user_context)
{
    camera_moving_to_fav_position_stop_cb(user_context);
}

/**
 * @brief moving to fav position action send message of camera service
 * @param ctx      [action context]
 * @param action   [moving to fav position action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_moving_to_fav_position_send(struct hey_action_ctx *ctx, struct camera_moving_to_fav_position_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief moving to fav position action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_moving_to_fav_position_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_recording_time_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetRecordingTime *get_recording_time = iot__service__camera__action_in_get_recording_time__unpack(NULL, len, value);
    if (NULL == get_recording_time) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_recording_time_in action = { 0 };
    action.fromtime = get_recording_time->fromtime;
    action.totime = get_recording_time->totime;
    action.recordcount = get_recording_time->recordcount;
    action.precision = get_recording_time->precision;
    ret = camera_get_recording_time_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_recording_time__free_unpacked(get_recording_time, NULL);
    return ret;
}

static void action_get_recording_time_stop_cb(void *cb_data, void *user_context)
{
    camera_get_recording_time_stop_cb(user_context);
}

/**
 * @brief get recording time action send message of camera service
 * @param ctx      [action context]
 * @param action   [get recording time action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_recording_time_send(struct hey_action_ctx *ctx, struct camera_get_recording_time_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetRecordingTime *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordingTime));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_recording_time__init(out);
    out->totalrecordcount = action->totalrecordcount;
    out->n_timeofrecording = action->n_timeofrecording;
    out->timeofrecording = action->timeofrecording;
    size_t buf_len = iot__service__camera__action_out_get_recording_time__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_recording_time__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get recording time action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_recording_time_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_get_record_event_list_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInGetRecordEventList *get_record_event_list = iot__service__camera__action_in_get_record_event_list__unpack(NULL, len, value);
    if (NULL == get_record_event_list) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_get_record_event_list_in action = { 0 };
    action.fromtime = get_record_event_list->fromtime;
    action.totime = get_record_event_list->totime;
    action.recordcount = get_record_event_list->recordcount;
    ret = camera_get_record_event_list_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_get_record_event_list__free_unpacked(get_record_event_list, NULL);
    return ret;
}

static void action_get_record_event_list_stop_cb(void *cb_data, void *user_context)
{
    camera_get_record_event_list_stop_cb(user_context);
}

/**
 * @brief get record event list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get record event list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_record_event_list_send(struct hey_action_ctx *ctx, struct camera_get_record_event_list_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutGetRecordEventList *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordEventList));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_get_record_event_list__init(out);
    out->totalcount = action->totalcount;
    if (action->n_eventinfo) {
        out->n_eventinfo  = action->n_eventinfo;
        out->eventinfo = calloc(out->n_eventinfo, sizeof(Iot__Service__Camera__ActionOutGetRecordEventList__EventInfo *));
        if (NULL == out->eventinfo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < out->n_eventinfo; i++) {
            out->eventinfo[i] = malloc(sizeof(Iot__Service__Camera__ActionOutGetRecordEventList__EventInfo));
            if (NULL == out->eventinfo[i]) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__action_out_get_record_event_list__event_info__init(out->eventinfo[i]);
            out->eventinfo[i]->eventtype = action->eventinfo[i]->eventtype;
            out->eventinfo[i]->starttime = action->eventinfo[i]->starttime;
            out->eventinfo[i]->endtime = action->eventinfo[i]->endtime;
            out->eventinfo[i]->notificationid = action->eventinfo[i]->notificationid;
        }
    }
    size_t buf_len = iot__service__camera__action_out_get_record_event_list__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_get_record_event_list__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->eventinfo) {
        for (int i = 0; i < out->n_eventinfo; i++) {
            if (out->eventinfo[i] == NULL)
                break;
            free(out->eventinfo[i]);
        }
        free(out->eventinfo);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief get record event list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_record_event_list_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_device_reboot_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInDeviceReboot *device_reboot = iot__service__camera__action_in_device_reboot__unpack(NULL, len, value);
    if (NULL == device_reboot) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_device_reboot_in action = { 0 };
    ret = camera_device_reboot_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_device_reboot__free_unpacked(device_reboot, NULL);
    return ret;
}

static void action_device_reboot_stop_cb(void *cb_data, void *user_context)
{
    camera_device_reboot_stop_cb(user_context);
}

/**
 * @brief device reboot action send message of camera service
 * @param ctx      [action context]
 * @param action   [device reboot action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_device_reboot_send(struct hey_action_ctx *ctx, struct camera_device_reboot_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief device reboot action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_device_reboot_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_panorama_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Camera__ActionInPanorama *panorama = iot__service__camera__action_in_panorama__unpack(NULL, len, value);
    if (NULL == panorama) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct camera_panorama_in action = { 0 };
    action.horizontalangle = panorama->horizontalangle;
    action.verticalangle = panorama->verticalangle;
    ret = camera_panorama_start_cb(ctx, &action, user_context);

    iot__service__camera__action_in_panorama__free_unpacked(panorama, NULL);
    return ret;
}

static void action_panorama_stop_cb(void *cb_data, void *user_context)
{
    camera_panorama_stop_cb(user_context);
}

/**
 * @brief panorama action send message of camera service
 * @param ctx      [action context]
 * @param action   [panorama action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_panorama_send(struct hey_action_ctx *ctx, struct camera_panorama_out *action)
{
    int32_t ret = 0;
    Iot__Service__Camera__ActionOutPanorama *out = NULL;
    uint8_t *buf = NULL;
    out = malloc(sizeof(Iot__Service__Camera__ActionOutPanorama));
    if (NULL == out) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__action_out_panorama__init(out);
    out->send_type_case = action->send_type_case;
    switch (out->send_type_case) {
    case CAMERA_PANORAMA_SEND_TYPE_OUT_NOT_SET:
        break;
    case CAMERA_PANORAMA_SEND_TYPE_OUT_PIC: {
        out->pic = malloc(sizeof(Iot__Service__Camera__ActionOutPanorama__Picture));
        if (NULL == out->pic) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__action_out_panorama__picture__init(out->pic);
        out->pic->fileid = action->pic->fileid;
        out->pic->point->x = action->pic->point->x;
        out->pic->point->y = action->pic->point->y;
    } break;
    case CAMERA_PANORAMA_SEND_TYPE_OUT_CODE:
        out->code = action->code;
        break;
    default:
        break;
    }
    size_t buf_len = iot__service__camera__action_out_panorama__get_packed_size(out);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
    }
    iot__service__camera__action_out_panorama__pack(out, buf);
    ret = hey_action_msg_send(ctx, buf_len, buf);

out:
    if (out && out->pic) {
        free(out->pic);
    }
    free(out);
    free(buf);
    return ret;
}

/**
 * @brief panorama action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_panorama_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static Iot__Service__Camera__FixedPositionAndTimeRecord *_camera_fixed_position_and_time_record = NULL;
struct camera_fixed_position_and_time_record *camera_fixed_position_and_time_record_unpack(const uint8_t *data, size_t len)
{
    _camera_fixed_position_and_time_record = iot__service__camera__fixed_position_and_time_record__unpack(NULL, len, data);
    if (NULL == _camera_fixed_position_and_time_record) {
        return NULL;
    }
    struct camera_fixed_position_and_time_record *hey_struct = malloc(sizeof(struct camera_fixed_position_and_time_record));
    if (NULL == hey_struct) {
        goto out1;
    }
    struct fixed_position_and_time_record_position *position = NULL;
    position = malloc(sizeof(struct fixed_position_and_time_record_position));
    if (NULL == position) {
        goto out2;
    }
    position->x = _camera_fixed_position_and_time_record->position->x;
    position->y = _camera_fixed_position_and_time_record->position->y;
    hey_struct->week = _camera_fixed_position_and_time_record->week;
    hey_struct->hour = _camera_fixed_position_and_time_record->hour;
    hey_struct->min = _camera_fixed_position_and_time_record->min;
    hey_struct->position = position;
    return hey_struct;
out2:
    free(position);
    free(hey_struct);
out1:
    iot__service__camera__fixed_position_and_time_record__free_unpacked(_camera_fixed_position_and_time_record, NULL);
    return NULL;
}

void camera_fixed_position_and_time_record_free_unpacked(struct camera_fixed_position_and_time_record *data)
{
    assert(NULL != data);
    iot__service__camera__fixed_position_and_time_record__free_unpacked(_camera_fixed_position_and_time_record, NULL);
    free(data->position);
    free(data);
}

int32_t camera_fixed_position_and_time_record_get_packed_size(const struct camera_fixed_position_and_time_record *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FixedPositionAndTimeRecord *pb_struct = malloc(sizeof(Iot__Service__Camera__FixedPositionAndTimeRecord));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__fixed_position_and_time_record__init(pb_struct);
    Iot__Service__Camera__FixedPositionAndTimeRecord__Position *position = NULL;
    if (data->position) {
        position = malloc(sizeof(Iot__Service__Camera__FixedPositionAndTimeRecord__Position));
        if (NULL == position) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__fixed_position_and_time_record__position__init(position);
        position->x = data->position->x;
        position->y = data->position->y;
    }
    pb_struct->week = data->week;
    pb_struct->hour = data->hour;
    pb_struct->min = data->min;
    pb_struct->position = position;
    ret = iot__service__camera__fixed_position_and_time_record__get_packed_size(pb_struct);
out:
    free(position);
    free(pb_struct);
    return ret;
}

int32_t camera_fixed_position_and_time_record_pack(const struct camera_fixed_position_and_time_record *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FixedPositionAndTimeRecord *pb_struct = malloc(sizeof(Iot__Service__Camera__FixedPositionAndTimeRecord));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__fixed_position_and_time_record__init(pb_struct);
    Iot__Service__Camera__FixedPositionAndTimeRecord__Position *position = NULL;
    if (data->position) {
        position = malloc(sizeof(Iot__Service__Camera__FixedPositionAndTimeRecord__Position));
        if (NULL == position) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__fixed_position_and_time_record__position__init(position);
        position->x = data->position->x;
        position->y = data->position->y;
    }
    pb_struct->week = data->week;
    pb_struct->hour = data->hour;
    pb_struct->min = data->min;
    pb_struct->position = position;
    ret = iot__service__camera__fixed_position_and_time_record__pack(pb_struct, out);
out:
    free(position);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__AppeasingBabyWorkingPeriod *_camera_appeasing_baby_working_period = NULL;
struct camera_appeasing_baby_working_period *camera_appeasing_baby_working_period_unpack(const uint8_t *data, size_t len)
{
    _camera_appeasing_baby_working_period = iot__service__camera__appeasing_baby_working_period__unpack(NULL, len, data);
    if (NULL == _camera_appeasing_baby_working_period) {
        return NULL;
    }
    struct camera_appeasing_baby_working_period *hey_struct = malloc(sizeof(struct camera_appeasing_baby_working_period));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->week = _camera_appeasing_baby_working_period->week;
    hey_struct->fromhour = _camera_appeasing_baby_working_period->fromhour;
    hey_struct->frommin = _camera_appeasing_baby_working_period->frommin;
    hey_struct->tohour = _camera_appeasing_baby_working_period->tohour;
    hey_struct->tomin = _camera_appeasing_baby_working_period->tomin;
    return hey_struct;
out1:
    iot__service__camera__appeasing_baby_working_period__free_unpacked(_camera_appeasing_baby_working_period, NULL);
    return NULL;
}

void camera_appeasing_baby_working_period_free_unpacked(struct camera_appeasing_baby_working_period *data)
{
    assert(NULL != data);
    iot__service__camera__appeasing_baby_working_period__free_unpacked(_camera_appeasing_baby_working_period, NULL);
    free(data);
}

int32_t camera_appeasing_baby_working_period_get_packed_size(const struct camera_appeasing_baby_working_period *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AppeasingBabyWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__AppeasingBabyWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__appeasing_baby_working_period__init(pb_struct);
    pb_struct->week = data->week;
    pb_struct->fromhour = data->fromhour;
    pb_struct->frommin = data->frommin;
    pb_struct->tohour = data->tohour;
    pb_struct->tomin = data->tomin;
    ret = iot__service__camera__appeasing_baby_working_period__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_appeasing_baby_working_period_pack(const struct camera_appeasing_baby_working_period *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AppeasingBabyWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__AppeasingBabyWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__appeasing_baby_working_period__init(pb_struct);
    pb_struct->week = data->week;
    pb_struct->fromhour = data->fromhour;
    pb_struct->frommin = data->frommin;
    pb_struct->tohour = data->tohour;
    pb_struct->tomin = data->tomin;
    ret = iot__service__camera__appeasing_baby_working_period__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__AutoDetectionWorkingPeriod *_camera_auto_detection_working_period = NULL;
struct camera_auto_detection_working_period *camera_auto_detection_working_period_unpack(const uint8_t *data, size_t len)
{
    _camera_auto_detection_working_period = iot__service__camera__auto_detection_working_period__unpack(NULL, len, data);
    if (NULL == _camera_auto_detection_working_period) {
        return NULL;
    }
    struct camera_auto_detection_working_period *hey_struct = malloc(sizeof(struct camera_auto_detection_working_period));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->week = _camera_auto_detection_working_period->week;
    hey_struct->fromhour = _camera_auto_detection_working_period->fromhour;
    hey_struct->frommin = _camera_auto_detection_working_period->frommin;
    hey_struct->tohour = _camera_auto_detection_working_period->tohour;
    hey_struct->tomin = _camera_auto_detection_working_period->tomin;
    return hey_struct;
out1:
    iot__service__camera__auto_detection_working_period__free_unpacked(_camera_auto_detection_working_period, NULL);
    return NULL;
}

void camera_auto_detection_working_period_free_unpacked(struct camera_auto_detection_working_period *data)
{
    assert(NULL != data);
    iot__service__camera__auto_detection_working_period__free_unpacked(_camera_auto_detection_working_period, NULL);
    free(data);
}

int32_t camera_auto_detection_working_period_get_packed_size(const struct camera_auto_detection_working_period *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AutoDetectionWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__AutoDetectionWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__auto_detection_working_period__init(pb_struct);
    pb_struct->week = data->week;
    pb_struct->fromhour = data->fromhour;
    pb_struct->frommin = data->frommin;
    pb_struct->tohour = data->tohour;
    pb_struct->tomin = data->tomin;
    ret = iot__service__camera__auto_detection_working_period__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_auto_detection_working_period_pack(const struct camera_auto_detection_working_period *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AutoDetectionWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__AutoDetectionWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__auto_detection_working_period__init(pb_struct);
    pb_struct->week = data->week;
    pb_struct->fromhour = data->fromhour;
    pb_struct->frommin = data->frommin;
    pb_struct->tohour = data->tohour;
    pb_struct->tomin = data->tomin;
    ret = iot__service__camera__auto_detection_working_period__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__VoiceMemoPlayCondition *_camera_voice_memo_play_condition = NULL;
struct camera_voice_memo_play_condition *camera_voice_memo_play_condition_unpack(const uint8_t *data, size_t len)
{
    _camera_voice_memo_play_condition = iot__service__camera__voice_memo_play_condition__unpack(NULL, len, data);
    if (NULL == _camera_voice_memo_play_condition) {
        return NULL;
    }
    struct camera_voice_memo_play_condition *hey_struct = malloc(sizeof(struct camera_voice_memo_play_condition));
    if (NULL == hey_struct) {
        goto out1;
    }
    struct voice_memo_play_condition_period_condition *periodcondition = NULL;
    struct voice_memo_play_condition_face_condition *facecondition = NULL;
    periodcondition = malloc(sizeof(struct voice_memo_play_condition_period_condition));
    if (NULL == periodcondition) {
        goto out2;
    }
    facecondition = malloc(sizeof(struct voice_memo_play_condition_face_condition));
    if (NULL == facecondition) {
        goto out2;
    }
    periodcondition->week = _camera_voice_memo_play_condition->periodcondition->week;
    periodcondition->hour = _camera_voice_memo_play_condition->periodcondition->hour;
    periodcondition->minute = _camera_voice_memo_play_condition->periodcondition->minute;
    facecondition->faceid = _camera_voice_memo_play_condition->facecondition->faceid;
    facecondition->name = _camera_voice_memo_play_condition->facecondition->name;
    hey_struct->periodcondition = periodcondition;
    hey_struct->facecondition = facecondition;
    hey_struct->enable = _camera_voice_memo_play_condition->enable;
    hey_struct->fileid = _camera_voice_memo_play_condition->fileid;
    return hey_struct;
out2:
    free(periodcondition);
    free(facecondition);
    free(hey_struct);
out1:
    iot__service__camera__voice_memo_play_condition__free_unpacked(_camera_voice_memo_play_condition, NULL);
    return NULL;
}

void camera_voice_memo_play_condition_free_unpacked(struct camera_voice_memo_play_condition *data)
{
    assert(NULL != data);
    iot__service__camera__voice_memo_play_condition__free_unpacked(_camera_voice_memo_play_condition, NULL);
    free(data->periodcondition);
    free(data->facecondition);
    free(data);
}

int32_t camera_voice_memo_play_condition_get_packed_size(const struct camera_voice_memo_play_condition *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__VoiceMemoPlayCondition *pb_struct = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__voice_memo_play_condition__init(pb_struct);
    Iot__Service__Camera__VoiceMemoPlayCondition__PeriodCondition *periodcondition = NULL;
    Iot__Service__Camera__VoiceMemoPlayCondition__FaceCondition *facecondition = NULL;
    if (data->periodcondition) {
        periodcondition = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition__PeriodCondition));
        if (NULL == periodcondition) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__voice_memo_play_condition__period_condition__init(periodcondition);
        periodcondition->week = data->periodcondition->week;
        periodcondition->hour = data->periodcondition->hour;
        periodcondition->minute = data->periodcondition->minute;
    }
    if (data->facecondition) {
        facecondition = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition__FaceCondition));
        if (NULL == facecondition) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__voice_memo_play_condition__face_condition__init(facecondition);
        facecondition->faceid = data->facecondition->faceid;
        facecondition->name = data->facecondition->name;
    }
    pb_struct->periodcondition = periodcondition;
    pb_struct->facecondition = facecondition;
    pb_struct->enable = data->enable;
    pb_struct->fileid = data->fileid;
    ret = iot__service__camera__voice_memo_play_condition__get_packed_size(pb_struct);
out:
    free(periodcondition);
    free(facecondition);
    free(pb_struct);
    return ret;
}

int32_t camera_voice_memo_play_condition_pack(const struct camera_voice_memo_play_condition *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__VoiceMemoPlayCondition *pb_struct = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__voice_memo_play_condition__init(pb_struct);
    Iot__Service__Camera__VoiceMemoPlayCondition__PeriodCondition *periodcondition = NULL;
    Iot__Service__Camera__VoiceMemoPlayCondition__FaceCondition *facecondition = NULL;
    if (data->periodcondition) {
        periodcondition = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition__PeriodCondition));
        if (NULL == periodcondition) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__voice_memo_play_condition__period_condition__init(periodcondition);
        periodcondition->week = data->periodcondition->week;
        periodcondition->hour = data->periodcondition->hour;
        periodcondition->minute = data->periodcondition->minute;
    }
    if (data->facecondition) {
        facecondition = malloc(sizeof(Iot__Service__Camera__VoiceMemoPlayCondition__FaceCondition));
        if (NULL == facecondition) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__voice_memo_play_condition__face_condition__init(facecondition);
        facecondition->faceid = data->facecondition->faceid;
        facecondition->name = data->facecondition->name;
    }
    pb_struct->periodcondition = periodcondition;
    pb_struct->facecondition = facecondition;
    pb_struct->enable = data->enable;
    pb_struct->fileid = data->fileid;
    ret = iot__service__camera__voice_memo_play_condition__pack(pb_struct, out);
out:
    free(periodcondition);
    free(facecondition);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__AppeasingBabyMusic *_camera_appeasing_baby_music = NULL;
struct camera_appeasing_baby_music *camera_appeasing_baby_music_unpack(const uint8_t *data, size_t len)
{
    _camera_appeasing_baby_music = iot__service__camera__appeasing_baby_music__unpack(NULL, len, data);
    if (NULL == _camera_appeasing_baby_music) {
        return NULL;
    }
    struct camera_appeasing_baby_music *hey_struct = malloc(sizeof(struct camera_appeasing_baby_music));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->fileurl = _camera_appeasing_baby_music->fileurl;
    hey_struct->filetype = _camera_appeasing_baby_music->filetype;
    hey_struct->duration = _camera_appeasing_baby_music->duration;
    return hey_struct;
out1:
    iot__service__camera__appeasing_baby_music__free_unpacked(_camera_appeasing_baby_music, NULL);
    return NULL;
}

void camera_appeasing_baby_music_free_unpacked(struct camera_appeasing_baby_music *data)
{
    assert(NULL != data);
    iot__service__camera__appeasing_baby_music__free_unpacked(_camera_appeasing_baby_music, NULL);
    free(data);
}

int32_t camera_appeasing_baby_music_get_packed_size(const struct camera_appeasing_baby_music *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AppeasingBabyMusic *pb_struct = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusic));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__appeasing_baby_music__init(pb_struct);
    pb_struct->fileurl = data->fileurl;
    pb_struct->filetype = data->filetype;
    pb_struct->duration = data->duration;
    ret = iot__service__camera__appeasing_baby_music__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_appeasing_baby_music_pack(const struct camera_appeasing_baby_music *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__AppeasingBabyMusic *pb_struct = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusic));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__appeasing_baby_music__init(pb_struct);
    pb_struct->fileurl = data->fileurl;
    pb_struct->filetype = data->filetype;
    pb_struct->duration = data->duration;
    ret = iot__service__camera__appeasing_baby_music__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__FavouriteCruisedPosition *_camera_favourite_cruised_position = NULL;
struct camera_favourite_cruised_position *camera_favourite_cruised_position_unpack(const uint8_t *data, size_t len)
{
    _camera_favourite_cruised_position = iot__service__camera__favourite_cruised_position__unpack(NULL, len, data);
    if (NULL == _camera_favourite_cruised_position) {
        return NULL;
    }
    struct camera_favourite_cruised_position *hey_struct = malloc(sizeof(struct camera_favourite_cruised_position));
    if (NULL == hey_struct) {
        goto out1;
    }
    struct favourite_cruised_position_position *position = NULL;
    position = malloc(sizeof(struct favourite_cruised_position_position));
    if (NULL == position) {
        goto out2;
    }
    position->x = _camera_favourite_cruised_position->position->x;
    position->y = _camera_favourite_cruised_position->position->y;
    hey_struct->name = _camera_favourite_cruised_position->name;
    hey_struct->fileid = _camera_favourite_cruised_position->fileid;
    hey_struct->position = position;
    return hey_struct;
out2:
    free(position);
    free(hey_struct);
out1:
    iot__service__camera__favourite_cruised_position__free_unpacked(_camera_favourite_cruised_position, NULL);
    return NULL;
}

void camera_favourite_cruised_position_free_unpacked(struct camera_favourite_cruised_position *data)
{
    assert(NULL != data);
    iot__service__camera__favourite_cruised_position__free_unpacked(_camera_favourite_cruised_position, NULL);
    free(data->position);
    free(data);
}

int32_t camera_favourite_cruised_position_get_packed_size(const struct camera_favourite_cruised_position *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FavouriteCruisedPosition *pb_struct = malloc(sizeof(Iot__Service__Camera__FavouriteCruisedPosition));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__favourite_cruised_position__init(pb_struct);
    Iot__Service__Camera__FavouriteCruisedPosition__Position *position = NULL;
    if (data->position) {
        position = malloc(sizeof(Iot__Service__Camera__FavouriteCruisedPosition__Position));
        if (NULL == position) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__favourite_cruised_position__position__init(position);
        position->x = data->position->x;
        position->y = data->position->y;
    }
    pb_struct->name = data->name;
    pb_struct->fileid = data->fileid;
    pb_struct->position = position;
    ret = iot__service__camera__favourite_cruised_position__get_packed_size(pb_struct);
out:
    free(position);
    free(pb_struct);
    return ret;
}

int32_t camera_favourite_cruised_position_pack(const struct camera_favourite_cruised_position *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FavouriteCruisedPosition *pb_struct = malloc(sizeof(Iot__Service__Camera__FavouriteCruisedPosition));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__favourite_cruised_position__init(pb_struct);
    Iot__Service__Camera__FavouriteCruisedPosition__Position *position = NULL;
    if (data->position) {
        position = malloc(sizeof(Iot__Service__Camera__FavouriteCruisedPosition__Position));
        if (NULL == position) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__favourite_cruised_position__position__init(position);
        position->x = data->position->x;
        position->y = data->position->y;
    }
    pb_struct->name = data->name;
    pb_struct->fileid = data->fileid;
    pb_struct->position = position;
    ret = iot__service__camera__favourite_cruised_position__pack(pb_struct, out);
out:
    free(position);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__FixedPositionForRecord *_camera_fixed_position_for_record = NULL;
struct camera_fixed_position_for_record *camera_fixed_position_for_record_unpack(const uint8_t *data, size_t len)
{
    _camera_fixed_position_for_record = iot__service__camera__fixed_position_for_record__unpack(NULL, len, data);
    if (NULL == _camera_fixed_position_for_record) {
        return NULL;
    }
    struct camera_fixed_position_for_record *hey_struct = malloc(sizeof(struct camera_fixed_position_for_record));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->x = _camera_fixed_position_for_record->x;
    hey_struct->y = _camera_fixed_position_for_record->y;
    return hey_struct;
out1:
    iot__service__camera__fixed_position_for_record__free_unpacked(_camera_fixed_position_for_record, NULL);
    return NULL;
}

void camera_fixed_position_for_record_free_unpacked(struct camera_fixed_position_for_record *data)
{
    assert(NULL != data);
    iot__service__camera__fixed_position_for_record__free_unpacked(_camera_fixed_position_for_record, NULL);
    free(data);
}

int32_t camera_fixed_position_for_record_get_packed_size(const struct camera_fixed_position_for_record *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FixedPositionForRecord *pb_struct = malloc(sizeof(Iot__Service__Camera__FixedPositionForRecord));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__fixed_position_for_record__init(pb_struct);
    pb_struct->x = data->x;
    pb_struct->y = data->y;
    ret = iot__service__camera__fixed_position_for_record__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_fixed_position_for_record_pack(const struct camera_fixed_position_for_record *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FixedPositionForRecord *pb_struct = malloc(sizeof(Iot__Service__Camera__FixedPositionForRecord));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__fixed_position_for_record__init(pb_struct);
    pb_struct->x = data->x;
    pb_struct->y = data->y;
    ret = iot__service__camera__fixed_position_for_record__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__VoiceMemo *_camera_voice_memo = NULL;
struct camera_voice_memo *camera_voice_memo_unpack(const uint8_t *data, size_t len)
{
    _camera_voice_memo = iot__service__camera__voice_memo__unpack(NULL, len, data);
    if (NULL == _camera_voice_memo) {
        return NULL;
    }
    struct camera_voice_memo *hey_struct = malloc(sizeof(struct camera_voice_memo));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->fileid = _camera_voice_memo->fileid;
    hey_struct->duration = _camera_voice_memo->duration;
    return hey_struct;
out1:
    iot__service__camera__voice_memo__free_unpacked(_camera_voice_memo, NULL);
    return NULL;
}

void camera_voice_memo_free_unpacked(struct camera_voice_memo *data)
{
    assert(NULL != data);
    iot__service__camera__voice_memo__free_unpacked(_camera_voice_memo, NULL);
    free(data);
}

int32_t camera_voice_memo_get_packed_size(const struct camera_voice_memo *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__VoiceMemo *pb_struct = malloc(sizeof(Iot__Service__Camera__VoiceMemo));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__voice_memo__init(pb_struct);
    pb_struct->fileid = data->fileid;
    pb_struct->duration = data->duration;
    ret = iot__service__camera__voice_memo__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_voice_memo_pack(const struct camera_voice_memo *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__VoiceMemo *pb_struct = malloc(sizeof(Iot__Service__Camera__VoiceMemo));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__voice_memo__init(pb_struct);
    pb_struct->fileid = data->fileid;
    pb_struct->duration = data->duration;
    ret = iot__service__camera__voice_memo__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__FaceSource *_camera_face_source = NULL;
struct camera_face_source *camera_face_source_unpack(const uint8_t *data, size_t len)
{
    _camera_face_source = iot__service__camera__face_source__unpack(NULL, len, data);
    if (NULL == _camera_face_source) {
        return NULL;
    }
    struct camera_face_source *hey_struct = malloc(sizeof(struct camera_face_source));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->faceid = _camera_face_source->faceid;
    hey_struct->faceinfo = _camera_face_source->faceinfo;
    hey_struct->faceurl = _camera_face_source->faceurl;
    return hey_struct;
out1:
    iot__service__camera__face_source__free_unpacked(_camera_face_source, NULL);
    return NULL;
}

void camera_face_source_free_unpacked(struct camera_face_source *data)
{
    assert(NULL != data);
    iot__service__camera__face_source__free_unpacked(_camera_face_source, NULL);
    free(data);
}

int32_t camera_face_source_get_packed_size(const struct camera_face_source *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FaceSource *pb_struct = malloc(sizeof(Iot__Service__Camera__FaceSource));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__face_source__init(pb_struct);
    pb_struct->faceid = data->faceid;
    pb_struct->faceinfo = data->faceinfo;
    pb_struct->faceurl = data->faceurl;
    ret = iot__service__camera__face_source__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t camera_face_source_pack(const struct camera_face_source *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__FaceSource *pb_struct = malloc(sizeof(Iot__Service__Camera__FaceSource));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__face_source__init(pb_struct);
    pb_struct->faceid = data->faceid;
    pb_struct->faceinfo = data->faceinfo;
    pb_struct->faceurl = data->faceurl;
    ret = iot__service__camera__face_source__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Camera__SleepModeWorkingPeriod *_camera_sleep_mode_working_period = NULL;
struct camera_sleep_mode_working_period *camera_sleep_mode_working_period_unpack(const uint8_t *data, size_t len)
{
    _camera_sleep_mode_working_period = iot__service__camera__sleep_mode_working_period__unpack(NULL, len, data);
    if (NULL == _camera_sleep_mode_working_period) {
        return NULL;
    }
    struct camera_sleep_mode_working_period *hey_struct = malloc(sizeof(struct camera_sleep_mode_working_period));
    if (NULL == hey_struct) {
        goto out1;
    }
    struct sleep_mode_working_period_sleep_period *sleepperiod = NULL;
    sleepperiod = malloc(sizeof(struct sleep_mode_working_period_sleep_period));
    if (NULL == sleepperiod) {
        goto out2;
    }
    sleepperiod->week = _camera_sleep_mode_working_period->sleepperiod->week;
    sleepperiod->fromhour = _camera_sleep_mode_working_period->sleepperiod->fromhour;
    sleepperiod->frommin = _camera_sleep_mode_working_period->sleepperiod->frommin;
    sleepperiod->tohour = _camera_sleep_mode_working_period->sleepperiod->tohour;
    sleepperiod->tomin = _camera_sleep_mode_working_period->sleepperiod->tomin;
    hey_struct->enable = _camera_sleep_mode_working_period->enable;
    hey_struct->sleepperiod = sleepperiod;
    return hey_struct;
out2:
    free(sleepperiod);
    free(hey_struct);
out1:
    iot__service__camera__sleep_mode_working_period__free_unpacked(_camera_sleep_mode_working_period, NULL);
    return NULL;
}

void camera_sleep_mode_working_period_free_unpacked(struct camera_sleep_mode_working_period *data)
{
    assert(NULL != data);
    iot__service__camera__sleep_mode_working_period__free_unpacked(_camera_sleep_mode_working_period, NULL);
    free(data->sleepperiod);
    free(data);
}

int32_t camera_sleep_mode_working_period_get_packed_size(const struct camera_sleep_mode_working_period *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__SleepModeWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__SleepModeWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__sleep_mode_working_period__init(pb_struct);
    Iot__Service__Camera__SleepModeWorkingPeriod__SleepPeriod *sleepperiod = NULL;
    if (data->sleepperiod) {
        sleepperiod = malloc(sizeof(Iot__Service__Camera__SleepModeWorkingPeriod__SleepPeriod));
        if (NULL == sleepperiod) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__sleep_mode_working_period__sleep_period__init(sleepperiod);
        sleepperiod->week = data->sleepperiod->week;
        sleepperiod->fromhour = data->sleepperiod->fromhour;
        sleepperiod->frommin = data->sleepperiod->frommin;
        sleepperiod->tohour = data->sleepperiod->tohour;
        sleepperiod->tomin = data->sleepperiod->tomin;
    }
    pb_struct->enable = data->enable;
    pb_struct->sleepperiod = sleepperiod;
    ret = iot__service__camera__sleep_mode_working_period__get_packed_size(pb_struct);
out:
    free(sleepperiod);
    free(pb_struct);
    return ret;
}

int32_t camera_sleep_mode_working_period_pack(const struct camera_sleep_mode_working_period *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Camera__SleepModeWorkingPeriod *pb_struct = malloc(sizeof(Iot__Service__Camera__SleepModeWorkingPeriod));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__camera__sleep_mode_working_period__init(pb_struct);
    Iot__Service__Camera__SleepModeWorkingPeriod__SleepPeriod *sleepperiod = NULL;
    if (data->sleepperiod) {
        sleepperiod = malloc(sizeof(Iot__Service__Camera__SleepModeWorkingPeriod__SleepPeriod));
        if (NULL == sleepperiod) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__sleep_mode_working_period__sleep_period__init(sleepperiod);
        sleepperiod->week = data->sleepperiod->week;
        sleepperiod->fromhour = data->sleepperiod->fromhour;
        sleepperiod->frommin = data->sleepperiod->frommin;
        sleepperiod->tohour = data->sleepperiod->tohour;
        sleepperiod->tomin = data->sleepperiod->tomin;
    }
    pb_struct->enable = data->enable;
    pb_struct->sleepperiod = sleepperiod;
    ret = iot__service__camera__sleep_mode_working_period__pack(pb_struct, out);
out:
    free(sleepperiod);
    free(pb_struct);
    return ret;
}

static int32_t service_camera_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                  size_t len, uint8_t *value)
{
    Iot__Service__Camera__Properties *props = iot__service__camera__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct camera_properties properties = { 0 };
    struct hey_array_node **favouritecruisedposition = NULL;
    struct hey_array_node **fixedpositionforrecord = NULL;
    struct hey_array_node **fixedpositionandtimerecord = NULL;
    struct hey_array_node **appeasingbabyworkingperiod = NULL;
    struct hey_array_node **autodetectionworkingperiod = NULL;
    struct hey_array_node **appeasingbabymusic = NULL;
    struct camera_appeasing_baby_music_play_mode appeasingbabymusicplaymode = { 0 };
    struct camera_appeasing_baby_music_play_setting appeasingbabymusicplaysetting = { 0 };
    struct hey_array_node **voicememo = NULL;
    struct hey_array_node **facesource = NULL;
    struct hey_array_node **voicememoplaycondition = NULL;
    struct camera_limited_position limitedposition = { 0 };
    struct hey_array_node **sleepmodeworkingperiod = NULL;
    if (props->appeasingbabymusicplaymode) {
        appeasingbabymusicplaymode.playmode = props->appeasingbabymusicplaymode->playmode;
    }
    if (props->appeasingbabymusicplaysetting) {
        appeasingbabymusicplaysetting.fileurl = props->appeasingbabymusicplaysetting->fileurl;
        appeasingbabymusicplaysetting.time = props->appeasingbabymusicplaysetting->time;
    }
    if (props->limitedposition) {
        limitedposition.maxhorizontalangle = props->limitedposition->maxhorizontalangle;
        limitedposition.maxverticalangle = props->limitedposition->maxverticalangle;
    }
    properties.power = props->power;
    properties.recordmode = props->recordmode;
    properties.resolution = props->resolution;
    properties.nightvisionsta = props->nightvisionsta;
    properties.recordmute = props->recordmute;
    properties.autodetectionenabled = props->autodetectionenabled;
    properties.fixedpositiondetectionenabled = props->fixedpositiondetectionenabled;
    properties.autocruisedetection = props->autocruisedetection;
    properties.facerecognitionenabled = props->facerecognitionenabled;
    properties.multimediawithtimewatermark = props->multimediawithtimewatermark;
    properties.pushmotiondetectionenabled = props->pushmotiondetectionenabled;
    properties.pushmotiondetectionsilenttime = props->pushmotiondetectionsilenttime;
    properties.camerasensitivity = props->camerasensitivity;
    if (props->n_favouritecruisedposition) {
        favouritecruisedposition = calloc(props->n_favouritecruisedposition, sizeof(struct hey_array_node *));
        if (favouritecruisedposition == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_favouritecruisedposition; i++) {
            favouritecruisedposition[i] = malloc(sizeof(struct hey_array_node));
            if (favouritecruisedposition[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            favouritecruisedposition[i]->id = props->favouritecruisedposition[i]->id;
            favouritecruisedposition[i]->data.data = props->favouritecruisedposition[i]->data.data;
            favouritecruisedposition[i]->data.len = props->favouritecruisedposition[i]->data.len;
        }
        properties.n_favouritecruisedposition = props->n_favouritecruisedposition;
        properties.favouritecruisedposition = favouritecruisedposition;
    }
    if (props->n_fixedpositionforrecord) {
        fixedpositionforrecord = calloc(props->n_fixedpositionforrecord, sizeof(struct hey_array_node *));
        if (fixedpositionforrecord == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_fixedpositionforrecord; i++) {
            fixedpositionforrecord[i] = malloc(sizeof(struct hey_array_node));
            if (fixedpositionforrecord[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            fixedpositionforrecord[i]->id = props->fixedpositionforrecord[i]->id;
            fixedpositionforrecord[i]->data.data = props->fixedpositionforrecord[i]->data.data;
            fixedpositionforrecord[i]->data.len = props->fixedpositionforrecord[i]->data.len;
        }
        properties.n_fixedpositionforrecord = props->n_fixedpositionforrecord;
        properties.fixedpositionforrecord = fixedpositionforrecord;
    }
    properties.crydetectionenabled = props->crydetectionenabled;
    properties.pushcrydetectionenabled = props->pushcrydetectionenabled;
    properties.pushcrydetectionsilenttime = props->pushcrydetectionsilenttime;
    properties.appeasingbabyenabled = props->appeasingbabyenabled;
    properties.indicatorlightenabled = props->indicatorlightenabled;
    properties.correctlendistortionenabled = props->correctlendistortionenabled;
    properties.wdrenabled = props->wdrenabled;
    properties.pushfacerecognitionenabled = props->pushfacerecognitionenabled;
    properties.pushfacerecognitionsilenttime = props->pushfacerecognitionsilenttime;
    if (props->n_fixedpositionandtimerecord) {
        fixedpositionandtimerecord = calloc(props->n_fixedpositionandtimerecord, sizeof(struct hey_array_node *));
        if (fixedpositionandtimerecord == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_fixedpositionandtimerecord; i++) {
            fixedpositionandtimerecord[i] = malloc(sizeof(struct hey_array_node));
            if (fixedpositionandtimerecord[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            fixedpositionandtimerecord[i]->id = props->fixedpositionandtimerecord[i]->id;
            fixedpositionandtimerecord[i]->data.data = props->fixedpositionandtimerecord[i]->data.data;
            fixedpositionandtimerecord[i]->data.len = props->fixedpositionandtimerecord[i]->data.len;
        }
        properties.n_fixedpositionandtimerecord = props->n_fixedpositionandtimerecord;
        properties.fixedpositionandtimerecord = fixedpositionandtimerecord;
    }
    if (props->n_appeasingbabyworkingperiod) {
        appeasingbabyworkingperiod = calloc(props->n_appeasingbabyworkingperiod, sizeof(struct hey_array_node *));
        if (appeasingbabyworkingperiod == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_appeasingbabyworkingperiod; i++) {
            appeasingbabyworkingperiod[i] = malloc(sizeof(struct hey_array_node));
            if (appeasingbabyworkingperiod[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            appeasingbabyworkingperiod[i]->id = props->appeasingbabyworkingperiod[i]->id;
            appeasingbabyworkingperiod[i]->data.data = props->appeasingbabyworkingperiod[i]->data.data;
            appeasingbabyworkingperiod[i]->data.len = props->appeasingbabyworkingperiod[i]->data.len;
        }
        properties.n_appeasingbabyworkingperiod = props->n_appeasingbabyworkingperiod;
        properties.appeasingbabyworkingperiod = appeasingbabyworkingperiod;
    }
    if (props->n_autodetectionworkingperiod) {
        autodetectionworkingperiod = calloc(props->n_autodetectionworkingperiod, sizeof(struct hey_array_node *));
        if (autodetectionworkingperiod == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_autodetectionworkingperiod; i++) {
            autodetectionworkingperiod[i] = malloc(sizeof(struct hey_array_node));
            if (autodetectionworkingperiod[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            autodetectionworkingperiod[i]->id = props->autodetectionworkingperiod[i]->id;
            autodetectionworkingperiod[i]->data.data = props->autodetectionworkingperiod[i]->data.data;
            autodetectionworkingperiod[i]->data.len = props->autodetectionworkingperiod[i]->data.len;
        }
        properties.n_autodetectionworkingperiod = props->n_autodetectionworkingperiod;
        properties.autodetectionworkingperiod = autodetectionworkingperiod;
    }
    properties.motiontrackingenabled = props->motiontrackingenabled;
    properties.soundalarmtime = props->soundalarmtime;
    properties.soundalarmvolume = props->soundalarmvolume;
    properties.ringingsound = props->ringingsound;
    properties.recordmotiondetectionsilencetime = props->recordmotiondetectionsilencetime;
    properties.recordhumanmotionsilencetime = props->recordhumanmotionsilencetime;
    properties.recordanimalmotionsilencetime = props->recordanimalmotionsilencetime;
    properties.recordcrydetectionsilencetime = props->recordcrydetectionsilencetime;
    properties.recordfacerecognitionsilenttime = props->recordfacerecognitionsilenttime;
    if (props->n_appeasingbabymusic) {
        appeasingbabymusic = calloc(props->n_appeasingbabymusic, sizeof(struct hey_array_node *));
        if (appeasingbabymusic == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_appeasingbabymusic; i++) {
            appeasingbabymusic[i] = malloc(sizeof(struct hey_array_node));
            if (appeasingbabymusic[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            appeasingbabymusic[i]->id = props->appeasingbabymusic[i]->id;
            appeasingbabymusic[i]->data.data = props->appeasingbabymusic[i]->data.data;
            appeasingbabymusic[i]->data.len = props->appeasingbabymusic[i]->data.len;
        }
        properties.n_appeasingbabymusic = props->n_appeasingbabymusic;
        properties.appeasingbabymusic = appeasingbabymusic;
    }
    properties.appeasingbabymusicplaymode = &appeasingbabymusicplaymode;
    properties.appeasingbabymusicplaysetting = &appeasingbabymusicplaysetting;
    properties.pushhumanmotionsilencetime = props->pushhumanmotionsilencetime;
    properties.pushanimalmotionsilencetime = props->pushanimalmotionsilencetime;
    properties.pushhumanmotionenabled = props->pushhumanmotionenabled;
    properties.pushanimalmotionenabled = props->pushanimalmotionenabled;
    if (props->n_voicememo) {
        voicememo = calloc(props->n_voicememo, sizeof(struct hey_array_node *));
        if (voicememo == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_voicememo; i++) {
            voicememo[i] = malloc(sizeof(struct hey_array_node));
            if (voicememo[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            voicememo[i]->id = props->voicememo[i]->id;
            voicememo[i]->data.data = props->voicememo[i]->data.data;
            voicememo[i]->data.len = props->voicememo[i]->data.len;
        }
        properties.n_voicememo = props->n_voicememo;
        properties.voicememo = voicememo;
    }
    if (props->n_facesource) {
        facesource = calloc(props->n_facesource, sizeof(struct hey_array_node *));
        if (facesource == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_facesource; i++) {
            facesource[i] = malloc(sizeof(struct hey_array_node));
            if (facesource[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            facesource[i]->id = props->facesource[i]->id;
            facesource[i]->data.data = props->facesource[i]->data.data;
            facesource[i]->data.len = props->facesource[i]->data.len;
        }
        properties.n_facesource = props->n_facesource;
        properties.facesource = facesource;
    }
    properties.pushpicturechangeenabled = props->pushpicturechangeenabled;
    properties.pushpicturechangesilencetime = props->pushpicturechangesilencetime;
    properties.recordpicturechangesilencetime = props->recordpicturechangesilencetime;
    if (props->n_voicememoplaycondition) {
        voicememoplaycondition = calloc(props->n_voicememoplaycondition, sizeof(struct hey_array_node *));
        if (voicememoplaycondition == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_voicememoplaycondition; i++) {
            voicememoplaycondition[i] = malloc(sizeof(struct hey_array_node));
            if (voicememoplaycondition[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            voicememoplaycondition[i]->id = props->voicememoplaycondition[i]->id;
            voicememoplaycondition[i]->data.data = props->voicememoplaycondition[i]->data.data;
            voicememoplaycondition[i]->data.len = props->voicememoplaycondition[i]->data.len;
        }
        properties.n_voicememoplaycondition = props->n_voicememoplaycondition;
        properties.voicememoplaycondition = voicememoplaycondition;
    }
    properties.pushcatmotionenabled = props->pushcatmotionenabled;
    properties.pushdogmotionenabled = props->pushdogmotionenabled;
    properties.pushcatmotionsilenttime = props->pushcatmotionsilenttime;
    properties.pushdogmotionsilenttime = props->pushdogmotionsilenttime;
    properties.recordcatmotionsilencetime = props->recordcatmotionsilencetime;
    properties.recorddogmotionsilencetime = props->recorddogmotionsilencetime;
    properties.eventvideouploadcloudenable = props->eventvideouploadcloudenable;
    properties.groupofpictures = props->groupofpictures;
    properties.framespersecond = props->framespersecond;
    properties.pictureflipmode = props->pictureflipmode;
    properties.limitedposition = &limitedposition;
    if (props->n_sleepmodeworkingperiod) {
        sleepmodeworkingperiod = calloc(props->n_sleepmodeworkingperiod, sizeof(struct hey_array_node *));
        if (sleepmodeworkingperiod == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_sleepmodeworkingperiod; i++) {
            sleepmodeworkingperiod[i] = malloc(sizeof(struct hey_array_node));
            if (sleepmodeworkingperiod[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            sleepmodeworkingperiod[i]->id = props->sleepmodeworkingperiod[i]->id;
            sleepmodeworkingperiod[i]->data.data = props->sleepmodeworkingperiod[i]->data.data;
            sleepmodeworkingperiod[i]->data.len = props->sleepmodeworkingperiod[i]->data.len;
        }
        properties.n_sleepmodeworkingperiod = props->n_sleepmodeworkingperiod;
        properties.sleepmodeworkingperiod = sleepmodeworkingperiod;
    }
    properties.bitrate = props->bitrate;
    properties.sleep = props->sleep;
    properties.onetouchcallenabled = props->onetouchcallenabled;
    ret = camera_properties_write_cb(n_iid, iids, &properties);

out:
    if (favouritecruisedposition) {
        for (int i = 0; i < props->n_favouritecruisedposition; i++) {
            free(favouritecruisedposition[i]);
        }
        free(favouritecruisedposition);
    }
    if (fixedpositionforrecord) {
        for (int i = 0; i < props->n_fixedpositionforrecord; i++) {
            free(fixedpositionforrecord[i]);
        }
        free(fixedpositionforrecord);
    }
    if (fixedpositionandtimerecord) {
        for (int i = 0; i < props->n_fixedpositionandtimerecord; i++) {
            free(fixedpositionandtimerecord[i]);
        }
        free(fixedpositionandtimerecord);
    }
    if (appeasingbabyworkingperiod) {
        for (int i = 0; i < props->n_appeasingbabyworkingperiod; i++) {
            free(appeasingbabyworkingperiod[i]);
        }
        free(appeasingbabyworkingperiod);
    }
    if (autodetectionworkingperiod) {
        for (int i = 0; i < props->n_autodetectionworkingperiod; i++) {
            free(autodetectionworkingperiod[i]);
        }
        free(autodetectionworkingperiod);
    }
    if (appeasingbabymusic) {
        for (int i = 0; i < props->n_appeasingbabymusic; i++) {
            free(appeasingbabymusic[i]);
        }
        free(appeasingbabymusic);
    }
    if (voicememo) {
        for (int i = 0; i < props->n_voicememo; i++) {
            free(voicememo[i]);
        }
        free(voicememo);
    }
    if (facesource) {
        for (int i = 0; i < props->n_facesource; i++) {
            free(facesource[i]);
        }
        free(facesource);
    }
    if (voicememoplaycondition) {
        for (int i = 0; i < props->n_voicememoplaycondition; i++) {
            free(voicememoplaycondition[i]);
        }
        free(voicememoplaycondition);
    }
    if (sleepmodeworkingperiod) {
        for (int i = 0; i < props->n_sleepmodeworkingperiod; i++) {
            free(sleepmodeworkingperiod[i]);
        }
        free(sleepmodeworkingperiod);
    }
    iot__service__camera__properties__free_unpacked(props, NULL);
    return ret;
}

static int32_t service_camera_properties_array_add_cb(void *cb_data, uint32_t iid, size_t len, uint8_t *value)
{
    switch(iid) {
    case CAMERA_PROPERTY_FAVOURITECRUISEDPOSITION:
        return camera_favouritecruisedposition_array_add_cb(len, value);
    case CAMERA_PROPERTY_FIXEDPOSITIONFORRECORD:
        return camera_fixedpositionforrecord_array_add_cb(len, value);
    case CAMERA_PROPERTY_FIXEDPOSITIONANDTIMERECORD:
        return camera_fixedpositionandtimerecord_array_add_cb(len, value);
    case CAMERA_PROPERTY_APPEASINGBABYWORKINGPERIOD:
        return camera_appeasingbabyworkingperiod_array_add_cb(len, value);
    case CAMERA_PROPERTY_AUTODETECTIONWORKINGPERIOD:
        return camera_autodetectionworkingperiod_array_add_cb(len, value);
    case CAMERA_PROPERTY_APPEASINGBABYMUSIC:
        return camera_appeasingbabymusic_array_add_cb(len, value);
    case CAMERA_PROPERTY_VOICEMEMO:
        return camera_voicememo_array_add_cb(len, value);
    case CAMERA_PROPERTY_FACESOURCE:
        return camera_facesource_array_add_cb(len, value);
    case CAMERA_PROPERTY_VOICEMEMOPLAYCONDITION:
        return camera_voicememoplaycondition_array_add_cb(len, value);
    case CAMERA_PROPERTY_SLEEPMODEWORKINGPERIOD:
        return camera_sleepmodeworkingperiod_array_add_cb(len, value);
    default:
        return -1;
    }
}

static int32_t service_camera_properties_array_del_cb(void *cb_data, uint32_t iid, size_t n_id, uint32_t *ids)
{
    switch(iid) {
    case CAMERA_PROPERTY_FAVOURITECRUISEDPOSITION:
        return camera_favouritecruisedposition_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_FIXEDPOSITIONFORRECORD:
        return camera_fixedpositionforrecord_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_FIXEDPOSITIONANDTIMERECORD:
        return camera_fixedpositionandtimerecord_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_APPEASINGBABYWORKINGPERIOD:
        return camera_appeasingbabyworkingperiod_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_AUTODETECTIONWORKINGPERIOD:
        return camera_autodetectionworkingperiod_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_APPEASINGBABYMUSIC:
        return camera_appeasingbabymusic_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_VOICEMEMO:
        return camera_voicememo_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_FACESOURCE:
        return camera_facesource_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_VOICEMEMOPLAYCONDITION:
        return camera_voicememoplaycondition_array_del_cb(n_id, ids);
    case CAMERA_PROPERTY_SLEEPMODEWORKINGPERIOD:
        return camera_sleepmodeworkingperiod_array_del_cb(n_id, ids);
    default:
        return -1;
    }
}

static int32_t service_camera_properties_array_replace_cb(void *cb_data, uint32_t iid, uint32_t id, size_t len, uint8_t *value)
{
    switch(iid) {
    case CAMERA_PROPERTY_FAVOURITECRUISEDPOSITION:
        return camera_favouritecruisedposition_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_FIXEDPOSITIONFORRECORD:
        return camera_fixedpositionforrecord_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_FIXEDPOSITIONANDTIMERECORD:
        return camera_fixedpositionandtimerecord_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_APPEASINGBABYWORKINGPERIOD:
        return camera_appeasingbabyworkingperiod_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_AUTODETECTIONWORKINGPERIOD:
        return camera_autodetectionworkingperiod_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_APPEASINGBABYMUSIC:
        return camera_appeasingbabymusic_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_VOICEMEMO:
        return camera_voicememo_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_FACESOURCE:
        return camera_facesource_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_VOICEMEMOPLAYCONDITION:
        return camera_voicememoplaycondition_array_replace_cb(id, len, value);
    case CAMERA_PROPERTY_SLEEPMODEWORKINGPERIOD:
        return camera_sleepmodeworkingperiod_array_replace_cb(id, len, value);
    default:
        return -1;
    }
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_camera_properties_write_cb,
    .array_add = service_camera_properties_array_add_cb,
    .array_del = service_camera_properties_array_del_cb,
    .array_replace = service_camera_properties_array_replace_cb,
};

static const struct hey_action_ctx_callbacks ptz_calibration_cbs = {
    .start = action_ptz_calibration_start_cb,
    .stop = action_ptz_calibration_stop_cb
};

static const struct hey_action_ctx_callbacks linear_movement_cbs = {
    .start = action_linear_movement_start_cb,
    .stop = action_linear_movement_stop_cb
};

static const struct hey_action_ctx_callbacks get_record_list_cbs = {
    .start = action_get_record_list_start_cb,
    .stop = action_get_record_list_stop_cb
};

static const struct hey_action_ctx_callbacks del_record_info_cbs = {
    .start = action_del_record_info_start_cb,
    .stop = action_del_record_info_stop_cb
};

static const struct hey_action_ctx_callbacks get_video_period_cbs = {
    .start = action_get_video_period_start_cb,
    .stop = action_get_video_period_stop_cb
};

static const struct hey_action_ctx_callbacks take_photo_cbs = {
    .start = action_take_photo_start_cb,
    .stop = action_take_photo_stop_cb
};

static const struct hey_action_ctx_callbacks get_current_position_cbs = {
    .start = action_get_current_position_start_cb,
    .stop = action_get_current_position_stop_cb
};

static const struct hey_action_ctx_callbacks get_picture_list_cbs = {
    .start = action_get_picture_list_start_cb,
    .stop = action_get_picture_list_stop_cb
};

static const struct hey_action_ctx_callbacks del_picture_info_cbs = {
    .start = action_del_picture_info_start_cb,
    .stop = action_del_picture_info_stop_cb
};

static const struct hey_action_ctx_callbacks sound_alarm_cbs = {
    .start = action_sound_alarm_start_cb,
    .stop = action_sound_alarm_stop_cb
};

static const struct hey_action_ctx_callbacks play_voice_memo_cbs = {
    .start = action_play_voice_memo_start_cb,
    .stop = action_play_voice_memo_stop_cb
};

static const struct hey_action_ctx_callbacks moving_to_fav_position_cbs = {
    .start = action_moving_to_fav_position_start_cb,
    .stop = action_moving_to_fav_position_stop_cb
};

static const struct hey_action_ctx_callbacks get_recording_time_cbs = {
    .start = action_get_recording_time_start_cb,
    .stop = action_get_recording_time_stop_cb
};

static const struct hey_action_ctx_callbacks get_record_event_list_cbs = {
    .start = action_get_record_event_list_start_cb,
    .stop = action_get_record_event_list_stop_cb
};

static const struct hey_action_ctx_callbacks device_reboot_cbs = {
    .start = action_device_reboot_start_cb,
    .stop = action_device_reboot_stop_cb
};

static const struct hey_action_ctx_callbacks panorama_cbs = {
    .start = action_panorama_start_cb,
    .stop = action_panorama_stop_cb
};

static const struct hey_action_entry actions_iids[] = {
    [0] = { .iid = CAMERA_ACTION_PTZ_CALIBRATION, .type = HEY_ACTION_ONCE, .cbs = &ptz_calibration_cbs },
    [1] = { .iid = CAMERA_ACTION_LINEAR_MOVEMENT, .type = HEY_ACTION_ONCE, .cbs = &linear_movement_cbs },
    [2] = { .iid = CAMERA_ACTION_GET_RECORD_LIST, .type = HEY_ACTION_ONCE, .cbs = &get_record_list_cbs },
    [3] = { .iid = CAMERA_ACTION_DEL_RECORD_INFO, .type = HEY_ACTION_ONCE, .cbs = &del_record_info_cbs },
    [4] = { .iid = CAMERA_ACTION_GET_VIDEO_PERIOD, .type = HEY_ACTION_ONCE, .cbs = &get_video_period_cbs },
    [5] = { .iid = CAMERA_ACTION_TAKE_PHOTO, .type = HEY_ACTION_ONCE, .cbs = &take_photo_cbs },
    [6] = { .iid = CAMERA_ACTION_GET_CURRENT_POSITION, .type = HEY_ACTION_ONCE, .cbs = &get_current_position_cbs },
    [7] = { .iid = CAMERA_ACTION_GET_PICTURE_LIST, .type = HEY_ACTION_ONCE, .cbs = &get_picture_list_cbs },
    [8] = { .iid = CAMERA_ACTION_DEL_PICTURE_INFO, .type = HEY_ACTION_ONCE, .cbs = &del_picture_info_cbs },
    [9] = { .iid = CAMERA_ACTION_SOUND_ALARM, .type = HEY_ACTION_ONCE, .cbs = &sound_alarm_cbs },
    [10] = { .iid = CAMERA_ACTION_PLAY_VOICE_MEMO, .type = HEY_ACTION_ONCE, .cbs = &play_voice_memo_cbs },
    [11] = { .iid = CAMERA_ACTION_MOVING_TO_FAV_POSITION, .type = HEY_ACTION_ONCE, .cbs = &moving_to_fav_position_cbs },
    [12] = { .iid = CAMERA_ACTION_GET_RECORDING_TIME, .type = HEY_ACTION_ONCE, .cbs = &get_recording_time_cbs },
    [13] = { .iid = CAMERA_ACTION_GET_RECORD_EVENT_LIST, .type = HEY_ACTION_ONCE, .cbs = &get_record_event_list_cbs },
    [14] = { .iid = CAMERA_ACTION_DEVICE_REBOOT, .type = HEY_ACTION_ONCE, .cbs = &device_reboot_cbs },
    [15] = { .iid = CAMERA_ACTION_PANORAMA, .type = HEY_ACTION_IN_ONCE_OUT_STREAM, .cbs = &panorama_cbs },
};

static int camera_service_register(Iot__Service__Camera__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__camera__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__camera__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)camera_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    schema_srv.actions.iids = (struct hey_action_entry *)actions_iids;
    schema_srv.actions.n_iid = ACT_IID_CNT;
    schema_srv.events.iids = (uint32_t *)camera_event_iids;
    schema_srv.events.n_iid = EV_IID_CNT;
    camera_service = hey_service_register(CAMERA_SERVICE, &schema_srv, NULL);
    if (NULL == camera_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of camera service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t camera_properties_update(size_t count, uint32_t *enumerate, struct camera_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__Camera__Properties *props = NULL;
    uint8_t *buf = NULL;
    ArrayNode **favouritecruisedposition = NULL;
    ArrayNode **fixedpositionforrecord = NULL;
    ArrayNode **fixedpositionandtimerecord = NULL;
    ArrayNode **appeasingbabyworkingperiod = NULL;
    ArrayNode **autodetectionworkingperiod = NULL;
    ArrayNode **appeasingbabymusic = NULL;
    Iot__Service__Camera__AppeasingBabyMusicPlayMode *appeasingbabymusicplaymode = NULL;
    Iot__Service__Camera__AppeasingBabyMusicPlaySetting *appeasingbabymusicplaysetting = NULL;
    ArrayNode **voicememo = NULL;
    ArrayNode **facesource = NULL;
    ArrayNode **voicememoplaycondition = NULL;
    Iot__Service__Camera__LimitedPosition *limitedposition = NULL;
    ArrayNode **sleepmodeworkingperiod = NULL;
    props = malloc(sizeof(Iot__Service__Camera__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__properties__init(props);
    if (properties->n_favouritecruisedposition) {
        favouritecruisedposition = calloc(properties->n_favouritecruisedposition, sizeof(ArrayNode *));
        if (NULL == favouritecruisedposition) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_favouritecruisedposition; i++) {
            favouritecruisedposition[i] = malloc(sizeof(ArrayNode));
            if (NULL == favouritecruisedposition[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(favouritecruisedposition[i]);
            favouritecruisedposition[i]->id = properties->favouritecruisedposition[i]->id;
            favouritecruisedposition[i]->data.data = properties->favouritecruisedposition[i]->data.data;
            favouritecruisedposition[i]->data.len = properties->favouritecruisedposition[i]->data.len;
        }
    }
    if (properties->n_fixedpositionforrecord) {
        fixedpositionforrecord = calloc(properties->n_fixedpositionforrecord, sizeof(ArrayNode *));
        if (NULL == fixedpositionforrecord) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_fixedpositionforrecord; i++) {
            fixedpositionforrecord[i] = malloc(sizeof(ArrayNode));
            if (NULL == fixedpositionforrecord[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(fixedpositionforrecord[i]);
            fixedpositionforrecord[i]->id = properties->fixedpositionforrecord[i]->id;
            fixedpositionforrecord[i]->data.data = properties->fixedpositionforrecord[i]->data.data;
            fixedpositionforrecord[i]->data.len = properties->fixedpositionforrecord[i]->data.len;
        }
    }
    if (properties->n_fixedpositionandtimerecord) {
        fixedpositionandtimerecord = calloc(properties->n_fixedpositionandtimerecord, sizeof(ArrayNode *));
        if (NULL == fixedpositionandtimerecord) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_fixedpositionandtimerecord; i++) {
            fixedpositionandtimerecord[i] = malloc(sizeof(ArrayNode));
            if (NULL == fixedpositionandtimerecord[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(fixedpositionandtimerecord[i]);
            fixedpositionandtimerecord[i]->id = properties->fixedpositionandtimerecord[i]->id;
            fixedpositionandtimerecord[i]->data.data = properties->fixedpositionandtimerecord[i]->data.data;
            fixedpositionandtimerecord[i]->data.len = properties->fixedpositionandtimerecord[i]->data.len;
        }
    }
    if (properties->n_appeasingbabyworkingperiod) {
        appeasingbabyworkingperiod = calloc(properties->n_appeasingbabyworkingperiod, sizeof(ArrayNode *));
        if (NULL == appeasingbabyworkingperiod) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_appeasingbabyworkingperiod; i++) {
            appeasingbabyworkingperiod[i] = malloc(sizeof(ArrayNode));
            if (NULL == appeasingbabyworkingperiod[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(appeasingbabyworkingperiod[i]);
            appeasingbabyworkingperiod[i]->id = properties->appeasingbabyworkingperiod[i]->id;
            appeasingbabyworkingperiod[i]->data.data = properties->appeasingbabyworkingperiod[i]->data.data;
            appeasingbabyworkingperiod[i]->data.len = properties->appeasingbabyworkingperiod[i]->data.len;
        }
    }
    if (properties->n_autodetectionworkingperiod) {
        autodetectionworkingperiod = calloc(properties->n_autodetectionworkingperiod, sizeof(ArrayNode *));
        if (NULL == autodetectionworkingperiod) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_autodetectionworkingperiod; i++) {
            autodetectionworkingperiod[i] = malloc(sizeof(ArrayNode));
            if (NULL == autodetectionworkingperiod[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(autodetectionworkingperiod[i]);
            autodetectionworkingperiod[i]->id = properties->autodetectionworkingperiod[i]->id;
            autodetectionworkingperiod[i]->data.data = properties->autodetectionworkingperiod[i]->data.data;
            autodetectionworkingperiod[i]->data.len = properties->autodetectionworkingperiod[i]->data.len;
        }
    }
    if (properties->n_appeasingbabymusic) {
        appeasingbabymusic = calloc(properties->n_appeasingbabymusic, sizeof(ArrayNode *));
        if (NULL == appeasingbabymusic) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_appeasingbabymusic; i++) {
            appeasingbabymusic[i] = malloc(sizeof(ArrayNode));
            if (NULL == appeasingbabymusic[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(appeasingbabymusic[i]);
            appeasingbabymusic[i]->id = properties->appeasingbabymusic[i]->id;
            appeasingbabymusic[i]->data.data = properties->appeasingbabymusic[i]->data.data;
            appeasingbabymusic[i]->data.len = properties->appeasingbabymusic[i]->data.len;
        }
    }
    if (properties->appeasingbabymusicplaymode) {
        appeasingbabymusicplaymode = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusicPlayMode));
        if (NULL == appeasingbabymusicplaymode) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__appeasing_baby_music_play_mode__init(appeasingbabymusicplaymode);
        appeasingbabymusicplaymode->playmode = properties->appeasingbabymusicplaymode->playmode;
    }
    if (properties->appeasingbabymusicplaysetting) {
        appeasingbabymusicplaysetting = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusicPlaySetting));
        if (NULL == appeasingbabymusicplaysetting) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__appeasing_baby_music_play_setting__init(appeasingbabymusicplaysetting);
        appeasingbabymusicplaysetting->fileurl = properties->appeasingbabymusicplaysetting->fileurl;
        appeasingbabymusicplaysetting->time = properties->appeasingbabymusicplaysetting->time;
    }
    if (properties->n_voicememo) {
        voicememo = calloc(properties->n_voicememo, sizeof(ArrayNode *));
        if (NULL == voicememo) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_voicememo; i++) {
            voicememo[i] = malloc(sizeof(ArrayNode));
            if (NULL == voicememo[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(voicememo[i]);
            voicememo[i]->id = properties->voicememo[i]->id;
            voicememo[i]->data.data = properties->voicememo[i]->data.data;
            voicememo[i]->data.len = properties->voicememo[i]->data.len;
        }
    }
    if (properties->n_facesource) {
        facesource = calloc(properties->n_facesource, sizeof(ArrayNode *));
        if (NULL == facesource) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_facesource; i++) {
            facesource[i] = malloc(sizeof(ArrayNode));
            if (NULL == facesource[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(facesource[i]);
            facesource[i]->id = properties->facesource[i]->id;
            facesource[i]->data.data = properties->facesource[i]->data.data;
            facesource[i]->data.len = properties->facesource[i]->data.len;
        }
    }
    if (properties->n_voicememoplaycondition) {
        voicememoplaycondition = calloc(properties->n_voicememoplaycondition, sizeof(ArrayNode *));
        if (NULL == voicememoplaycondition) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_voicememoplaycondition; i++) {
            voicememoplaycondition[i] = malloc(sizeof(ArrayNode));
            if (NULL == voicememoplaycondition[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(voicememoplaycondition[i]);
            voicememoplaycondition[i]->id = properties->voicememoplaycondition[i]->id;
            voicememoplaycondition[i]->data.data = properties->voicememoplaycondition[i]->data.data;
            voicememoplaycondition[i]->data.len = properties->voicememoplaycondition[i]->data.len;
        }
    }
    if (properties->limitedposition) {
        limitedposition = malloc(sizeof(Iot__Service__Camera__LimitedPosition));
        if (NULL == limitedposition) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__limited_position__init(limitedposition);
        limitedposition->maxhorizontalangle = properties->limitedposition->maxhorizontalangle;
        limitedposition->maxverticalangle = properties->limitedposition->maxverticalangle;
    }
    if (properties->n_sleepmodeworkingperiod) {
        sleepmodeworkingperiod = calloc(properties->n_sleepmodeworkingperiod, sizeof(ArrayNode *));
        if (NULL == sleepmodeworkingperiod) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_sleepmodeworkingperiod; i++) {
            sleepmodeworkingperiod[i] = malloc(sizeof(ArrayNode));
            if (NULL == sleepmodeworkingperiod[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(sleepmodeworkingperiod[i]);
            sleepmodeworkingperiod[i]->id = properties->sleepmodeworkingperiod[i]->id;
            sleepmodeworkingperiod[i]->data.data = properties->sleepmodeworkingperiod[i]->data.data;
            sleepmodeworkingperiod[i]->data.len = properties->sleepmodeworkingperiod[i]->data.len;
        }
    }
    props->power = properties->power;
    props->recordmode = properties->recordmode;
    props->resolution = properties->resolution;
    props->nightvisionsta = properties->nightvisionsta;
    props->recordmute = properties->recordmute;
    props->autodetectionenabled = properties->autodetectionenabled;
    props->fixedpositiondetectionenabled = properties->fixedpositiondetectionenabled;
    props->autocruisedetection = properties->autocruisedetection;
    props->facerecognitionenabled = properties->facerecognitionenabled;
    props->multimediawithtimewatermark = properties->multimediawithtimewatermark;
    props->pushmotiondetectionenabled = properties->pushmotiondetectionenabled;
    props->pushmotiondetectionsilenttime = properties->pushmotiondetectionsilenttime;
    props->camerasensitivity = properties->camerasensitivity;
    props->n_favouritecruisedposition = properties->n_favouritecruisedposition;
    props->favouritecruisedposition = favouritecruisedposition;
    props->n_fixedpositionforrecord = properties->n_fixedpositionforrecord;
    props->fixedpositionforrecord = fixedpositionforrecord;
    props->crydetectionenabled = properties->crydetectionenabled;
    props->pushcrydetectionenabled = properties->pushcrydetectionenabled;
    props->pushcrydetectionsilenttime = properties->pushcrydetectionsilenttime;
    props->appeasingbabyenabled = properties->appeasingbabyenabled;
    props->indicatorlightenabled = properties->indicatorlightenabled;
    props->correctlendistortionenabled = properties->correctlendistortionenabled;
    props->wdrenabled = properties->wdrenabled;
    props->pushfacerecognitionenabled = properties->pushfacerecognitionenabled;
    props->pushfacerecognitionsilenttime = properties->pushfacerecognitionsilenttime;
    props->n_fixedpositionandtimerecord = properties->n_fixedpositionandtimerecord;
    props->fixedpositionandtimerecord = fixedpositionandtimerecord;
    props->n_appeasingbabyworkingperiod = properties->n_appeasingbabyworkingperiod;
    props->appeasingbabyworkingperiod = appeasingbabyworkingperiod;
    props->n_autodetectionworkingperiod = properties->n_autodetectionworkingperiod;
    props->autodetectionworkingperiod = autodetectionworkingperiod;
    props->motiontrackingenabled = properties->motiontrackingenabled;
    props->soundalarmtime = properties->soundalarmtime;
    props->soundalarmvolume = properties->soundalarmvolume;
    props->ringingsound = properties->ringingsound;
    props->recordmotiondetectionsilencetime = properties->recordmotiondetectionsilencetime;
    props->recordhumanmotionsilencetime = properties->recordhumanmotionsilencetime;
    props->recordanimalmotionsilencetime = properties->recordanimalmotionsilencetime;
    props->recordcrydetectionsilencetime = properties->recordcrydetectionsilencetime;
    props->recordfacerecognitionsilenttime = properties->recordfacerecognitionsilenttime;
    props->n_appeasingbabymusic = properties->n_appeasingbabymusic;
    props->appeasingbabymusic = appeasingbabymusic;
    props->appeasingbabymusicplaymode = appeasingbabymusicplaymode;
    props->appeasingbabymusicplaysetting = appeasingbabymusicplaysetting;
    props->pushhumanmotionsilencetime = properties->pushhumanmotionsilencetime;
    props->pushanimalmotionsilencetime = properties->pushanimalmotionsilencetime;
    props->pushhumanmotionenabled = properties->pushhumanmotionenabled;
    props->pushanimalmotionenabled = properties->pushanimalmotionenabled;
    props->n_voicememo = properties->n_voicememo;
    props->voicememo = voicememo;
    props->n_facesource = properties->n_facesource;
    props->facesource = facesource;
    props->pushpicturechangeenabled = properties->pushpicturechangeenabled;
    props->pushpicturechangesilencetime = properties->pushpicturechangesilencetime;
    props->recordpicturechangesilencetime = properties->recordpicturechangesilencetime;
    props->n_voicememoplaycondition = properties->n_voicememoplaycondition;
    props->voicememoplaycondition = voicememoplaycondition;
    props->pushcatmotionenabled = properties->pushcatmotionenabled;
    props->pushdogmotionenabled = properties->pushdogmotionenabled;
    props->pushcatmotionsilenttime = properties->pushcatmotionsilenttime;
    props->pushdogmotionsilenttime = properties->pushdogmotionsilenttime;
    props->recordcatmotionsilencetime = properties->recordcatmotionsilencetime;
    props->recorddogmotionsilencetime = properties->recorddogmotionsilencetime;
    props->eventvideouploadcloudenable = properties->eventvideouploadcloudenable;
    props->groupofpictures = properties->groupofpictures;
    props->framespersecond = properties->framespersecond;
    props->pictureflipmode = properties->pictureflipmode;
    props->limitedposition = limitedposition;
    props->n_sleepmodeworkingperiod = properties->n_sleepmodeworkingperiod;
    props->sleepmodeworkingperiod = sleepmodeworkingperiod;
    props->bitrate = properties->bitrate;
    props->sleep = properties->sleep;
    props->onetouchcallenabled = properties->onetouchcallenabled;

    size_t buf_len;
    buf_len = iot__service__camera__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__camera__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(camera_service, &content);

out:
    free(props);
    free(buf);
    if (favouritecruisedposition) {
        for (int i = 0; i < properties->n_favouritecruisedposition; i++) {
            free(favouritecruisedposition[i]);
        }
        free(favouritecruisedposition);
    }
    if (fixedpositionforrecord) {
        for (int i = 0; i < properties->n_fixedpositionforrecord; i++) {
            free(fixedpositionforrecord[i]);
        }
        free(fixedpositionforrecord);
    }
    if (fixedpositionandtimerecord) {
        for (int i = 0; i < properties->n_fixedpositionandtimerecord; i++) {
            free(fixedpositionandtimerecord[i]);
        }
        free(fixedpositionandtimerecord);
    }
    if (appeasingbabyworkingperiod) {
        for (int i = 0; i < properties->n_appeasingbabyworkingperiod; i++) {
            free(appeasingbabyworkingperiod[i]);
        }
        free(appeasingbabyworkingperiod);
    }
    if (autodetectionworkingperiod) {
        for (int i = 0; i < properties->n_autodetectionworkingperiod; i++) {
            free(autodetectionworkingperiod[i]);
        }
        free(autodetectionworkingperiod);
    }
    if (appeasingbabymusic) {
        for (int i = 0; i < properties->n_appeasingbabymusic; i++) {
            free(appeasingbabymusic[i]);
        }
        free(appeasingbabymusic);
    }
    free(appeasingbabymusicplaymode);
    free(appeasingbabymusicplaysetting);
    if (voicememo) {
        for (int i = 0; i < properties->n_voicememo; i++) {
            free(voicememo[i]);
        }
        free(voicememo);
    }
    if (facesource) {
        for (int i = 0; i < properties->n_facesource; i++) {
            free(facesource[i]);
        }
        free(facesource);
    }
    if (voicememoplaycondition) {
        for (int i = 0; i < properties->n_voicememoplaycondition; i++) {
            free(voicememoplaycondition[i]);
        }
        free(voicememoplaycondition);
    }
    free(limitedposition);
    if (sleepmodeworkingperiod) {
        for (int i = 0; i < properties->n_sleepmodeworkingperiod; i++) {
            free(sleepmodeworkingperiod[i]);
        }
        free(sleepmodeworkingperiod);
    }
    return ret;
}

/**
 * @brief camera service initialization
 * @param properties [camera service properties]
 * @return int32_t   [initialize result]
*/
int32_t camera_service_init(const struct camera_properties *properties)
{
    int ret = 0;
    Iot__Service__Camera__Properties *props = NULL;
    ArrayNode **favouritecruisedposition = NULL;
    ArrayNode **fixedpositionforrecord = NULL;
    ArrayNode **fixedpositionandtimerecord = NULL;
    ArrayNode **appeasingbabyworkingperiod = NULL;
    ArrayNode **autodetectionworkingperiod = NULL;
    ArrayNode **appeasingbabymusic = NULL;
    Iot__Service__Camera__AppeasingBabyMusicPlayMode *appeasingbabymusicplaymode = NULL;
    Iot__Service__Camera__AppeasingBabyMusicPlaySetting *appeasingbabymusicplaysetting = NULL;
    ArrayNode **voicememo = NULL;
    ArrayNode **facesource = NULL;
    ArrayNode **voicememoplaycondition = NULL;
    Iot__Service__Camera__LimitedPosition *limitedposition = NULL;
    ArrayNode **sleepmodeworkingperiod = NULL;
    props = malloc(sizeof(Iot__Service__Camera__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__camera__properties__init(props);
    if (NULL != properties) {
        if (properties->n_favouritecruisedposition) {
            favouritecruisedposition = calloc(properties->n_favouritecruisedposition, sizeof(ArrayNode *));
            if (NULL == favouritecruisedposition) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_favouritecruisedposition; i++) {
                favouritecruisedposition[i] = malloc(sizeof(ArrayNode));
                if (NULL == favouritecruisedposition[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(favouritecruisedposition[i]);
                favouritecruisedposition[i]->id = properties->favouritecruisedposition[i]->id;
                favouritecruisedposition[i]->data.data = properties->favouritecruisedposition[i]->data.data;
                favouritecruisedposition[i]->data.len = properties->favouritecruisedposition[i]->data.len;
            }
        }
        if (properties->n_fixedpositionforrecord) {
            fixedpositionforrecord = calloc(properties->n_fixedpositionforrecord, sizeof(ArrayNode *));
            if (NULL == fixedpositionforrecord) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_fixedpositionforrecord; i++) {
                fixedpositionforrecord[i] = malloc(sizeof(ArrayNode));
                if (NULL == fixedpositionforrecord[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(fixedpositionforrecord[i]);
                fixedpositionforrecord[i]->id = properties->fixedpositionforrecord[i]->id;
                fixedpositionforrecord[i]->data.data = properties->fixedpositionforrecord[i]->data.data;
                fixedpositionforrecord[i]->data.len = properties->fixedpositionforrecord[i]->data.len;
            }
        }
        if (properties->n_fixedpositionandtimerecord) {
            fixedpositionandtimerecord = calloc(properties->n_fixedpositionandtimerecord, sizeof(ArrayNode *));
            if (NULL == fixedpositionandtimerecord) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_fixedpositionandtimerecord; i++) {
                fixedpositionandtimerecord[i] = malloc(sizeof(ArrayNode));
                if (NULL == fixedpositionandtimerecord[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(fixedpositionandtimerecord[i]);
                fixedpositionandtimerecord[i]->id = properties->fixedpositionandtimerecord[i]->id;
                fixedpositionandtimerecord[i]->data.data = properties->fixedpositionandtimerecord[i]->data.data;
                fixedpositionandtimerecord[i]->data.len = properties->fixedpositionandtimerecord[i]->data.len;
            }
        }
        if (properties->n_appeasingbabyworkingperiod) {
            appeasingbabyworkingperiod = calloc(properties->n_appeasingbabyworkingperiod, sizeof(ArrayNode *));
            if (NULL == appeasingbabyworkingperiod) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_appeasingbabyworkingperiod; i++) {
                appeasingbabyworkingperiod[i] = malloc(sizeof(ArrayNode));
                if (NULL == appeasingbabyworkingperiod[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(appeasingbabyworkingperiod[i]);
                appeasingbabyworkingperiod[i]->id = properties->appeasingbabyworkingperiod[i]->id;
                appeasingbabyworkingperiod[i]->data.data = properties->appeasingbabyworkingperiod[i]->data.data;
                appeasingbabyworkingperiod[i]->data.len = properties->appeasingbabyworkingperiod[i]->data.len;
            }
        }
        if (properties->n_autodetectionworkingperiod) {
            autodetectionworkingperiod = calloc(properties->n_autodetectionworkingperiod, sizeof(ArrayNode *));
            if (NULL == autodetectionworkingperiod) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_autodetectionworkingperiod; i++) {
                autodetectionworkingperiod[i] = malloc(sizeof(ArrayNode));
                if (NULL == autodetectionworkingperiod[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(autodetectionworkingperiod[i]);
                autodetectionworkingperiod[i]->id = properties->autodetectionworkingperiod[i]->id;
                autodetectionworkingperiod[i]->data.data = properties->autodetectionworkingperiod[i]->data.data;
                autodetectionworkingperiod[i]->data.len = properties->autodetectionworkingperiod[i]->data.len;
            }
        }
        if (properties->n_appeasingbabymusic) {
            appeasingbabymusic = calloc(properties->n_appeasingbabymusic, sizeof(ArrayNode *));
            if (NULL == appeasingbabymusic) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_appeasingbabymusic; i++) {
                appeasingbabymusic[i] = malloc(sizeof(ArrayNode));
                if (NULL == appeasingbabymusic[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(appeasingbabymusic[i]);
                appeasingbabymusic[i]->id = properties->appeasingbabymusic[i]->id;
                appeasingbabymusic[i]->data.data = properties->appeasingbabymusic[i]->data.data;
                appeasingbabymusic[i]->data.len = properties->appeasingbabymusic[i]->data.len;
            }
        }
        if (properties->appeasingbabymusicplaymode) {
            appeasingbabymusicplaymode = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusicPlayMode));
            if (NULL == appeasingbabymusicplaymode) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__appeasing_baby_music_play_mode__init(appeasingbabymusicplaymode);
            appeasingbabymusicplaymode->playmode = properties->appeasingbabymusicplaymode->playmode;
        }
        if (properties->appeasingbabymusicplaysetting) {
            appeasingbabymusicplaysetting = malloc(sizeof(Iot__Service__Camera__AppeasingBabyMusicPlaySetting));
            if (NULL == appeasingbabymusicplaysetting) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__appeasing_baby_music_play_setting__init(appeasingbabymusicplaysetting);
            appeasingbabymusicplaysetting->fileurl = properties->appeasingbabymusicplaysetting->fileurl;
            appeasingbabymusicplaysetting->time = properties->appeasingbabymusicplaysetting->time;
        }
        if (properties->n_voicememo) {
            voicememo = calloc(properties->n_voicememo, sizeof(ArrayNode *));
            if (NULL == voicememo) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_voicememo; i++) {
                voicememo[i] = malloc(sizeof(ArrayNode));
                if (NULL == voicememo[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(voicememo[i]);
                voicememo[i]->id = properties->voicememo[i]->id;
                voicememo[i]->data.data = properties->voicememo[i]->data.data;
                voicememo[i]->data.len = properties->voicememo[i]->data.len;
            }
        }
        if (properties->n_facesource) {
            facesource = calloc(properties->n_facesource, sizeof(ArrayNode *));
            if (NULL == facesource) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_facesource; i++) {
                facesource[i] = malloc(sizeof(ArrayNode));
                if (NULL == facesource[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(facesource[i]);
                facesource[i]->id = properties->facesource[i]->id;
                facesource[i]->data.data = properties->facesource[i]->data.data;
                facesource[i]->data.len = properties->facesource[i]->data.len;
            }
        }
        if (properties->n_voicememoplaycondition) {
            voicememoplaycondition = calloc(properties->n_voicememoplaycondition, sizeof(ArrayNode *));
            if (NULL == voicememoplaycondition) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_voicememoplaycondition; i++) {
                voicememoplaycondition[i] = malloc(sizeof(ArrayNode));
                if (NULL == voicememoplaycondition[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(voicememoplaycondition[i]);
                voicememoplaycondition[i]->id = properties->voicememoplaycondition[i]->id;
                voicememoplaycondition[i]->data.data = properties->voicememoplaycondition[i]->data.data;
                voicememoplaycondition[i]->data.len = properties->voicememoplaycondition[i]->data.len;
            }
        }
        if (properties->limitedposition) {
            limitedposition = malloc(sizeof(Iot__Service__Camera__LimitedPosition));
            if (NULL == limitedposition) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__camera__limited_position__init(limitedposition);
            limitedposition->maxhorizontalangle = properties->limitedposition->maxhorizontalangle;
            limitedposition->maxverticalangle = properties->limitedposition->maxverticalangle;
        }
        if (properties->n_sleepmodeworkingperiod) {
            sleepmodeworkingperiod = calloc(properties->n_sleepmodeworkingperiod, sizeof(ArrayNode *));
            if (NULL == sleepmodeworkingperiod) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_sleepmodeworkingperiod; i++) {
                sleepmodeworkingperiod[i] = malloc(sizeof(ArrayNode));
                if (NULL == sleepmodeworkingperiod[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(sleepmodeworkingperiod[i]);
                sleepmodeworkingperiod[i]->id = properties->sleepmodeworkingperiod[i]->id;
                sleepmodeworkingperiod[i]->data.data = properties->sleepmodeworkingperiod[i]->data.data;
                sleepmodeworkingperiod[i]->data.len = properties->sleepmodeworkingperiod[i]->data.len;
            }
        }
        props->power = properties->power;
        props->recordmode = properties->recordmode;
        props->resolution = properties->resolution;
        props->nightvisionsta = properties->nightvisionsta;
        props->recordmute = properties->recordmute;
        props->autodetectionenabled = properties->autodetectionenabled;
        props->fixedpositiondetectionenabled = properties->fixedpositiondetectionenabled;
        props->autocruisedetection = properties->autocruisedetection;
        props->facerecognitionenabled = properties->facerecognitionenabled;
        props->multimediawithtimewatermark = properties->multimediawithtimewatermark;
        props->pushmotiondetectionenabled = properties->pushmotiondetectionenabled;
        props->pushmotiondetectionsilenttime = properties->pushmotiondetectionsilenttime;
        props->camerasensitivity = properties->camerasensitivity;
        props->n_favouritecruisedposition = properties->n_favouritecruisedposition;
        props->favouritecruisedposition = favouritecruisedposition;
        props->n_fixedpositionforrecord = properties->n_fixedpositionforrecord;
        props->fixedpositionforrecord = fixedpositionforrecord;
        props->crydetectionenabled = properties->crydetectionenabled;
        props->pushcrydetectionenabled = properties->pushcrydetectionenabled;
        props->pushcrydetectionsilenttime = properties->pushcrydetectionsilenttime;
        props->appeasingbabyenabled = properties->appeasingbabyenabled;
        props->indicatorlightenabled = properties->indicatorlightenabled;
        props->correctlendistortionenabled = properties->correctlendistortionenabled;
        props->wdrenabled = properties->wdrenabled;
        props->pushfacerecognitionenabled = properties->pushfacerecognitionenabled;
        props->pushfacerecognitionsilenttime = properties->pushfacerecognitionsilenttime;
        props->n_fixedpositionandtimerecord = properties->n_fixedpositionandtimerecord;
        props->fixedpositionandtimerecord = fixedpositionandtimerecord;
        props->n_appeasingbabyworkingperiod = properties->n_appeasingbabyworkingperiod;
        props->appeasingbabyworkingperiod = appeasingbabyworkingperiod;
        props->n_autodetectionworkingperiod = properties->n_autodetectionworkingperiod;
        props->autodetectionworkingperiod = autodetectionworkingperiod;
        props->motiontrackingenabled = properties->motiontrackingenabled;
        props->soundalarmtime = properties->soundalarmtime;
        props->soundalarmvolume = properties->soundalarmvolume;
        props->ringingsound = properties->ringingsound;
        props->recordmotiondetectionsilencetime = properties->recordmotiondetectionsilencetime;
        props->recordhumanmotionsilencetime = properties->recordhumanmotionsilencetime;
        props->recordanimalmotionsilencetime = properties->recordanimalmotionsilencetime;
        props->recordcrydetectionsilencetime = properties->recordcrydetectionsilencetime;
        props->recordfacerecognitionsilenttime = properties->recordfacerecognitionsilenttime;
        props->n_appeasingbabymusic = properties->n_appeasingbabymusic;
        props->appeasingbabymusic = appeasingbabymusic;
        props->appeasingbabymusicplaymode = appeasingbabymusicplaymode;
        props->appeasingbabymusicplaysetting = appeasingbabymusicplaysetting;
        props->pushhumanmotionsilencetime = properties->pushhumanmotionsilencetime;
        props->pushanimalmotionsilencetime = properties->pushanimalmotionsilencetime;
        props->pushhumanmotionenabled = properties->pushhumanmotionenabled;
        props->pushanimalmotionenabled = properties->pushanimalmotionenabled;
        props->n_voicememo = properties->n_voicememo;
        props->voicememo = voicememo;
        props->n_facesource = properties->n_facesource;
        props->facesource = facesource;
        props->pushpicturechangeenabled = properties->pushpicturechangeenabled;
        props->pushpicturechangesilencetime = properties->pushpicturechangesilencetime;
        props->recordpicturechangesilencetime = properties->recordpicturechangesilencetime;
        props->n_voicememoplaycondition = properties->n_voicememoplaycondition;
        props->voicememoplaycondition = voicememoplaycondition;
        props->pushcatmotionenabled = properties->pushcatmotionenabled;
        props->pushdogmotionenabled = properties->pushdogmotionenabled;
        props->pushcatmotionsilenttime = properties->pushcatmotionsilenttime;
        props->pushdogmotionsilenttime = properties->pushdogmotionsilenttime;
        props->recordcatmotionsilencetime = properties->recordcatmotionsilencetime;
        props->recorddogmotionsilencetime = properties->recorddogmotionsilencetime;
        props->eventvideouploadcloudenable = properties->eventvideouploadcloudenable;
        props->groupofpictures = properties->groupofpictures;
        props->framespersecond = properties->framespersecond;
        props->pictureflipmode = properties->pictureflipmode;
        props->limitedposition = limitedposition;
        props->n_sleepmodeworkingperiod = properties->n_sleepmodeworkingperiod;
        props->sleepmodeworkingperiod = sleepmodeworkingperiod;
        props->bitrate = properties->bitrate;
        props->sleep = properties->sleep;
        props->onetouchcallenabled = properties->onetouchcallenabled;
    }

    ret = camera_service_register(props);

out:
    free(props);
    if (favouritecruisedposition) {
        for (int i = 0; i < properties->n_favouritecruisedposition; i++) {
            free(favouritecruisedposition[i]);
        }
        free(favouritecruisedposition);
    }
    if (fixedpositionforrecord) {
        for (int i = 0; i < properties->n_fixedpositionforrecord; i++) {
            free(fixedpositionforrecord[i]);
        }
        free(fixedpositionforrecord);
    }
    if (fixedpositionandtimerecord) {
        for (int i = 0; i < properties->n_fixedpositionandtimerecord; i++) {
            free(fixedpositionandtimerecord[i]);
        }
        free(fixedpositionandtimerecord);
    }
    if (appeasingbabyworkingperiod) {
        for (int i = 0; i < properties->n_appeasingbabyworkingperiod; i++) {
            free(appeasingbabyworkingperiod[i]);
        }
        free(appeasingbabyworkingperiod);
    }
    if (autodetectionworkingperiod) {
        for (int i = 0; i < properties->n_autodetectionworkingperiod; i++) {
            free(autodetectionworkingperiod[i]);
        }
        free(autodetectionworkingperiod);
    }
    if (appeasingbabymusic) {
        for (int i = 0; i < properties->n_appeasingbabymusic; i++) {
            free(appeasingbabymusic[i]);
        }
        free(appeasingbabymusic);
    }
    free(appeasingbabymusicplaymode);
    free(appeasingbabymusicplaysetting);
    if (voicememo) {
        for (int i = 0; i < properties->n_voicememo; i++) {
            free(voicememo[i]);
        }
        free(voicememo);
    }
    if (facesource) {
        for (int i = 0; i < properties->n_facesource; i++) {
            free(facesource[i]);
        }
        free(facesource);
    }
    if (voicememoplaycondition) {
        for (int i = 0; i < properties->n_voicememoplaycondition; i++) {
            free(voicememoplaycondition[i]);
        }
        free(voicememoplaycondition);
    }
    free(limitedposition);
    if (sleepmodeworkingperiod) {
        for (int i = 0; i < properties->n_sleepmodeworkingperiod; i++) {
            free(sleepmodeworkingperiod[i]);
        }
        free(sleepmodeworkingperiod);
    }
    return ret;
}

/**
 * @brief cry detection start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_cry_detection_start_notify(struct camera_event_cry_detection_start *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventCryDetectionStart *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventCryDetectionStart));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_cry_detection_start__init(ev);
    ev->eventstarttime = event->eventstarttime;
    ev->uploadvideoenable = event->uploadvideoenable;

    size_t buf_len;
    buf_len = iot__service__camera__event_cry_detection_start__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_cry_detection_start__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_CRY_DETECTION_START,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_cry_detection_start_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief face recognition detected notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_face_recognition_detected_notify(struct camera_event_face_recognition_detected *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventFaceRecognitionDetected *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventFaceRecognitionDetected));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_face_recognition_detected__init(ev);
    ev->faceinfoname = event->faceinfoname;
    ev->thumbnaiurl = event->thumbnaiurl;

    size_t buf_len;
    buf_len = iot__service__camera__event_face_recognition_detected__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_face_recognition_detected__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_FACE_RECOGNITION_DETECTED,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_face_recognition_detected_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief record notify notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_record_notify_notify(struct camera_event_record_notify *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventRecordNotify *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventRecordNotify));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_record_notify__init(ev);
    ev->filename = event->filename;
    ev->mediatype = event->mediatype;

    size_t buf_len;
    buf_len = iot__service__camera__event_record_notify__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_record_notify__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_RECORD_NOTIFY,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_record_notify_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief motion detection start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_motion_detection_start_notify(struct camera_event_motion_detection_start *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventMotionDetectionStart *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventMotionDetectionStart));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_motion_detection_start__init(ev);
    ev->eventstarttime = event->eventstarttime;
    ev->resulttype = event->resulttype;
    ev->uploadvideoenable = event->uploadvideoenable;

    size_t buf_len;
    buf_len = iot__service__camera__event_motion_detection_start__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_motion_detection_start__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_MOTION_DETECTION_START,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_motion_detection_start_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief motion detection end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_motion_detection_end_notify(struct camera_event_motion_detection_end *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventMotionDetectionEnd *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventMotionDetectionEnd));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_motion_detection_end__init(ev);
    ev->eventendtime = event->eventendtime;

    size_t buf_len;
    buf_len = iot__service__camera__event_motion_detection_end__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_motion_detection_end__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_MOTION_DETECTION_END,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_motion_detection_end_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief cry detection end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_cry_detection_end_notify(struct camera_event_cry_detection_end *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventCryDetectionEnd *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventCryDetectionEnd));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_cry_detection_end__init(ev);
    ev->eventendtime = event->eventendtime;

    size_t buf_len;
    buf_len = iot__service__camera__event_cry_detection_end__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_cry_detection_end__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_CRY_DETECTION_END,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_cry_detection_end_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief dial record start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_dial_record_start_notify(struct camera_event_dial_record_start *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventDialRecordStart *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventDialRecordStart));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_dial_record_start__init(ev);
    ev->eventstarttime = event->eventstarttime;
    ev->uploadvideoenable = event->uploadvideoenable;

    size_t buf_len;
    buf_len = iot__service__camera__event_dial_record_start__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_dial_record_start__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_DIAL_RECORD_START,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_dial_record_start_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}

/**
 * @brief dial record end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_dial_record_end_notify(struct camera_event_dial_record_end *event, struct hey_event_notify_attr *attr)
{
    int64_t ret = -1;

    Iot__Service__Camera__EventDialRecordEnd *ev = NULL;
    uint8_t *buf = NULL;
    ev = malloc(sizeof(Iot__Service__Camera__EventDialRecordEnd));
    if (NULL == ev) {
        errno = ENOMEM;
        return ret;
    }
    iot__service__camera__event_dial_record_end__init(ev);
    ev->eventendtime = event->eventendtime;

    size_t buf_len;
    buf_len = iot__service__camera__event_dial_record_end__get_packed_size(ev);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            errno = ENOMEM;
            goto out;
        }
        iot__service__camera__event_dial_record_end__pack(ev, buf);
    }

    struct hey_event_notify_content content = {
        .iid = CAMERA_EVENT_DIAL_RECORD_END,
        .importance = attr->importance,
        .uuid = attr->uuid,
        .ref_uuid = attr->ref_uuid,
        .timestamp = attr->timestamp,
        .len = buf_len,
        .value = buf,
    };
    ret = hey_event_notify(camera_service, &content, camera_dial_record_end_notify_result_cb, attr->ctx);

out:
    free(ev);
    free(buf);
    return ret;
}
