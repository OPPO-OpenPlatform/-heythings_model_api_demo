/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: camera.proto */

#ifndef CAMERA_SERVICE_H
#define CAMERA_SERVICE_H

#include "hey/types.h"

enum camera_action_linear_movement_linear_movementtype {
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_UP = 0,
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_DOWN = 1,
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_RIGHT = 2,
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_LEFT = 3,
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_FORWARD = 4,
    CAMERA_ACTION_LINEAR_MOVEMENT_LINEAR_MOVEMENTTYPE_BACK = 5
};

enum camera_action_out_linear_movement_border_state {
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_NOT_ON_BORDER = 0,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_UP_BORDER = 1,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_DOWN_BORDER = 2,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_RIGHT_BORDER = 3,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_LEFT_BORDER = 4,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_FORWARD_BORDER = 5,
    CAMERA_ACTION_OUT_LINEAR_MOVEMENT_BORDER_STATE_BACK_BORDER = 6
};

enum record_point_recorde_event_type {
    RECORD_POINT_RECORDE_EVENT_TYPE_PICTURE_CHANGE = 0,
    RECORD_POINT_RECORDE_EVENT_TYPE_CRY = 1,
    RECORD_POINT_RECORDE_EVENT_TYPE_STAYING_DOORWAY = 2,
    RECORD_POINT_RECORDE_EVENT_TYPE_PASSING_BY_DOOR = 3,
    RECORD_POINT_RECORDE_EVENT_TYPE_HUMAN_MOTION = 4,
    RECORD_POINT_RECORDE_EVENT_TYPE_ANIMAL_MOTION = 5,
    RECORD_POINT_RECORDE_EVENT_TYPE_CAT_MOTION = 6,
    RECORD_POINT_RECORDE_EVENT_TYPE_DOG_MOTION = 7,
  /*
   *一键通话拨打记录
   */
    RECORD_POINT_RECORDE_EVENT_TYPE_DIAL_RECORD = 8
};

enum event_record_notify_media_type {
    EVENT_RECORD_NOTIFY_MEDIA_TYPE_PICTURE = 0,
    EVENT_RECORD_NOTIFY_MEDIA_TYPE_AUDIO = 1,
    EVENT_RECORD_NOTIFY_MEDIA_TYPE_VIDEO = 2
};

enum event_motion_detection_start_result_type {
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_PICTURE_CHANGE = 0,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_STAYING_DOORWAY = 1,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_PASSING_BY_DOOR = 2,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_HUMAN_MOTION = 3,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_ANIMAL_MOTION = 4,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_CAT_MOTION = 5,
    EVENT_MOTION_DETECTION_START_RESULT_TYPE_DOG_MOTION = 6
};

enum appeasing_baby_music_file_type {
    APPEASING_BABY_MUSIC_FILE_TYPE_FROM_VENDOR = 0,
    APPEASING_BABY_MUSIC_FILE_TYPE_FROM_USER = 1
};

enum appeasing_baby_music_play_mode_play_mode {
    APPEASING_BABY_MUSIC_PLAY_MODE_PLAY_MODE_SINGLE_PLAY = 0,
    APPEASING_BABY_MUSIC_PLAY_MODE_PLAY_MODE_RANDOM_PLAY = 1
};

enum camera_action_get_recording_time_precision {
    CAMERA_ACTION_GET_RECORDING_TIME_PRECISION_DAY = 0,
    CAMERA_ACTION_GET_RECORDING_TIME_PRECISION_HOUR = 1,
    CAMERA_ACTION_GET_RECORDING_TIME_PRECISION_MINUTE = 2
};

enum event_info_event_type {
    EVENT_INFO_EVENT_TYPE_PICTURE_CHANGE = 0,
    EVENT_INFO_EVENT_TYPE_CRY = 1,
    EVENT_INFO_EVENT_TYPE_STAYING_DOORWAY = 2,
    EVENT_INFO_EVENT_TYPE_PASSING_BY_DOOR = 3,
    EVENT_INFO_EVENT_TYPE_HUMAN_MOTION = 4,
    EVENT_INFO_EVENT_TYPE_ANIMAL_MOTION = 5,
    EVENT_INFO_EVENT_TYPE_CAT_MOTION = 6,
    EVENT_INFO_EVENT_TYPE_DOG_MOTION = 7,
  /*
   *一键通话拨打记录
   */
    EVENT_INFO_EVENT_TYPE_DIAL_RECORD = 8
};

enum camera_action_out_panorama_end_code {
  /*
   *成功，完成后再应答
   */
    CAMERA_ACTION_OUT_PANORAMA_END_CODE_SUCCESS = 0,
  /*
   *忙，无法执行
   */
    CAMERA_ACTION_OUT_PANORAMA_END_CODE_BUSY = 1
};

enum camera_record_mode {
    CAMERA_RECORD_MODE_NOT_RECORD = 0,
    CAMERA_RECORD_MODE_ALLWAYS_RECORD = 1,
    CAMERA_RECORD_MODE_EVENT_RECORD = 2
};

enum camera_predefined_resolution {
    CAMERA_PREDEFINED_RESOLUTION_AUTO = 0,
    CAMERA_PREDEFINED_RESOLUTION_R360P = 1,
    CAMERA_PREDEFINED_RESOLUTION_R720P = 2,
  /*
   *2K
   */
    CAMERA_PREDEFINED_RESOLUTION_R1080P = 3,
    CAMERA_PREDEFINED_RESOLUTION_R1280P = 4,
    CAMERA_PREDEFINED_RESOLUTION_R1296P = 5,
    CAMERA_PREDEFINED_RESOLUTION_R480P = 6,
  /*
   *2.5K
   */
    CAMERA_PREDEFINED_RESOLUTION_R1440P = 7
};

enum camera_night_vision_sta {
    CAMERA_NIGHT_VISION_STA_N_AUTO = 0,
    CAMERA_NIGHT_VISION_STA_N_ON = 1,
    CAMERA_NIGHT_VISION_STA_N_OFF = 2
};

enum camera_auto_cruise_detection {
    CAMERA_AUTO_CRUISE_DETECTION_CLOSE = 0,
    CAMERA_AUTO_CRUISE_DETECTION_FAVPOSCRUISE = 1,
    CAMERA_AUTO_CRUISE_DETECTION_PANORAMICCRUISE = 2
};

enum camera_ringing_sound {
    CAMERA_RINGING_SOUND_SILENT = 0,
    CAMERA_RINGING_SOUND_RING1 = 1,
    CAMERA_RINGING_SOUND_RING2 = 2
};

enum camera_picture_flip_mode {
    CAMERA_PICTURE_FLIP_MODE_NO_FLIP = 0,
    CAMERA_PICTURE_FLIP_MODE_VERTICAL_FLIP = 1,
    CAMERA_PICTURE_FLIP_MODE_HORIZONTAL_FLIP = 2,
  /*
   *VERTICAL_FLIP + HORIZONTAL_FLIP
   */
    CAMERA_PICTURE_FLIP_MODE_CENTRAL_FLIP = 3
};

struct fixed_position_and_time_record_position {
    uint32_t x;
    uint32_t y;
};

struct camera_fixed_position_and_time_record {
    uint32_t week;
    uint32_t hour;
    uint32_t min;
    struct fixed_position_and_time_record_position *position;
};

struct camera_appeasing_baby_working_period {
    uint32_t week;
    uint32_t fromhour;
    uint32_t frommin;
    uint32_t tohour;
    uint32_t tomin;
};

struct camera_auto_detection_working_period {
    uint32_t week;
    uint32_t fromhour;
    uint32_t frommin;
    uint32_t tohour;
    uint32_t tomin;
};

struct voice_memo_play_condition_period_condition {
    uint32_t week;
    uint32_t hour;
    uint32_t minute;
};

struct voice_memo_play_condition_face_condition {
    char *faceid;
    char *name;
};

struct camera_voice_memo_play_condition {
    struct voice_memo_play_condition_period_condition *periodcondition;
    struct voice_memo_play_condition_face_condition *facecondition;
    bool enable;
    char *fileid;
};

struct camera_linear_movement_in {
    enum camera_action_linear_movement_linear_movementtype linearmovementtype;
};

struct camera_linear_movement_out {
    uint32_t x;
    uint32_t y;
    enum camera_action_out_linear_movement_border_state state;
};

struct camera_get_record_list_in {
    uint64_t fromtime;
    uint64_t totime;
    uint32_t recordcount;
};

struct camera_get_record_list_picture_info_record_point_out {
    enum record_point_recorde_event_type type;
    uint64_t frameindex;
};

struct camera_get_record_list_picture_info_out {
    char *recordfilename;
    char *thumbnailfilename;
    uint64_t recordstarttime;
    uint32_t recordelapsedtime;
    bool autodeleteenabled;
    size_t n_recordpoint;
    struct camera_get_record_list_picture_info_record_point_out **recordpoint;
};

struct camera_get_record_list_out {
    uint32_t totalrecordcount;
    size_t n_pictureinfo;
    struct camera_get_record_list_picture_info_out **pictureinfo;
};

struct camera_del_record_info_in {
    size_t n_recordstarttime;
    uint64_t *recordstarttime;
};

struct camera_del_record_info_out {
    char __place_holder__; // make compiler happy
};

struct camera_take_photo_in {
    char __place_holder__; // make compiler happy
};

struct camera_take_photo_out {
    char *filename;
};

struct camera_get_picture_list_in {
    uint64_t fromtime;
    uint64_t totime;
    uint32_t count;
};

struct camera_get_picture_list_picture_info_out {
    char *filename;
    uint64_t capturetime;
};

struct camera_get_picture_list_out {
    uint32_t totalcount;
    size_t n_pictureinfo;
    struct camera_get_picture_list_picture_info_out **pictureinfo;
};

struct camera_del_picture_info_in {
    size_t n_filename;
    char **filename;
};

struct camera_del_picture_info_out {
    char __place_holder__; // make compiler happy
};

struct camera_event_cry_detection_start {
    uint64_t eventstarttime;
    bool uploadvideoenable;
};

struct camera_event_cry_detection_end {
    uint64_t eventendtime;
};

struct camera_event_face_recognition_detected {
    size_t n_faceinfoname;
    char **faceinfoname;
    char *thumbnaiurl;
};

struct camera_event_record_notify {
    char *filename;
    enum event_record_notify_media_type mediatype;
};

struct camera_event_motion_detection_start {
    uint64_t eventstarttime;
    enum event_motion_detection_start_result_type resulttype;
    bool uploadvideoenable;
};

struct camera_event_motion_detection_end {
    uint64_t eventendtime;
};

struct camera_appeasing_baby_music {
    char *fileurl;
    enum appeasing_baby_music_file_type filetype;
    uint32_t duration;
};

struct camera_appeasing_baby_music_play_mode {
    enum appeasing_baby_music_play_mode_play_mode playmode;
};

struct camera_appeasing_baby_music_play_setting {
    char *fileurl;
    uint32_t time;
};

struct favourite_cruised_position_position {
    uint32_t x;
    uint32_t y;
};

struct camera_favourite_cruised_position {
    char *name;
    char *fileid;
    struct favourite_cruised_position_position *position;
};

struct camera_fixed_position_for_record {
    uint32_t x;
    uint32_t y;
};

struct camera_voice_memo {
    char *fileid;
    uint32_t duration;
};

struct camera_face_source {
    char *faceid;
    char *faceinfo;
    char *faceurl;
};

struct camera_ptz_calibration_in {
    char __place_holder__; // make compiler happy
};

struct camera_ptz_calibration_out {
    char __place_holder__; // make compiler happy
};

struct camera_sound_alarm_in {
    char __place_holder__; // make compiler happy
};

struct camera_sound_alarm_out {
    char __place_holder__; // make compiler happy
};

struct camera_moving_to_fav_position_in {
    uint32_t x;
    uint32_t y;
};

struct camera_moving_to_fav_position_out {
    char __place_holder__; // make compiler happy
};

struct camera_get_recording_time_in {
    uint64_t fromtime;
    uint64_t totime;
    uint32_t recordcount;
    enum camera_action_get_recording_time_precision precision;
};

struct camera_get_recording_time_out {
    uint32_t totalrecordcount;
    size_t n_timeofrecording;
    uint64_t *timeofrecording;
};

struct camera_get_current_position_in {
    char __place_holder__; // make compiler happy
};

struct camera_get_current_position_out {
    uint32_t x;
    uint32_t y;
};

struct camera_play_voice_memo_in {
    char *fileid;
};

struct camera_play_voice_memo_out {
    char __place_holder__; // make compiler happy
};

struct camera_get_record_event_list_in {
    uint64_t fromtime;
    uint64_t totime;
    uint32_t recordcount;
};

struct camera_get_record_event_list_event_info_out {
    enum event_info_event_type eventtype;
    uint64_t starttime;
    uint64_t endtime;
    uint64_t notificationid;
};

struct camera_get_record_event_list_out {
    uint32_t totalcount;
    size_t n_eventinfo;
    struct camera_get_record_event_list_event_info_out **eventinfo;
};

struct camera_get_video_period_in {
    char __place_holder__; // make compiler happy
};

struct camera_get_video_period_out {
    uint64_t endtime;
    uint64_t starttime;
};

struct camera_limited_position {
    uint32_t maxhorizontalangle;
    uint32_t maxverticalangle;
};

struct sleep_mode_working_period_sleep_period {
    uint32_t week;
    uint32_t fromhour;
    uint32_t frommin;
    uint32_t tohour;
    uint32_t tomin;
};

struct camera_sleep_mode_working_period {
    bool enable;
    struct sleep_mode_working_period_sleep_period *sleepperiod;
};

struct camera_device_reboot_in {
    char __place_holder__; // make compiler happy
};

struct camera_device_reboot_out {
    char __place_holder__; // make compiler happy
};

struct camera_panorama_in {
    uint32_t horizontalangle;
    uint32_t verticalangle;
};

struct camera_panorama_picture_position_out {
    uint32_t x;
    uint32_t y;
};

struct camera_panorama_picture_out {
    char *fileid;
    struct camera_panorama_picture_position_out *point;
};

enum camera_panorama_send_type_out {
    CAMERA_PANORAMA_SEND_TYPE_OUT_NOT_SET = 0,
    CAMERA_PANORAMA_SEND_TYPE_OUT_PIC = 1,
    CAMERA_PANORAMA_SEND_TYPE_OUT_CODE = 2
};

struct camera_panorama_out {
    enum camera_panorama_send_type_out send_type_case;
    union {
        struct camera_panorama_picture_out *pic;
        enum camera_action_out_panorama_end_code code;
    };
};

struct camera_event_dial_record_start {
    uint64_t eventstarttime;
    bool uploadvideoenable;
};

struct camera_event_dial_record_end {
    uint64_t eventendtime;
};

enum CAMERA_PROPERTY {
    CAMERA_PROPERTY_POWER = 1,
    CAMERA_PROPERTY_RECORDMODE = 2,
    CAMERA_PROPERTY_RESOLUTION = 3,
    CAMERA_PROPERTY_NIGHTVISIONSTA = 4,
    CAMERA_PROPERTY_RECORDMUTE = 5,
    CAMERA_PROPERTY_AUTODETECTIONENABLED = 6,
    CAMERA_PROPERTY_FIXEDPOSITIONDETECTIONENABLED = 7,
    CAMERA_PROPERTY_AUTOCRUISEDETECTION = 8,
    CAMERA_PROPERTY_FACERECOGNITIONENABLED = 9,
    CAMERA_PROPERTY_MULTIMEDIAWITHTIMEWATERMARK = 10,
    CAMERA_PROPERTY_PUSHMOTIONDETECTIONENABLED = 11,
    CAMERA_PROPERTY_PUSHMOTIONDETECTIONSILENTTIME = 12,
    CAMERA_PROPERTY_CAMERASENSITIVITY = 13,
    CAMERA_PROPERTY_FAVOURITECRUISEDPOSITION = 14,
    CAMERA_PROPERTY_FIXEDPOSITIONFORRECORD = 15,
    CAMERA_PROPERTY_CRYDETECTIONENABLED = 16,
    CAMERA_PROPERTY_PUSHCRYDETECTIONENABLED = 17,
    CAMERA_PROPERTY_PUSHCRYDETECTIONSILENTTIME = 18,
    CAMERA_PROPERTY_APPEASINGBABYENABLED = 19,
    CAMERA_PROPERTY_INDICATORLIGHTENABLED = 20,
    CAMERA_PROPERTY_CORRECTLENDISTORTIONENABLED = 21,
    CAMERA_PROPERTY_WDRENABLED = 22,
    CAMERA_PROPERTY_PUSHFACERECOGNITIONENABLED = 23,
    CAMERA_PROPERTY_PUSHFACERECOGNITIONSILENTTIME = 24,
    CAMERA_PROPERTY_FIXEDPOSITIONANDTIMERECORD = 25,
    CAMERA_PROPERTY_APPEASINGBABYWORKINGPERIOD = 26,
    CAMERA_PROPERTY_AUTODETECTIONWORKINGPERIOD = 27,
    CAMERA_PROPERTY_MOTIONTRACKINGENABLED = 28,
    CAMERA_PROPERTY_SOUNDALARMTIME = 29,
    CAMERA_PROPERTY_SOUNDALARMVOLUME = 30,
    CAMERA_PROPERTY_RINGINGSOUND = 31,
    CAMERA_PROPERTY_RECORDMOTIONDETECTIONSILENCETIME = 32,
    CAMERA_PROPERTY_RECORDHUMANMOTIONSILENCETIME = 33,
    CAMERA_PROPERTY_RECORDANIMALMOTIONSILENCETIME = 34,
    CAMERA_PROPERTY_RECORDCRYDETECTIONSILENCETIME = 35,
    CAMERA_PROPERTY_RECORDFACERECOGNITIONSILENTTIME = 36,
    CAMERA_PROPERTY_APPEASINGBABYMUSIC = 37,
    CAMERA_PROPERTY_APPEASINGBABYMUSICPLAYMODE = 38,
    CAMERA_PROPERTY_APPEASINGBABYMUSICPLAYSETTING = 39,
    CAMERA_PROPERTY_PUSHHUMANMOTIONSILENCETIME = 40,
    CAMERA_PROPERTY_PUSHANIMALMOTIONSILENCETIME = 41,
    CAMERA_PROPERTY_PUSHHUMANMOTIONENABLED = 42,
    CAMERA_PROPERTY_PUSHANIMALMOTIONENABLED = 43,
    CAMERA_PROPERTY_VOICEMEMO = 44,
    CAMERA_PROPERTY_FACESOURCE = 58,
    CAMERA_PROPERTY_PUSHPICTURECHANGEENABLED = 63,
    CAMERA_PROPERTY_PUSHPICTURECHANGESILENCETIME = 64,
    CAMERA_PROPERTY_RECORDPICTURECHANGESILENCETIME = 65,
    CAMERA_PROPERTY_VOICEMEMOPLAYCONDITION = 66,
    CAMERA_PROPERTY_PUSHCATMOTIONENABLED = 67,
    CAMERA_PROPERTY_PUSHDOGMOTIONENABLED = 68,
    CAMERA_PROPERTY_PUSHCATMOTIONSILENTTIME = 69,
    CAMERA_PROPERTY_PUSHDOGMOTIONSILENTTIME = 70,
    CAMERA_PROPERTY_RECORDCATMOTIONSILENCETIME = 71,
    CAMERA_PROPERTY_RECORDDOGMOTIONSILENCETIME = 72,
    CAMERA_PROPERTY_EVENTVIDEOUPLOADCLOUDENABLE = 76,
    CAMERA_PROPERTY_GROUPOFPICTURES = 77,
    CAMERA_PROPERTY_FRAMESPERSECOND = 78,
    CAMERA_PROPERTY_PICTUREFLIPMODE = 79,
    CAMERA_PROPERTY_LIMITEDPOSITION = 80,
    CAMERA_PROPERTY_SLEEPMODEWORKINGPERIOD = 81,
    CAMERA_PROPERTY_BITRATE = 83,
    CAMERA_PROPERTY_SLEEP = 84,
    CAMERA_PROPERTY_ONETOUCHCALLENABLED = 88
};

enum CAMERA_ACTION {
    CAMERA_ACTION_PTZ_CALIBRATION = 45,
    CAMERA_ACTION_LINEAR_MOVEMENT = 46,
    CAMERA_ACTION_GET_RECORD_LIST = 47,
    CAMERA_ACTION_DEL_RECORD_INFO = 48,
    CAMERA_ACTION_GET_VIDEO_PERIOD = 49,
    CAMERA_ACTION_TAKE_PHOTO = 50,
    CAMERA_ACTION_GET_CURRENT_POSITION = 51,
    CAMERA_ACTION_GET_PICTURE_LIST = 52,
    CAMERA_ACTION_DEL_PICTURE_INFO = 53,
    CAMERA_ACTION_SOUND_ALARM = 54,
    CAMERA_ACTION_PLAY_VOICE_MEMO = 55,
    CAMERA_ACTION_MOVING_TO_FAV_POSITION = 73,
    CAMERA_ACTION_GET_RECORDING_TIME = 74,
    CAMERA_ACTION_GET_RECORD_EVENT_LIST = 75,
    CAMERA_ACTION_DEVICE_REBOOT = 82,
    CAMERA_ACTION_PANORAMA = 85
};

enum CAMERA_EVENT {
    CAMERA_EVENT_CRY_DETECTION_START = 56,
    CAMERA_EVENT_FACE_RECOGNITION_DETECTED = 57,
    CAMERA_EVENT_RECORD_NOTIFY = 59,
    CAMERA_EVENT_MOTION_DETECTION_START = 60,
    CAMERA_EVENT_MOTION_DETECTION_END = 61,
    CAMERA_EVENT_CRY_DETECTION_END = 62,
    CAMERA_EVENT_DIAL_RECORD_START = 86,
    CAMERA_EVENT_DIAL_RECORD_END = 87
};

struct camera_properties {
    bool power;
    enum camera_record_mode recordmode;
    enum camera_predefined_resolution resolution;
    enum camera_night_vision_sta nightvisionsta;
    bool recordmute;
    bool autodetectionenabled;
    bool fixedpositiondetectionenabled;
    enum camera_auto_cruise_detection autocruisedetection;
    bool facerecognitionenabled;
    bool multimediawithtimewatermark;
    bool pushmotiondetectionenabled;
    uint32_t pushmotiondetectionsilenttime;
    uint32_t camerasensitivity;
    size_t n_favouritecruisedposition;
    struct hey_array_node **favouritecruisedposition;
    size_t n_fixedpositionforrecord;
    struct hey_array_node **fixedpositionforrecord;
    bool crydetectionenabled;
    bool pushcrydetectionenabled;
    uint32_t pushcrydetectionsilenttime;
    bool appeasingbabyenabled;
    bool indicatorlightenabled;
    bool correctlendistortionenabled;
    bool wdrenabled;
    bool pushfacerecognitionenabled;
    uint32_t pushfacerecognitionsilenttime;
    size_t n_fixedpositionandtimerecord;
    struct hey_array_node **fixedpositionandtimerecord;
    size_t n_appeasingbabyworkingperiod;
    struct hey_array_node **appeasingbabyworkingperiod;
    size_t n_autodetectionworkingperiod;
    struct hey_array_node **autodetectionworkingperiod;
    bool motiontrackingenabled;
    uint32_t soundalarmtime;
    uint32_t soundalarmvolume;
    enum camera_ringing_sound ringingsound;
    uint32_t recordmotiondetectionsilencetime;
    uint32_t recordhumanmotionsilencetime;
    uint32_t recordanimalmotionsilencetime;
    uint32_t recordcrydetectionsilencetime;
    uint32_t recordfacerecognitionsilenttime;
    size_t n_appeasingbabymusic;
    struct hey_array_node **appeasingbabymusic;
    struct camera_appeasing_baby_music_play_mode *appeasingbabymusicplaymode;
    struct camera_appeasing_baby_music_play_setting *appeasingbabymusicplaysetting;
    uint32_t pushhumanmotionsilencetime;
    uint32_t pushanimalmotionsilencetime;
    bool pushhumanmotionenabled;
    bool pushanimalmotionenabled;
    size_t n_voicememo;
    struct hey_array_node **voicememo;
    size_t n_facesource;
    struct hey_array_node **facesource;
    bool pushpicturechangeenabled;
    uint32_t pushpicturechangesilencetime;
    uint32_t recordpicturechangesilencetime;
    size_t n_voicememoplaycondition;
    struct hey_array_node **voicememoplaycondition;
    bool pushcatmotionenabled;
    bool pushdogmotionenabled;
    uint32_t pushcatmotionsilenttime;
    uint32_t pushdogmotionsilenttime;
    uint32_t recordcatmotionsilencetime;
    uint32_t recorddogmotionsilencetime;
    bool eventvideouploadcloudenable;
    uint32_t groupofpictures;
    uint32_t framespersecond;
    enum camera_picture_flip_mode pictureflipmode;
    struct camera_limited_position *limitedposition;
    size_t n_sleepmodeworkingperiod;
    struct hey_array_node **sleepmodeworkingperiod;
    uint32_t bitrate;
    bool sleep;
    bool onetouchcallenabled;
};

/**
 * @brief camera service initialization
 * @param properties [camera service properties]
 * @return int32_t   [initialize result]
*/
int32_t camera_service_init(const struct camera_properties *properties);

/**
 * @brief data at "struct hey_array_node" pack and unpack
*/
struct camera_fixed_position_and_time_record *camera_fixed_position_and_time_record_unpack(const uint8_t *data, size_t len);
void camera_fixed_position_and_time_record_free_unpacked(struct camera_fixed_position_and_time_record *data);
// less than 0 means failure
int32_t camera_fixed_position_and_time_record_get_packed_size(const struct camera_fixed_position_and_time_record *data);
// less than 0 means failure
int32_t camera_fixed_position_and_time_record_pack(const struct camera_fixed_position_and_time_record *data, uint8_t *out);

struct camera_appeasing_baby_working_period *camera_appeasing_baby_working_period_unpack(const uint8_t *data, size_t len);
void camera_appeasing_baby_working_period_free_unpacked(struct camera_appeasing_baby_working_period *data);
// less than 0 means failure
int32_t camera_appeasing_baby_working_period_get_packed_size(const struct camera_appeasing_baby_working_period *data);
// less than 0 means failure
int32_t camera_appeasing_baby_working_period_pack(const struct camera_appeasing_baby_working_period *data, uint8_t *out);

struct camera_auto_detection_working_period *camera_auto_detection_working_period_unpack(const uint8_t *data, size_t len);
void camera_auto_detection_working_period_free_unpacked(struct camera_auto_detection_working_period *data);
// less than 0 means failure
int32_t camera_auto_detection_working_period_get_packed_size(const struct camera_auto_detection_working_period *data);
// less than 0 means failure
int32_t camera_auto_detection_working_period_pack(const struct camera_auto_detection_working_period *data, uint8_t *out);

struct camera_voice_memo_play_condition *camera_voice_memo_play_condition_unpack(const uint8_t *data, size_t len);
void camera_voice_memo_play_condition_free_unpacked(struct camera_voice_memo_play_condition *data);
// less than 0 means failure
int32_t camera_voice_memo_play_condition_get_packed_size(const struct camera_voice_memo_play_condition *data);
// less than 0 means failure
int32_t camera_voice_memo_play_condition_pack(const struct camera_voice_memo_play_condition *data, uint8_t *out);

struct camera_appeasing_baby_music *camera_appeasing_baby_music_unpack(const uint8_t *data, size_t len);
void camera_appeasing_baby_music_free_unpacked(struct camera_appeasing_baby_music *data);
// less than 0 means failure
int32_t camera_appeasing_baby_music_get_packed_size(const struct camera_appeasing_baby_music *data);
// less than 0 means failure
int32_t camera_appeasing_baby_music_pack(const struct camera_appeasing_baby_music *data, uint8_t *out);

struct camera_favourite_cruised_position *camera_favourite_cruised_position_unpack(const uint8_t *data, size_t len);
void camera_favourite_cruised_position_free_unpacked(struct camera_favourite_cruised_position *data);
// less than 0 means failure
int32_t camera_favourite_cruised_position_get_packed_size(const struct camera_favourite_cruised_position *data);
// less than 0 means failure
int32_t camera_favourite_cruised_position_pack(const struct camera_favourite_cruised_position *data, uint8_t *out);

struct camera_fixed_position_for_record *camera_fixed_position_for_record_unpack(const uint8_t *data, size_t len);
void camera_fixed_position_for_record_free_unpacked(struct camera_fixed_position_for_record *data);
// less than 0 means failure
int32_t camera_fixed_position_for_record_get_packed_size(const struct camera_fixed_position_for_record *data);
// less than 0 means failure
int32_t camera_fixed_position_for_record_pack(const struct camera_fixed_position_for_record *data, uint8_t *out);

struct camera_voice_memo *camera_voice_memo_unpack(const uint8_t *data, size_t len);
void camera_voice_memo_free_unpacked(struct camera_voice_memo *data);
// less than 0 means failure
int32_t camera_voice_memo_get_packed_size(const struct camera_voice_memo *data);
// less than 0 means failure
int32_t camera_voice_memo_pack(const struct camera_voice_memo *data, uint8_t *out);

struct camera_face_source *camera_face_source_unpack(const uint8_t *data, size_t len);
void camera_face_source_free_unpacked(struct camera_face_source *data);
// less than 0 means failure
int32_t camera_face_source_get_packed_size(const struct camera_face_source *data);
// less than 0 means failure
int32_t camera_face_source_pack(const struct camera_face_source *data, uint8_t *out);

struct camera_sleep_mode_working_period *camera_sleep_mode_working_period_unpack(const uint8_t *data, size_t len);
void camera_sleep_mode_working_period_free_unpacked(struct camera_sleep_mode_working_period *data);
// less than 0 means failure
int32_t camera_sleep_mode_working_period_get_packed_size(const struct camera_sleep_mode_working_period *data);
// less than 0 means failure
int32_t camera_sleep_mode_working_period_pack(const struct camera_sleep_mode_working_period *data, uint8_t *out);

/**
 * @brief properties write callback of camera service
 * @param count      [the number of properties will be written]
 * @param enumerate  [the iid enumeration of properties will be written]
 * @param properties [properties structure with written content]
 * @return int32_t   [be writed result, 0 means success]
*/
int32_t camera_properties_write_cb(size_t count, uint32_t *enumerate, struct camera_properties *properties);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_favouritecruisedposition_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_favouritecruisedposition_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_favouritecruisedposition_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_fixedpositionforrecord_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_fixedpositionforrecord_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_fixedpositionforrecord_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_fixedpositionandtimerecord_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_fixedpositionandtimerecord_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_fixedpositionandtimerecord_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_appeasingbabyworkingperiod_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_appeasingbabyworkingperiod_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_appeasingbabyworkingperiod_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_autodetectionworkingperiod_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_autodetectionworkingperiod_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_autodetectionworkingperiod_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_appeasingbabymusic_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_appeasingbabymusic_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_appeasingbabymusic_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_voicememo_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_voicememo_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_voicememo_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_facesource_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_facesource_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_facesource_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_voicememoplaycondition_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_voicememoplaycondition_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_voicememoplaycondition_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief arrayNode properties add callback of camera service
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [return array id, 0 or more than 0 means success]
*/
int32_t camera_sleepmodeworkingperiod_array_add_cb(size_t len, uint8_t *value);

/**
 * @brief arrayNode properties delete callback of camera service
 * @param n_id     [nums of id that will be removed]
 * @param ids      [list of ids that will be removed]
 * @return int32_t [0 means success]
*/
int32_t camera_sleepmodeworkingperiod_array_del_cb(size_t n_id, uint32_t *ids);

/**
 * @brief arrayNode properties replace callback of camera service
 * @param id       [array id that will be replaced]
 * @param len      [array data length]
 * @param value    [array data]
 * @return int32_t [0 means success]
*/
int32_t camera_sleepmodeworkingperiod_array_replace_cb(uint32_t id, size_t len, uint8_t *value);

/**
 * @brief update properties of camera service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t camera_properties_update(size_t count, uint32_t *enumerate, struct camera_properties *properties);

/**
 * @brief ptz calibration action start callback of camera service
 * @param ctx          [action context]
 * @param action       [ptz calibration action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_ptz_calibration_start_cb(struct hey_action_ctx *ctx, struct camera_ptz_calibration_in *action, void **user_context);

/**
 * @brief ptz calibration action send message of camera service
 * @param ctx      [action context]
 * @param action   [ptz calibration action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_ptz_calibration_send(struct hey_action_ctx *ctx, struct camera_ptz_calibration_out *action);

/**
 * @brief ptz calibration action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_ptz_calibration_stop(struct hey_action_ctx *ctx);

/**
 * @brief ptz calibration action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_ptz_calibration_stop_cb(void *user_context);

/**
 * @brief linear movement action start callback of camera service
 * @param ctx          [action context]
 * @param action       [linear movement action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_linear_movement_start_cb(struct hey_action_ctx *ctx, struct camera_linear_movement_in *action, void **user_context);

/**
 * @brief linear movement action send message of camera service
 * @param ctx      [action context]
 * @param action   [linear movement action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_linear_movement_send(struct hey_action_ctx *ctx, struct camera_linear_movement_out *action);

/**
 * @brief linear movement action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_linear_movement_stop(struct hey_action_ctx *ctx);

/**
 * @brief linear movement action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_linear_movement_stop_cb(void *user_context);

/**
 * @brief get record list action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get record list action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_record_list_start_cb(struct hey_action_ctx *ctx, struct camera_get_record_list_in *action, void **user_context);

/**
 * @brief get record list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get record list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_record_list_send(struct hey_action_ctx *ctx, struct camera_get_record_list_out *action);

/**
 * @brief get record list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_record_list_stop(struct hey_action_ctx *ctx);

/**
 * @brief get record list action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_record_list_stop_cb(void *user_context);

/**
 * @brief del record info action start callback of camera service
 * @param ctx          [action context]
 * @param action       [del record info action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_del_record_info_start_cb(struct hey_action_ctx *ctx, struct camera_del_record_info_in *action, void **user_context);

/**
 * @brief del record info action send message of camera service
 * @param ctx      [action context]
 * @param action   [del record info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_del_record_info_send(struct hey_action_ctx *ctx, struct camera_del_record_info_out *action);

/**
 * @brief del record info action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_del_record_info_stop(struct hey_action_ctx *ctx);

/**
 * @brief del record info action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_del_record_info_stop_cb(void *user_context);

/**
 * @brief get video period action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get video period action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_video_period_start_cb(struct hey_action_ctx *ctx, struct camera_get_video_period_in *action, void **user_context);

/**
 * @brief get video period action send message of camera service
 * @param ctx      [action context]
 * @param action   [get video period action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_video_period_send(struct hey_action_ctx *ctx, struct camera_get_video_period_out *action);

/**
 * @brief get video period action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_video_period_stop(struct hey_action_ctx *ctx);

/**
 * @brief get video period action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_video_period_stop_cb(void *user_context);

/**
 * @brief take photo action start callback of camera service
 * @param ctx          [action context]
 * @param action       [take photo action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_take_photo_start_cb(struct hey_action_ctx *ctx, struct camera_take_photo_in *action, void **user_context);

/**
 * @brief take photo action send message of camera service
 * @param ctx      [action context]
 * @param action   [take photo action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_take_photo_send(struct hey_action_ctx *ctx, struct camera_take_photo_out *action);

/**
 * @brief take photo action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_take_photo_stop(struct hey_action_ctx *ctx);

/**
 * @brief take photo action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_take_photo_stop_cb(void *user_context);

/**
 * @brief get current position action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get current position action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_current_position_start_cb(struct hey_action_ctx *ctx, struct camera_get_current_position_in *action, void **user_context);

/**
 * @brief get current position action send message of camera service
 * @param ctx      [action context]
 * @param action   [get current position action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_current_position_send(struct hey_action_ctx *ctx, struct camera_get_current_position_out *action);

/**
 * @brief get current position action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_current_position_stop(struct hey_action_ctx *ctx);

/**
 * @brief get current position action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_current_position_stop_cb(void *user_context);

/**
 * @brief get picture list action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get picture list action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_picture_list_start_cb(struct hey_action_ctx *ctx, struct camera_get_picture_list_in *action, void **user_context);

/**
 * @brief get picture list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get picture list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_picture_list_send(struct hey_action_ctx *ctx, struct camera_get_picture_list_out *action);

/**
 * @brief get picture list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_picture_list_stop(struct hey_action_ctx *ctx);

/**
 * @brief get picture list action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_picture_list_stop_cb(void *user_context);

/**
 * @brief del picture info action start callback of camera service
 * @param ctx          [action context]
 * @param action       [del picture info action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_del_picture_info_start_cb(struct hey_action_ctx *ctx, struct camera_del_picture_info_in *action, void **user_context);

/**
 * @brief del picture info action send message of camera service
 * @param ctx      [action context]
 * @param action   [del picture info action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_del_picture_info_send(struct hey_action_ctx *ctx, struct camera_del_picture_info_out *action);

/**
 * @brief del picture info action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_del_picture_info_stop(struct hey_action_ctx *ctx);

/**
 * @brief del picture info action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_del_picture_info_stop_cb(void *user_context);

/**
 * @brief sound alarm action start callback of camera service
 * @param ctx          [action context]
 * @param action       [sound alarm action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_sound_alarm_start_cb(struct hey_action_ctx *ctx, struct camera_sound_alarm_in *action, void **user_context);

/**
 * @brief sound alarm action send message of camera service
 * @param ctx      [action context]
 * @param action   [sound alarm action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_sound_alarm_send(struct hey_action_ctx *ctx, struct camera_sound_alarm_out *action);

/**
 * @brief sound alarm action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_sound_alarm_stop(struct hey_action_ctx *ctx);

/**
 * @brief sound alarm action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_sound_alarm_stop_cb(void *user_context);

/**
 * @brief play voice memo action start callback of camera service
 * @param ctx          [action context]
 * @param action       [play voice memo action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_play_voice_memo_start_cb(struct hey_action_ctx *ctx, struct camera_play_voice_memo_in *action, void **user_context);

/**
 * @brief play voice memo action send message of camera service
 * @param ctx      [action context]
 * @param action   [play voice memo action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_play_voice_memo_send(struct hey_action_ctx *ctx, struct camera_play_voice_memo_out *action);

/**
 * @brief play voice memo action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_play_voice_memo_stop(struct hey_action_ctx *ctx);

/**
 * @brief play voice memo action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_play_voice_memo_stop_cb(void *user_context);

/**
 * @brief moving to fav position action start callback of camera service
 * @param ctx          [action context]
 * @param action       [moving to fav position action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_moving_to_fav_position_start_cb(struct hey_action_ctx *ctx, struct camera_moving_to_fav_position_in *action, void **user_context);

/**
 * @brief moving to fav position action send message of camera service
 * @param ctx      [action context]
 * @param action   [moving to fav position action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_moving_to_fav_position_send(struct hey_action_ctx *ctx, struct camera_moving_to_fav_position_out *action);

/**
 * @brief moving to fav position action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_moving_to_fav_position_stop(struct hey_action_ctx *ctx);

/**
 * @brief moving to fav position action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_moving_to_fav_position_stop_cb(void *user_context);

/**
 * @brief get recording time action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get recording time action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_recording_time_start_cb(struct hey_action_ctx *ctx, struct camera_get_recording_time_in *action, void **user_context);

/**
 * @brief get recording time action send message of camera service
 * @param ctx      [action context]
 * @param action   [get recording time action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_recording_time_send(struct hey_action_ctx *ctx, struct camera_get_recording_time_out *action);

/**
 * @brief get recording time action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_recording_time_stop(struct hey_action_ctx *ctx);

/**
 * @brief get recording time action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_recording_time_stop_cb(void *user_context);

/**
 * @brief get record event list action start callback of camera service
 * @param ctx          [action context]
 * @param action       [get record event list action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_get_record_event_list_start_cb(struct hey_action_ctx *ctx, struct camera_get_record_event_list_in *action, void **user_context);

/**
 * @brief get record event list action send message of camera service
 * @param ctx      [action context]
 * @param action   [get record event list action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_get_record_event_list_send(struct hey_action_ctx *ctx, struct camera_get_record_event_list_out *action);

/**
 * @brief get record event list action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_get_record_event_list_stop(struct hey_action_ctx *ctx);

/**
 * @brief get record event list action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_get_record_event_list_stop_cb(void *user_context);

/**
 * @brief device reboot action start callback of camera service
 * @param ctx          [action context]
 * @param action       [device reboot action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_device_reboot_start_cb(struct hey_action_ctx *ctx, struct camera_device_reboot_in *action, void **user_context);

/**
 * @brief device reboot action send message of camera service
 * @param ctx      [action context]
 * @param action   [device reboot action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_device_reboot_send(struct hey_action_ctx *ctx, struct camera_device_reboot_out *action);

/**
 * @brief device reboot action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_device_reboot_stop(struct hey_action_ctx *ctx);

/**
 * @brief device reboot action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_device_reboot_stop_cb(void *user_context);

/**
 * @brief panorama action start callback of camera service
 * @param ctx          [action context]
 * @param action       [panorama action in]
 * @param user_context [user context record in SDK as needed, otherwise set it NULL]
 * @return int32_t     [action start handle result, 0 means success]
 */
int32_t camera_panorama_start_cb(struct hey_action_ctx *ctx, struct camera_panorama_in *action, void **user_context);

/**
 * @brief panorama action send message of camera service
 * @param ctx      [action context]
 * @param action   [panorama action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t camera_panorama_send(struct hey_action_ctx *ctx, struct camera_panorama_out *action);

/**
 * @brief panorama action stop of camera service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t camera_panorama_stop(struct hey_action_ctx *ctx);

/**
 * @brief panorama action stop callback of camera service
 *        closed by the peer, user must to call action stop function
 * @param user_context [callback data which form action start callback function]
 * @return none
 */
void camera_panorama_stop_cb(void *user_context);

/**
 * @brief cry detection start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_cry_detection_start_notify(struct camera_event_cry_detection_start *event, struct hey_event_notify_attr *attr);

/**
 * @brief cry detection start notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_cry_detection_start_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief face recognition detected notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_face_recognition_detected_notify(struct camera_event_face_recognition_detected *event, struct hey_event_notify_attr *attr);

/**
 * @brief face recognition detected notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_face_recognition_detected_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief record notify notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_record_notify_notify(struct camera_event_record_notify *event, struct hey_event_notify_attr *attr);

/**
 * @brief record notify notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_record_notify_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief motion detection start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_motion_detection_start_notify(struct camera_event_motion_detection_start *event, struct hey_event_notify_attr *attr);

/**
 * @brief motion detection start notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_motion_detection_start_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief motion detection end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_motion_detection_end_notify(struct camera_event_motion_detection_end *event, struct hey_event_notify_attr *attr);

/**
 * @brief motion detection end notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_motion_detection_end_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief cry detection end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_cry_detection_end_notify(struct camera_event_cry_detection_end *event, struct hey_event_notify_attr *attr);

/**
 * @brief cry detection end notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_cry_detection_end_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief dial record start notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_dial_record_start_notify(struct camera_event_dial_record_start *event, struct hey_event_notify_attr *attr);

/**
 * @brief dial record start notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_dial_record_start_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

/**
 * @brief dial record end notify of camera service
 * @param event    [event content]
 * @param attr     [event details]
 * @return int64_t [event uuid, get error code from errno when return negative value]
*/
int64_t camera_dial_record_end_notify(struct camera_event_dial_record_end *event, struct hey_event_notify_attr *attr);

/**
 * @brief dial record end notify result callback of camera service
 * @param ctx    [registered callback context by user]
 * @param result [the result of notify, 0 means success]
 * @return none
*/
void camera_dial_record_end_notify_result_cb(struct hey_job_ctx *ctx, int32_t result);

#endif /* CAMERA_SERVICE_H */
