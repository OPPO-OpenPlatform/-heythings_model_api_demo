/* Generated by the heythings model compiler.  DO NOT EDIT! */
/* Generated from: router.proto */

#include <errno.h>
#include <assert.h>
#include "router.pb-c.h"
#include "router_service.h"
#include "hey/schema.h"

#define ROUTER_SERVICE (76 * 256)
#define PROP_IID_CNT 81
#define ACT_IID_CNT 4

static const struct hey_schema_property router_properties_iids[] = {
    [0] = { .iid = 1, .type = HEY_PROPERTY_TYPE_GENERIC },
    [1] = { .iid = 2, .type = HEY_PROPERTY_TYPE_GENERIC },
    [2] = { .iid = 3, .type = HEY_PROPERTY_TYPE_GENERIC },
    [3] = { .iid = 4, .type = HEY_PROPERTY_TYPE_GENERIC },
    [4] = { .iid = 5, .type = HEY_PROPERTY_TYPE_GENERIC },
    [5] = { .iid = 6, .type = HEY_PROPERTY_TYPE_GENERIC },
    [6] = { .iid = 7, .type = HEY_PROPERTY_TYPE_GENERIC },
    [7] = { .iid = 8, .type = HEY_PROPERTY_TYPE_GENERIC },
    [8] = { .iid = 9, .type = HEY_PROPERTY_TYPE_GENERIC },
    [9] = { .iid = 10, .type = HEY_PROPERTY_TYPE_GENERIC },
    [10] = { .iid = 11, .type = HEY_PROPERTY_TYPE_GENERIC },
    [11] = { .iid = 12, .type = HEY_PROPERTY_TYPE_GENERIC },
    [12] = { .iid = 13, .type = HEY_PROPERTY_TYPE_GENERIC },
    [13] = { .iid = 14, .type = HEY_PROPERTY_TYPE_GENERIC },
    [14] = { .iid = 15, .type = HEY_PROPERTY_TYPE_GENERIC },
    [15] = { .iid = 16, .type = HEY_PROPERTY_TYPE_GENERIC },
    [16] = { .iid = 17, .type = HEY_PROPERTY_TYPE_GENERIC },
    [17] = { .iid = 18, .type = HEY_PROPERTY_TYPE_GENERIC },
    [18] = { .iid = 19, .type = HEY_PROPERTY_TYPE_GENERIC },
    [19] = { .iid = 20, .type = HEY_PROPERTY_TYPE_GENERIC },
    [20] = { .iid = 21, .type = HEY_PROPERTY_TYPE_GENERIC },
    [21] = { .iid = 22, .type = HEY_PROPERTY_TYPE_GENERIC },
    [22] = { .iid = 23, .type = HEY_PROPERTY_TYPE_GENERIC },
    [23] = { .iid = 24, .type = HEY_PROPERTY_TYPE_GENERIC },
    [24] = { .iid = 25, .type = HEY_PROPERTY_TYPE_GENERIC },
    [25] = { .iid = 26, .type = HEY_PROPERTY_TYPE_GENERIC },
    [26] = { .iid = 27, .type = HEY_PROPERTY_TYPE_GENERIC },
    [27] = { .iid = 28, .type = HEY_PROPERTY_TYPE_GENERIC },
    [28] = { .iid = 29, .type = HEY_PROPERTY_TYPE_GENERIC },
    [29] = { .iid = 30, .type = HEY_PROPERTY_TYPE_GENERIC },
    [30] = { .iid = 31, .type = HEY_PROPERTY_TYPE_GENERIC },
    [31] = { .iid = 32, .type = HEY_PROPERTY_TYPE_ARRAY },
    [32] = { .iid = 33, .type = HEY_PROPERTY_TYPE_ARRAY },
    [33] = { .iid = 34, .type = HEY_PROPERTY_TYPE_GENERIC },
    [34] = { .iid = 35, .type = HEY_PROPERTY_TYPE_GENERIC },
    [35] = { .iid = 36, .type = HEY_PROPERTY_TYPE_GENERIC },
    [36] = { .iid = 37, .type = HEY_PROPERTY_TYPE_GENERIC },
    [37] = { .iid = 38, .type = HEY_PROPERTY_TYPE_GENERIC },
    [38] = { .iid = 39, .type = HEY_PROPERTY_TYPE_GENERIC },
    [39] = { .iid = 40, .type = HEY_PROPERTY_TYPE_GENERIC },
    [40] = { .iid = 41, .type = HEY_PROPERTY_TYPE_GENERIC },
    [41] = { .iid = 42, .type = HEY_PROPERTY_TYPE_GENERIC },
    [42] = { .iid = 43, .type = HEY_PROPERTY_TYPE_GENERIC },
    [43] = { .iid = 44, .type = HEY_PROPERTY_TYPE_GENERIC },
    [44] = { .iid = 45, .type = HEY_PROPERTY_TYPE_GENERIC },
    [45] = { .iid = 46, .type = HEY_PROPERTY_TYPE_GENERIC },
    [46] = { .iid = 47, .type = HEY_PROPERTY_TYPE_GENERIC },
    [47] = { .iid = 48, .type = HEY_PROPERTY_TYPE_GENERIC },
    [48] = { .iid = 49, .type = HEY_PROPERTY_TYPE_GENERIC },
    [49] = { .iid = 50, .type = HEY_PROPERTY_TYPE_GENERIC },
    [50] = { .iid = 51, .type = HEY_PROPERTY_TYPE_GENERIC },
    [51] = { .iid = 52, .type = HEY_PROPERTY_TYPE_GENERIC },
    [52] = { .iid = 53, .type = HEY_PROPERTY_TYPE_GENERIC },
    [53] = { .iid = 54, .type = HEY_PROPERTY_TYPE_GENERIC },
    [54] = { .iid = 55, .type = HEY_PROPERTY_TYPE_GENERIC },
    [55] = { .iid = 56, .type = HEY_PROPERTY_TYPE_GENERIC },
    [56] = { .iid = 57, .type = HEY_PROPERTY_TYPE_GENERIC },
    [57] = { .iid = 58, .type = HEY_PROPERTY_TYPE_GENERIC },
    [58] = { .iid = 59, .type = HEY_PROPERTY_TYPE_ARRAY },
    [59] = { .iid = 60, .type = HEY_PROPERTY_TYPE_GENERIC },
    [60] = { .iid = 61, .type = HEY_PROPERTY_TYPE_ARRAY },
    [61] = { .iid = 62, .type = HEY_PROPERTY_TYPE_GENERIC },
    [62] = { .iid = 66, .type = HEY_PROPERTY_TYPE_GENERIC },
    [63] = { .iid = 67, .type = HEY_PROPERTY_TYPE_GENERIC },
    [64] = { .iid = 68, .type = HEY_PROPERTY_TYPE_GENERIC },
    [65] = { .iid = 69, .type = HEY_PROPERTY_TYPE_ARRAY },
    [66] = { .iid = 70, .type = HEY_PROPERTY_TYPE_GENERIC },
    [67] = { .iid = 71, .type = HEY_PROPERTY_TYPE_GENERIC },
    [68] = { .iid = 72, .type = HEY_PROPERTY_TYPE_ARRAY },
    [69] = { .iid = 73, .type = HEY_PROPERTY_TYPE_GENERIC },
    [70] = { .iid = 74, .type = HEY_PROPERTY_TYPE_ARRAY },
    [71] = { .iid = 75, .type = HEY_PROPERTY_TYPE_GENERIC },
    [72] = { .iid = 76, .type = HEY_PROPERTY_TYPE_GENERIC },
    [73] = { .iid = 77, .type = HEY_PROPERTY_TYPE_ARRAY },
    [74] = { .iid = 78, .type = HEY_PROPERTY_TYPE_GENERIC },
    [75] = { .iid = 79, .type = HEY_PROPERTY_TYPE_GENERIC },
    [76] = { .iid = 80, .type = HEY_PROPERTY_TYPE_GENERIC },
    [77] = { .iid = 81, .type = HEY_PROPERTY_TYPE_GENERIC },
    [78] = { .iid = 82, .type = HEY_PROPERTY_TYPE_GENERIC },
    [79] = { .iid = 83, .type = HEY_PROPERTY_TYPE_GENERIC },
    [80] = { .iid = 84, .type = HEY_PROPERTY_TYPE_GENERIC },
};
static struct hey_service *router_service;

static int32_t action_modify_web_password_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Router__ActionInModifyWebPassword *modify_web_password = iot__service__router__action_in_modify_web_password__unpack(NULL, len, value);
    if (NULL == modify_web_password) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct router_modify_web_password_in action = { 0 };
    action.oldpassword = modify_web_password->oldpassword;
    action.newpassword = modify_web_password->newpassword;
    ret = router_modify_web_password_start_cb(ctx, &action, user_context);

    iot__service__router__action_in_modify_web_password__free_unpacked(modify_web_password, NULL);
    return ret;
}

static void action_modify_web_password_stop_cb(void *cb_data, void *user_context)
{
    router_modify_web_password_stop_cb(user_context);
}

/**
 * @brief modify web password action send message of router service
 * @param ctx      [action context]
 * @param action   [modify web password action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t router_modify_web_password_send(struct hey_action_ctx *ctx, struct router_modify_web_password_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief modify web password action stop of router service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t router_modify_web_password_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_device_reboot_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Router__ActionInDeviceReboot *device_reboot = iot__service__router__action_in_device_reboot__unpack(NULL, len, value);
    if (NULL == device_reboot) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct router_device_reboot_in action = { 0 };
    ret = router_device_reboot_start_cb(ctx, &action, user_context);

    iot__service__router__action_in_device_reboot__free_unpacked(device_reboot, NULL);
    return ret;
}

static void action_device_reboot_stop_cb(void *cb_data, void *user_context)
{
    router_device_reboot_stop_cb(user_context);
}

/**
 * @brief device reboot action send message of router service
 * @param ctx      [action context]
 * @param action   [device reboot action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t router_device_reboot_send(struct hey_action_ctx *ctx, struct router_device_reboot_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief device reboot action stop of router service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t router_device_reboot_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_device_restore_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Router__ActionInDeviceRestore *device_restore = iot__service__router__action_in_device_restore__unpack(NULL, len, value);
    if (NULL == device_restore) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct router_device_restore_in action = { 0 };
    ret = router_device_restore_start_cb(ctx, &action, user_context);

    iot__service__router__action_in_device_restore__free_unpacked(device_restore, NULL);
    return ret;
}

static void action_device_restore_stop_cb(void *cb_data, void *user_context)
{
    router_device_restore_stop_cb(user_context);
}

/**
 * @brief device restore action send message of router service
 * @param ctx      [action context]
 * @param action   [device restore action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t router_device_restore_send(struct hey_action_ctx *ctx, struct router_device_restore_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief device restore action stop of router service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t router_device_restore_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static int32_t action_wifi_channel_optimization_start_cb(void *cb_data, struct hey_action_ctx *ctx, size_t len, uint8_t *value, void **user_context)
{
    int32_t ret = -1;
    Iot__Service__Router__ActionInWifiChannelOptimization *wifi_channel_optimization = iot__service__router__action_in_wifi_channel_optimization__unpack(NULL, len, value);
    if (NULL == wifi_channel_optimization) {
        hey_action_stop(ctx);
        return EINVAL;
    }

    struct router_wifi_channel_optimization_in action = { 0 };
    ret = router_wifi_channel_optimization_start_cb(ctx, &action, user_context);

    iot__service__router__action_in_wifi_channel_optimization__free_unpacked(wifi_channel_optimization, NULL);
    return ret;
}

static void action_wifi_channel_optimization_stop_cb(void *cb_data, void *user_context)
{
    router_wifi_channel_optimization_stop_cb(user_context);
}

/**
 * @brief wifi channel optimization action send message of router service
 * @param ctx      [action context]
 * @param action   [wifi channel optimization action out]
 * @return int32_t [action send result, 0 means success]
 */
int32_t router_wifi_channel_optimization_send(struct hey_action_ctx *ctx, struct router_wifi_channel_optimization_out *action)
{
    return hey_action_msg_send(ctx, 0, NULL);
}

/**
 * @brief wifi channel optimization action stop of router service
 * @param ctx      [action context]
 * @return int32_t [action stop result, 0 means success]
 */
int32_t router_wifi_channel_optimization_stop(struct hey_action_ctx *ctx)
{
    return hey_action_stop(ctx);
}

static Iot__Service__Router__ReserveIP *_router_reserve_ip = NULL;
struct router_reserve_ip *router_reserve_ip_unpack(const uint8_t *data, size_t len)
{
    _router_reserve_ip = iot__service__router__reserve_ip__unpack(NULL, len, data);
    if (NULL == _router_reserve_ip) {
        return NULL;
    }
    struct router_reserve_ip *hey_struct = malloc(sizeof(struct router_reserve_ip));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->devicename = _router_reserve_ip->devicename;
    hey_struct->mac = _router_reserve_ip->mac;
    hey_struct->ip = _router_reserve_ip->ip;
    return hey_struct;
out1:
    iot__service__router__reserve_ip__free_unpacked(_router_reserve_ip, NULL);
    return NULL;
}

void router_reserve_ip_free_unpacked(struct router_reserve_ip *data)
{
    assert(NULL != data);
    iot__service__router__reserve_ip__free_unpacked(_router_reserve_ip, NULL);
    free(data);
}

int32_t router_reserve_ip_get_packed_size(const struct router_reserve_ip *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__ReserveIP *pb_struct = malloc(sizeof(Iot__Service__Router__ReserveIP));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__reserve_ip__init(pb_struct);
    pb_struct->devicename = data->devicename;
    pb_struct->mac = data->mac;
    pb_struct->ip = data->ip;
    ret = iot__service__router__reserve_ip__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_reserve_ip_pack(const struct router_reserve_ip *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__ReserveIP *pb_struct = malloc(sizeof(Iot__Service__Router__ReserveIP));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__reserve_ip__init(pb_struct);
    pb_struct->devicename = data->devicename;
    pb_struct->mac = data->mac;
    pb_struct->ip = data->ip;
    ret = iot__service__router__reserve_ip__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__StaticRoute *_router_static_route = NULL;
struct router_static_route *router_static_route_unpack(const uint8_t *data, size_t len)
{
    _router_static_route = iot__service__router__static_route__unpack(NULL, len, data);
    if (NULL == _router_static_route) {
        return NULL;
    }
    struct router_static_route *hey_struct = malloc(sizeof(struct router_static_route));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->destip = _router_static_route->destip;
    hey_struct->subnetmask = _router_static_route->subnetmask;
    hey_struct->defaultgateway = _router_static_route->defaultgateway;
    return hey_struct;
out1:
    iot__service__router__static_route__free_unpacked(_router_static_route, NULL);
    return NULL;
}

void router_static_route_free_unpacked(struct router_static_route *data)
{
    assert(NULL != data);
    iot__service__router__static_route__free_unpacked(_router_static_route, NULL);
    free(data);
}

int32_t router_static_route_get_packed_size(const struct router_static_route *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__StaticRoute *pb_struct = malloc(sizeof(Iot__Service__Router__StaticRoute));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__static_route__init(pb_struct);
    pb_struct->destip = data->destip;
    pb_struct->subnetmask = data->subnetmask;
    pb_struct->defaultgateway = data->defaultgateway;
    ret = iot__service__router__static_route__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_static_route_pack(const struct router_static_route *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__StaticRoute *pb_struct = malloc(sizeof(Iot__Service__Router__StaticRoute));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__static_route__init(pb_struct);
    pb_struct->destip = data->destip;
    pb_struct->subnetmask = data->subnetmask;
    pb_struct->defaultgateway = data->defaultgateway;
    ret = iot__service__router__static_route__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__WlanFilter *_router_wlan_filter = NULL;
struct router_wlan_filter *router_wlan_filter_unpack(const uint8_t *data, size_t len)
{
    _router_wlan_filter = iot__service__router__wlan_filter__unpack(NULL, len, data);
    if (NULL == _router_wlan_filter) {
        return NULL;
    }
    struct router_wlan_filter *hey_struct = malloc(sizeof(struct router_wlan_filter));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->devicename = _router_wlan_filter->devicename;
    hey_struct->mac = _router_wlan_filter->mac;
    return hey_struct;
out1:
    iot__service__router__wlan_filter__free_unpacked(_router_wlan_filter, NULL);
    return NULL;
}

void router_wlan_filter_free_unpacked(struct router_wlan_filter *data)
{
    assert(NULL != data);
    iot__service__router__wlan_filter__free_unpacked(_router_wlan_filter, NULL);
    free(data);
}

int32_t router_wlan_filter_get_packed_size(const struct router_wlan_filter *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__WlanFilter *pb_struct = malloc(sizeof(Iot__Service__Router__WlanFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__wlan_filter__init(pb_struct);
    pb_struct->devicename = data->devicename;
    pb_struct->mac = data->mac;
    ret = iot__service__router__wlan_filter__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_wlan_filter_pack(const struct router_wlan_filter *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__WlanFilter *pb_struct = malloc(sizeof(Iot__Service__Router__WlanFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__wlan_filter__init(pb_struct);
    pb_struct->devicename = data->devicename;
    pb_struct->mac = data->mac;
    ret = iot__service__router__wlan_filter__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__Client *_router_client = NULL;
struct router_client *router_client_unpack(const uint8_t *data, size_t len)
{
    _router_client = iot__service__router__client__unpack(NULL, len, data);
    if (NULL == _router_client) {
        return NULL;
    }
    struct router_client *hey_struct = malloc(sizeof(struct router_client));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->isonline = _router_client->isonline;
    hey_struct->connecttype = _router_client->connecttype;
    hey_struct->clientname = _router_client->clientname;
    hey_struct->mac = _router_client->mac;
    hey_struct->ipv4 = _router_client->ipv4;
    hey_struct->ipv6 = _router_client->ipv6;
    hey_struct->dhcpremainday = _router_client->dhcpremainday;
    hey_struct->dhcpremainhour = _router_client->dhcpremainhour;
    hey_struct->dhcpremainminute = _router_client->dhcpremainminute;
    hey_struct->allowinternet = _router_client->allowinternet;
    return hey_struct;
out1:
    iot__service__router__client__free_unpacked(_router_client, NULL);
    return NULL;
}

void router_client_free_unpacked(struct router_client *data)
{
    assert(NULL != data);
    iot__service__router__client__free_unpacked(_router_client, NULL);
    free(data);
}

int32_t router_client_get_packed_size(const struct router_client *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__Client *pb_struct = malloc(sizeof(Iot__Service__Router__Client));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__client__init(pb_struct);
    pb_struct->isonline = data->isonline;
    pb_struct->connecttype = data->connecttype;
    pb_struct->clientname = data->clientname;
    pb_struct->mac = data->mac;
    pb_struct->ipv4 = data->ipv4;
    pb_struct->ipv6 = data->ipv6;
    pb_struct->dhcpremainday = data->dhcpremainday;
    pb_struct->dhcpremainhour = data->dhcpremainhour;
    pb_struct->dhcpremainminute = data->dhcpremainminute;
    pb_struct->allowinternet = data->allowinternet;
    ret = iot__service__router__client__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_client_pack(const struct router_client *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__Client *pb_struct = malloc(sizeof(Iot__Service__Router__Client));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__client__init(pb_struct);
    pb_struct->isonline = data->isonline;
    pb_struct->connecttype = data->connecttype;
    pb_struct->clientname = data->clientname;
    pb_struct->mac = data->mac;
    pb_struct->ipv4 = data->ipv4;
    pb_struct->ipv6 = data->ipv6;
    pb_struct->dhcpremainday = data->dhcpremainday;
    pb_struct->dhcpremainhour = data->dhcpremainhour;
    pb_struct->dhcpremainminute = data->dhcpremainminute;
    pb_struct->allowinternet = data->allowinternet;
    ret = iot__service__router__client__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__MacFilter *_router_mac_filter = NULL;
struct router_mac_filter *router_mac_filter_unpack(const uint8_t *data, size_t len)
{
    _router_mac_filter = iot__service__router__mac_filter__unpack(NULL, len, data);
    if (NULL == _router_mac_filter) {
        return NULL;
    }
    struct router_mac_filter *hey_struct = malloc(sizeof(struct router_mac_filter));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->clientname = _router_mac_filter->clientname;
    hey_struct->mac = _router_mac_filter->mac;
    return hey_struct;
out1:
    iot__service__router__mac_filter__free_unpacked(_router_mac_filter, NULL);
    return NULL;
}

void router_mac_filter_free_unpacked(struct router_mac_filter *data)
{
    assert(NULL != data);
    iot__service__router__mac_filter__free_unpacked(_router_mac_filter, NULL);
    free(data);
}

int32_t router_mac_filter_get_packed_size(const struct router_mac_filter *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__MacFilter *pb_struct = malloc(sizeof(Iot__Service__Router__MacFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__mac_filter__init(pb_struct);
    pb_struct->clientname = data->clientname;
    pb_struct->mac = data->mac;
    ret = iot__service__router__mac_filter__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_mac_filter_pack(const struct router_mac_filter *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__MacFilter *pb_struct = malloc(sizeof(Iot__Service__Router__MacFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__mac_filter__init(pb_struct);
    pb_struct->clientname = data->clientname;
    pb_struct->mac = data->mac;
    ret = iot__service__router__mac_filter__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__IpFilter *_router_ip_filter = NULL;
struct router_ip_filter *router_ip_filter_unpack(const uint8_t *data, size_t len)
{
    _router_ip_filter = iot__service__router__ip_filter__unpack(NULL, len, data);
    if (NULL == _router_ip_filter) {
        return NULL;
    }
    struct router_ip_filter *hey_struct = malloc(sizeof(struct router_ip_filter));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->wanip = _router_ip_filter->wanip;
    hey_struct->protocal = _router_ip_filter->protocal;
    hey_struct->wanstartport = _router_ip_filter->wanstartport;
    hey_struct->wanendport = _router_ip_filter->wanendport;
    hey_struct->clientname = _router_ip_filter->clientname;
    hey_struct->lanip = _router_ip_filter->lanip;
    hey_struct->lanstartport = _router_ip_filter->lanstartport;
    hey_struct->lanendport = _router_ip_filter->lanendport;
    return hey_struct;
out1:
    iot__service__router__ip_filter__free_unpacked(_router_ip_filter, NULL);
    return NULL;
}

void router_ip_filter_free_unpacked(struct router_ip_filter *data)
{
    assert(NULL != data);
    iot__service__router__ip_filter__free_unpacked(_router_ip_filter, NULL);
    free(data);
}

int32_t router_ip_filter_get_packed_size(const struct router_ip_filter *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__IpFilter *pb_struct = malloc(sizeof(Iot__Service__Router__IpFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__ip_filter__init(pb_struct);
    pb_struct->wanip = data->wanip;
    pb_struct->protocal = data->protocal;
    pb_struct->wanstartport = data->wanstartport;
    pb_struct->wanendport = data->wanendport;
    pb_struct->clientname = data->clientname;
    pb_struct->lanip = data->lanip;
    pb_struct->lanstartport = data->lanstartport;
    pb_struct->lanendport = data->lanendport;
    ret = iot__service__router__ip_filter__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_ip_filter_pack(const struct router_ip_filter *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__IpFilter *pb_struct = malloc(sizeof(Iot__Service__Router__IpFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__ip_filter__init(pb_struct);
    pb_struct->wanip = data->wanip;
    pb_struct->protocal = data->protocal;
    pb_struct->wanstartport = data->wanstartport;
    pb_struct->wanendport = data->wanendport;
    pb_struct->clientname = data->clientname;
    pb_struct->lanip = data->lanip;
    pb_struct->lanstartport = data->lanstartport;
    pb_struct->lanendport = data->lanendport;
    ret = iot__service__router__ip_filter__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__DomainFilter *_router_domain_filter = NULL;
struct router_domain_filter *router_domain_filter_unpack(const uint8_t *data, size_t len)
{
    _router_domain_filter = iot__service__router__domain_filter__unpack(NULL, len, data);
    if (NULL == _router_domain_filter) {
        return NULL;
    }
    struct router_domain_filter *hey_struct = malloc(sizeof(struct router_domain_filter));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->domain = _router_domain_filter->domain;
    return hey_struct;
out1:
    iot__service__router__domain_filter__free_unpacked(_router_domain_filter, NULL);
    return NULL;
}

void router_domain_filter_free_unpacked(struct router_domain_filter *data)
{
    assert(NULL != data);
    iot__service__router__domain_filter__free_unpacked(_router_domain_filter, NULL);
    free(data);
}

int32_t router_domain_filter_get_packed_size(const struct router_domain_filter *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__DomainFilter *pb_struct = malloc(sizeof(Iot__Service__Router__DomainFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__domain_filter__init(pb_struct);
    pb_struct->domain = data->domain;
    ret = iot__service__router__domain_filter__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_domain_filter_pack(const struct router_domain_filter *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__DomainFilter *pb_struct = malloc(sizeof(Iot__Service__Router__DomainFilter));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__domain_filter__init(pb_struct);
    pb_struct->domain = data->domain;
    ret = iot__service__router__domain_filter__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static Iot__Service__Router__VirtualServer *_router_virtual_server = NULL;
struct router_virtual_server *router_virtual_server_unpack(const uint8_t *data, size_t len)
{
    _router_virtual_server = iot__service__router__virtual_server__unpack(NULL, len, data);
    if (NULL == _router_virtual_server) {
        return NULL;
    }
    struct router_virtual_server *hey_struct = malloc(sizeof(struct router_virtual_server));
    if (NULL == hey_struct) {
        goto out1;
    }
    hey_struct->name = _router_virtual_server->name;
    hey_struct->protocal = _router_virtual_server->protocal;
    hey_struct->wanstartport = _router_virtual_server->wanstartport;
    hey_struct->wanendport = _router_virtual_server->wanendport;
    hey_struct->lanip = _router_virtual_server->lanip;
    hey_struct->lanstartport = _router_virtual_server->lanstartport;
    hey_struct->lanendport = _router_virtual_server->lanendport;
    return hey_struct;
out1:
    iot__service__router__virtual_server__free_unpacked(_router_virtual_server, NULL);
    return NULL;
}

void router_virtual_server_free_unpacked(struct router_virtual_server *data)
{
    assert(NULL != data);
    iot__service__router__virtual_server__free_unpacked(_router_virtual_server, NULL);
    free(data);
}

int32_t router_virtual_server_get_packed_size(const struct router_virtual_server *data)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__VirtualServer *pb_struct = malloc(sizeof(Iot__Service__Router__VirtualServer));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__virtual_server__init(pb_struct);
    pb_struct->name = data->name;
    pb_struct->protocal = data->protocal;
    pb_struct->wanstartport = data->wanstartport;
    pb_struct->wanendport = data->wanendport;
    pb_struct->lanip = data->lanip;
    pb_struct->lanstartport = data->lanstartport;
    pb_struct->lanendport = data->lanendport;
    ret = iot__service__router__virtual_server__get_packed_size(pb_struct);
    free(pb_struct);
    return ret;
}

int32_t router_virtual_server_pack(const struct router_virtual_server *data, uint8_t *out)
{
    assert(data);
    int ret = 0;
    Iot__Service__Router__VirtualServer *pb_struct = malloc(sizeof(Iot__Service__Router__VirtualServer));
    if (pb_struct == NULL) {
        return -1;
    }
    iot__service__router__virtual_server__init(pb_struct);
    pb_struct->name = data->name;
    pb_struct->protocal = data->protocal;
    pb_struct->wanstartport = data->wanstartport;
    pb_struct->wanendport = data->wanendport;
    pb_struct->lanip = data->lanip;
    pb_struct->lanstartport = data->lanstartport;
    pb_struct->lanendport = data->lanendport;
    ret = iot__service__router__virtual_server__pack(pb_struct, out);
    free(pb_struct);
    return ret;
}

static int32_t service_router_properties_write_cb(void *cb_data, size_t n_iid, uint32_t *iids,
                                                  size_t len, uint8_t *value)
{
    Iot__Service__Router__Properties *props = iot__service__router__properties__unpack(NULL, len, value);
    if (NULL == props) {
        return EINVAL;
    }

    int32_t ret = 0;
    struct router_properties properties = { 0 };
    struct router_ethwan_info ethwaninfo = { 0 };
    struct hey_array_node **reserveip = NULL;
    struct hey_array_node **staticroute = NULL;
    struct hey_array_node **wlanfilter = NULL;
    struct hey_array_node **client = NULL;
    struct hey_array_node **macfilter = NULL;
    struct hey_array_node **ipfilter = NULL;
    struct hey_array_node **domainfilter = NULL;
    struct hey_array_node **virtualserver = NULL;
    struct router_usb_share_account usbshareaccount = { 0 };
    if (props->ethwaninfo) {
        ethwaninfo.linkstatus = props->ethwaninfo->linkstatus;
        ethwaninfo.uploadrate = props->ethwaninfo->uploadrate;
        ethwaninfo.downloadrate = props->ethwaninfo->downloadrate;
    }
    if (props->usbshareaccount) {
        usbshareaccount.account = props->usbshareaccount->account;
        usbshareaccount.password = props->usbshareaccount->password;
    }
    properties.ethwaninfo = &ethwaninfo;
    properties.ethwanmac = props->ethwanmac;
    properties.ethwanip = props->ethwanip;
    properties.ethwansubnet = props->ethwansubnet;
    properties.ethwangateway = props->ethwangateway;
    properties.ethwanprimarydns = props->ethwanprimarydns;
    properties.ethwansecondarydns = props->ethwansecondarydns;
    properties.onlineclientno = props->onlineclientno;
    properties.connectmode = props->connectmode;
    properties.pppoeaccount = props->pppoeaccount;
    properties.pppoepassword = props->pppoepassword;
    properties.pppoemtu = props->pppoemtu;
    properties.dynamicmanualdnsenabled = props->dynamicmanualdnsenabled;
    properties.dynamicmanualprimarydns = props->dynamicmanualprimarydns;
    properties.dynamicmanualsecondarydns = props->dynamicmanualsecondarydns;
    properties.dynamicmtu = props->dynamicmtu;
    properties.staticip = props->staticip;
    properties.staticsubnet = props->staticsubnet;
    properties.staticgateway = props->staticgateway;
    properties.staticprimarydns = props->staticprimarydns;
    properties.staticsecondarydns = props->staticsecondarydns;
    properties.staticmtu = props->staticmtu;
    properties.lanip = props->lanip;
    properties.lansubnet = props->lansubnet;
    properties.dhcpenabled = props->dhcpenabled;
    properties.dhcpstartip = props->dhcpstartip;
    properties.dhcpendip = props->dhcpendip;
    properties.dhcpmanualdnsenabled = props->dhcpmanualdnsenabled;
    properties.dhcpmanualdnsprimary = props->dhcpmanualdnsprimary;
    properties.dhcpmanualdnssecondary = props->dhcpmanualdnssecondary;
    properties.dhcpleasetime = props->dhcpleasetime;
    if (props->n_reserveip) {
        reserveip = calloc(props->n_reserveip, sizeof(struct hey_array_node *));
        if (reserveip == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_reserveip; i++) {
            reserveip[i] = malloc(sizeof(struct hey_array_node));
            if (reserveip[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            reserveip[i]->id = props->reserveip[i]->id;
            reserveip[i]->data.data = props->reserveip[i]->data.data;
            reserveip[i]->data.len = props->reserveip[i]->data.len;
        }
        properties.n_reserveip = props->n_reserveip;
        properties.reserveip = reserveip;
    }
    if (props->n_staticroute) {
        staticroute = calloc(props->n_staticroute, sizeof(struct hey_array_node *));
        if (staticroute == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_staticroute; i++) {
            staticroute[i] = malloc(sizeof(struct hey_array_node));
            if (staticroute[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            staticroute[i]->id = props->staticroute[i]->id;
            staticroute[i]->data.data = props->staticroute[i]->data.data;
            staticroute[i]->data.len = props->staticroute[i]->data.len;
        }
        properties.n_staticroute = props->n_staticroute;
        properties.staticroute = staticroute;
    }
    properties.wlanenabled2p4g = props->wlanenabled2p4g;
    properties.ssid2p4g = props->ssid2p4g;
    properties.hidessidenabled2p4g = props->hidessidenabled2p4g;
    properties.sercuritymode2p4g = props->sercuritymode2p4g;
    properties.password2p4g = props->password2p4g;
    properties.transmitpower2p4g = props->transmitpower2p4g;
    properties.wlanenabled5g = props->wlanenabled5g;
    properties.ssid5g = props->ssid5g;
    properties.hidessidenabled5g = props->hidessidenabled5g;
    properties.sercuritymode5g = props->sercuritymode5g;
    properties.password5g = props->password5g;
    properties.transmitpower5g = props->transmitpower5g;
    properties.priorityenabled5g = props->priorityenabled5g;
    properties.combinedssid = props->combinedssid;
    properties.combinedsercuritymode = props->combinedsercuritymode;
    properties.combinedpassword = props->combinedpassword;
    properties.hidecombinedenabled = props->hidecombinedenabled;
    properties.guestwlanenabled = props->guestwlanenabled;
    properties.guestwlanssid = props->guestwlanssid;
    properties.guestwlantime = props->guestwlantime;
    properties.guestwlansercuritymode = props->guestwlansercuritymode;
    properties.guestwlanpassword = props->guestwlanpassword;
    properties.guestwlanbroadcastenabled = props->guestwlanbroadcastenabled;
    properties.wlanfilterenabled = props->wlanfilterenabled;
    properties.wlanfiltertype = props->wlanfiltertype;
    if (props->n_wlanfilter) {
        wlanfilter = calloc(props->n_wlanfilter, sizeof(struct hey_array_node *));
        if (wlanfilter == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_wlanfilter; i++) {
            wlanfilter[i] = malloc(sizeof(struct hey_array_node));
            if (wlanfilter[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            wlanfilter[i]->id = props->wlanfilter[i]->id;
            wlanfilter[i]->data.data = props->wlanfilter[i]->data.data;
            wlanfilter[i]->data.len = props->wlanfilter[i]->data.len;
        }
        properties.n_wlanfilter = props->n_wlanfilter;
        properties.wlanfilter = wlanfilter;
    }
    properties.wpsenabled = props->wpsenabled;
    if (props->n_client) {
        client = calloc(props->n_client, sizeof(struct hey_array_node *));
        if (client == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_client; i++) {
            client[i] = malloc(sizeof(struct hey_array_node));
            if (client[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            client[i]->id = props->client[i]->id;
            client[i]->data.data = props->client[i]->data.data;
            client[i]->data.len = props->client[i]->data.len;
        }
        properties.n_client = props->n_client;
        properties.client = client;
    }
    properties.webpassword = props->webpassword;
    properties.firewallenabled = props->firewallenabled;
    properties.macfilterenabled = props->macfilterenabled;
    properties.macfiltertype = props->macfiltertype;
    if (props->n_macfilter) {
        macfilter = calloc(props->n_macfilter, sizeof(struct hey_array_node *));
        if (macfilter == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_macfilter; i++) {
            macfilter[i] = malloc(sizeof(struct hey_array_node));
            if (macfilter[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            macfilter[i]->id = props->macfilter[i]->id;
            macfilter[i]->data.data = props->macfilter[i]->data.data;
            macfilter[i]->data.len = props->macfilter[i]->data.len;
        }
        properties.n_macfilter = props->n_macfilter;
        properties.macfilter = macfilter;
    }
    properties.ipfilterenabled = props->ipfilterenabled;
    properties.ipfiltertype = props->ipfiltertype;
    if (props->n_ipfilter) {
        ipfilter = calloc(props->n_ipfilter, sizeof(struct hey_array_node *));
        if (ipfilter == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_ipfilter; i++) {
            ipfilter[i] = malloc(sizeof(struct hey_array_node));
            if (ipfilter[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            ipfilter[i]->id = props->ipfilter[i]->id;
            ipfilter[i]->data.data = props->ipfilter[i]->data.data;
            ipfilter[i]->data.len = props->ipfilter[i]->data.len;
        }
        properties.n_ipfilter = props->n_ipfilter;
        properties.ipfilter = ipfilter;
    }
    properties.domainfilterenabled = props->domainfilterenabled;
    if (props->n_domainfilter) {
        domainfilter = calloc(props->n_domainfilter, sizeof(struct hey_array_node *));
        if (domainfilter == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_domainfilter; i++) {
            domainfilter[i] = malloc(sizeof(struct hey_array_node));
            if (domainfilter[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            domainfilter[i]->id = props->domainfilter[i]->id;
            domainfilter[i]->data.data = props->domainfilter[i]->data.data;
            domainfilter[i]->data.len = props->domainfilter[i]->data.len;
        }
        properties.n_domainfilter = props->n_domainfilter;
        properties.domainfilter = domainfilter;
    }
    properties.dmzenabled = props->dmzenabled;
    properties.dmzip = props->dmzip;
    if (props->n_virtualserver) {
        virtualserver = calloc(props->n_virtualserver, sizeof(struct hey_array_node *));
        if (virtualserver == NULL) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < props->n_virtualserver; i++) {
            virtualserver[i] = malloc(sizeof(struct hey_array_node));
            if (virtualserver[i] == NULL) {
                ret = ENOMEM;
                goto out;
            }
            virtualserver[i]->id = props->virtualserver[i]->id;
            virtualserver[i]->data.data = props->virtualserver[i]->data.data;
            virtualserver[i]->data.len = props->virtualserver[i]->data.len;
        }
        properties.n_virtualserver = props->n_virtualserver;
        properties.virtualserver = virtualserver;
    }
    properties.upnpenabled = props->upnpenabled;
    properties.usbshareenabled = props->usbshareenabled;
    properties.usbshareaccount = &usbshareaccount;
    properties.prioritywifienabled5g = props->prioritywifienabled5g;
    properties.wifiquality = props->wifiquality;
    properties.wifimode = props->wifimode;
    properties.indicatorlightenabled = props->indicatorlightenabled;
    ret = router_properties_write_cb(n_iid, iids, &properties);

out:
    if (reserveip) {
        for (int i = 0; i < props->n_reserveip; i++) {
            free(reserveip[i]);
        }
        free(reserveip);
    }
    if (staticroute) {
        for (int i = 0; i < props->n_staticroute; i++) {
            free(staticroute[i]);
        }
        free(staticroute);
    }
    if (wlanfilter) {
        for (int i = 0; i < props->n_wlanfilter; i++) {
            free(wlanfilter[i]);
        }
        free(wlanfilter);
    }
    if (client) {
        for (int i = 0; i < props->n_client; i++) {
            free(client[i]);
        }
        free(client);
    }
    if (macfilter) {
        for (int i = 0; i < props->n_macfilter; i++) {
            free(macfilter[i]);
        }
        free(macfilter);
    }
    if (ipfilter) {
        for (int i = 0; i < props->n_ipfilter; i++) {
            free(ipfilter[i]);
        }
        free(ipfilter);
    }
    if (domainfilter) {
        for (int i = 0; i < props->n_domainfilter; i++) {
            free(domainfilter[i]);
        }
        free(domainfilter);
    }
    if (virtualserver) {
        for (int i = 0; i < props->n_virtualserver; i++) {
            free(virtualserver[i]);
        }
        free(virtualserver);
    }
    iot__service__router__properties__free_unpacked(props, NULL);
    return ret;
}

static int32_t service_router_properties_array_add_cb(void *cb_data, uint32_t iid, size_t len, uint8_t *value)
{
    switch(iid) {
    case ROUTER_PROPERTY_RESERVEIP:
        return router_reserveip_array_add_cb(len, value);
    case ROUTER_PROPERTY_STATICROUTE:
        return router_staticroute_array_add_cb(len, value);
    case ROUTER_PROPERTY_WLANFILTER:
        return router_wlanfilter_array_add_cb(len, value);
    case ROUTER_PROPERTY_CLIENT:
        return router_client_array_add_cb(len, value);
    case ROUTER_PROPERTY_MACFILTER:
        return router_macfilter_array_add_cb(len, value);
    case ROUTER_PROPERTY_IPFILTER:
        return router_ipfilter_array_add_cb(len, value);
    case ROUTER_PROPERTY_DOMAINFILTER:
        return router_domainfilter_array_add_cb(len, value);
    case ROUTER_PROPERTY_VIRTUALSERVER:
        return router_virtualserver_array_add_cb(len, value);
    default:
        return -1;
    }
}

static int32_t service_router_properties_array_del_cb(void *cb_data, uint32_t iid, size_t n_id, uint32_t *ids)
{
    switch(iid) {
    case ROUTER_PROPERTY_RESERVEIP:
        return router_reserveip_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_STATICROUTE:
        return router_staticroute_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_WLANFILTER:
        return router_wlanfilter_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_CLIENT:
        return router_client_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_MACFILTER:
        return router_macfilter_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_IPFILTER:
        return router_ipfilter_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_DOMAINFILTER:
        return router_domainfilter_array_del_cb(n_id, ids);
    case ROUTER_PROPERTY_VIRTUALSERVER:
        return router_virtualserver_array_del_cb(n_id, ids);
    default:
        return -1;
    }
}

static int32_t service_router_properties_array_replace_cb(void *cb_data, uint32_t iid, uint32_t id, size_t len, uint8_t *value)
{
    switch(iid) {
    case ROUTER_PROPERTY_RESERVEIP:
        return router_reserveip_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_STATICROUTE:
        return router_staticroute_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_WLANFILTER:
        return router_wlanfilter_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_CLIENT:
        return router_client_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_MACFILTER:
        return router_macfilter_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_IPFILTER:
        return router_ipfilter_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_DOMAINFILTER:
        return router_domainfilter_array_replace_cb(id, len, value);
    case ROUTER_PROPERTY_VIRTUALSERVER:
        return router_virtualserver_array_replace_cb(id, len, value);
    default:
        return -1;
    }
}

static const struct hey_properties_callbacks props_cbs = {
    .write = service_router_properties_write_cb,
    .array_add = service_router_properties_array_add_cb,
    .array_del = service_router_properties_array_del_cb,
    .array_replace = service_router_properties_array_replace_cb,
};

static const struct hey_action_ctx_callbacks modify_web_password_cbs = {
    .start = action_modify_web_password_start_cb,
    .stop = action_modify_web_password_stop_cb
};

static const struct hey_action_ctx_callbacks device_reboot_cbs = {
    .start = action_device_reboot_start_cb,
    .stop = action_device_reboot_stop_cb
};

static const struct hey_action_ctx_callbacks device_restore_cbs = {
    .start = action_device_restore_start_cb,
    .stop = action_device_restore_stop_cb
};

static const struct hey_action_ctx_callbacks wifi_channel_optimization_cbs = {
    .start = action_wifi_channel_optimization_start_cb,
    .stop = action_wifi_channel_optimization_stop_cb
};

static const struct hey_action_entry actions_iids[] = {
    [0] = { .iid = ROUTER_ACTION_MODIFY_WEB_PASSWORD, .type = HEY_ACTION_ONCE, .cbs = &modify_web_password_cbs },
    [1] = { .iid = ROUTER_ACTION_DEVICE_REBOOT, .type = HEY_ACTION_ONCE, .cbs = &device_reboot_cbs },
    [2] = { .iid = ROUTER_ACTION_DEVICE_RESTORE, .type = HEY_ACTION_ONCE, .cbs = &device_restore_cbs },
    [3] = { .iid = ROUTER_ACTION_WIFI_CHANNEL_OPTIMIZATION, .type = HEY_ACTION_ONCE, .cbs = &wifi_channel_optimization_cbs },
};

static int router_service_register(Iot__Service__Router__Properties *props)
{
    uint8_t *buf;
    size_t buf_len;
    buf_len = iot__service__router__properties__get_packed_size(props);
    if (buf_len == 0) {
        buf = NULL;
    } else {
        buf = malloc(buf_len);
        if (!buf) {
            return ENOMEM;
        }
        iot__service__router__properties__pack(props, buf);
    }

    struct hey_schema_service schema_srv;
    hey_schema_service_init(&schema_srv);
    schema_srv.properties.iids = (struct hey_schema_property *)router_properties_iids;
    schema_srv.properties.n_iid = PROP_IID_CNT;
    schema_srv.properties.value = buf;
    schema_srv.properties.len = buf_len;
    schema_srv.properties.cbs = &props_cbs;
    schema_srv.actions.iids = (struct hey_action_entry *)actions_iids;
    schema_srv.actions.n_iid = ACT_IID_CNT;
    router_service = hey_service_register(ROUTER_SERVICE, &schema_srv, NULL);
    if (NULL == router_service) {
        free(buf);
        return errno;
    }

    free(buf);
    return 0;
}

/**
 * @brief update properties of router service
 * @param count      [the number of properties to be updated]
 * @param enumerate  [the iid enumeration of properties to be updated]
 * @param properties [properties structure with updated content]
 * @return int32_t   [update result]
 */
int32_t router_properties_update(size_t count, uint32_t *enumerate, struct router_properties *properties)
{
    assert(count <= PROP_IID_CNT);
    if (NULL == properties) {
        return EINVAL;
    }

    int ret = 0;
    Iot__Service__Router__Properties *props = NULL;
    uint8_t *buf = NULL;
    Iot__Service__Router__EthwanInfo *ethwaninfo = NULL;
    ArrayNode **reserveip = NULL;
    ArrayNode **staticroute = NULL;
    ArrayNode **wlanfilter = NULL;
    ArrayNode **client = NULL;
    ArrayNode **macfilter = NULL;
    ArrayNode **ipfilter = NULL;
    ArrayNode **domainfilter = NULL;
    ArrayNode **virtualserver = NULL;
    Iot__Service__Router__UsbShareAccount *usbshareaccount = NULL;
    props = malloc(sizeof(Iot__Service__Router__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__router__properties__init(props);
    if (properties->ethwaninfo) {
        ethwaninfo = malloc(sizeof(Iot__Service__Router__EthwanInfo));
        if (NULL == ethwaninfo) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__router__ethwan_info__init(ethwaninfo);
        ethwaninfo->linkstatus = properties->ethwaninfo->linkstatus;
        ethwaninfo->uploadrate = properties->ethwaninfo->uploadrate;
        ethwaninfo->downloadrate = properties->ethwaninfo->downloadrate;
    }
    if (properties->n_reserveip) {
        reserveip = calloc(properties->n_reserveip, sizeof(ArrayNode *));
        if (NULL == reserveip) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_reserveip; i++) {
            reserveip[i] = malloc(sizeof(ArrayNode));
            if (NULL == reserveip[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(reserveip[i]);
            reserveip[i]->id = properties->reserveip[i]->id;
            reserveip[i]->data.data = properties->reserveip[i]->data.data;
            reserveip[i]->data.len = properties->reserveip[i]->data.len;
        }
    }
    if (properties->n_staticroute) {
        staticroute = calloc(properties->n_staticroute, sizeof(ArrayNode *));
        if (NULL == staticroute) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_staticroute; i++) {
            staticroute[i] = malloc(sizeof(ArrayNode));
            if (NULL == staticroute[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(staticroute[i]);
            staticroute[i]->id = properties->staticroute[i]->id;
            staticroute[i]->data.data = properties->staticroute[i]->data.data;
            staticroute[i]->data.len = properties->staticroute[i]->data.len;
        }
    }
    if (properties->n_wlanfilter) {
        wlanfilter = calloc(properties->n_wlanfilter, sizeof(ArrayNode *));
        if (NULL == wlanfilter) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_wlanfilter; i++) {
            wlanfilter[i] = malloc(sizeof(ArrayNode));
            if (NULL == wlanfilter[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(wlanfilter[i]);
            wlanfilter[i]->id = properties->wlanfilter[i]->id;
            wlanfilter[i]->data.data = properties->wlanfilter[i]->data.data;
            wlanfilter[i]->data.len = properties->wlanfilter[i]->data.len;
        }
    }
    if (properties->n_client) {
        client = calloc(properties->n_client, sizeof(ArrayNode *));
        if (NULL == client) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_client; i++) {
            client[i] = malloc(sizeof(ArrayNode));
            if (NULL == client[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(client[i]);
            client[i]->id = properties->client[i]->id;
            client[i]->data.data = properties->client[i]->data.data;
            client[i]->data.len = properties->client[i]->data.len;
        }
    }
    if (properties->n_macfilter) {
        macfilter = calloc(properties->n_macfilter, sizeof(ArrayNode *));
        if (NULL == macfilter) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_macfilter; i++) {
            macfilter[i] = malloc(sizeof(ArrayNode));
            if (NULL == macfilter[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(macfilter[i]);
            macfilter[i]->id = properties->macfilter[i]->id;
            macfilter[i]->data.data = properties->macfilter[i]->data.data;
            macfilter[i]->data.len = properties->macfilter[i]->data.len;
        }
    }
    if (properties->n_ipfilter) {
        ipfilter = calloc(properties->n_ipfilter, sizeof(ArrayNode *));
        if (NULL == ipfilter) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_ipfilter; i++) {
            ipfilter[i] = malloc(sizeof(ArrayNode));
            if (NULL == ipfilter[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(ipfilter[i]);
            ipfilter[i]->id = properties->ipfilter[i]->id;
            ipfilter[i]->data.data = properties->ipfilter[i]->data.data;
            ipfilter[i]->data.len = properties->ipfilter[i]->data.len;
        }
    }
    if (properties->n_domainfilter) {
        domainfilter = calloc(properties->n_domainfilter, sizeof(ArrayNode *));
        if (NULL == domainfilter) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_domainfilter; i++) {
            domainfilter[i] = malloc(sizeof(ArrayNode));
            if (NULL == domainfilter[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(domainfilter[i]);
            domainfilter[i]->id = properties->domainfilter[i]->id;
            domainfilter[i]->data.data = properties->domainfilter[i]->data.data;
            domainfilter[i]->data.len = properties->domainfilter[i]->data.len;
        }
    }
    if (properties->n_virtualserver) {
        virtualserver = calloc(properties->n_virtualserver, sizeof(ArrayNode *));
        if (NULL == virtualserver) {
            ret = ENOMEM;
            goto out;
        }
        for (int i = 0; i < properties->n_virtualserver; i++) {
            virtualserver[i] = malloc(sizeof(ArrayNode));
            if (NULL == virtualserver[i]) {
                ret = ENOMEM;
                goto out;
            }
            array_node__init(virtualserver[i]);
            virtualserver[i]->id = properties->virtualserver[i]->id;
            virtualserver[i]->data.data = properties->virtualserver[i]->data.data;
            virtualserver[i]->data.len = properties->virtualserver[i]->data.len;
        }
    }
    if (properties->usbshareaccount) {
        usbshareaccount = malloc(sizeof(Iot__Service__Router__UsbShareAccount));
        if (NULL == usbshareaccount) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__router__usb_share_account__init(usbshareaccount);
        usbshareaccount->account = properties->usbshareaccount->account;
        usbshareaccount->password = properties->usbshareaccount->password;
    }
    props->ethwaninfo = ethwaninfo;
    props->ethwanmac = properties->ethwanmac;
    props->ethwanip = properties->ethwanip;
    props->ethwansubnet = properties->ethwansubnet;
    props->ethwangateway = properties->ethwangateway;
    props->ethwanprimarydns = properties->ethwanprimarydns;
    props->ethwansecondarydns = properties->ethwansecondarydns;
    props->onlineclientno = properties->onlineclientno;
    props->connectmode = properties->connectmode;
    props->pppoeaccount = properties->pppoeaccount;
    props->pppoepassword = properties->pppoepassword;
    props->pppoemtu = properties->pppoemtu;
    props->dynamicmanualdnsenabled = properties->dynamicmanualdnsenabled;
    props->dynamicmanualprimarydns = properties->dynamicmanualprimarydns;
    props->dynamicmanualsecondarydns = properties->dynamicmanualsecondarydns;
    props->dynamicmtu = properties->dynamicmtu;
    props->staticip = properties->staticip;
    props->staticsubnet = properties->staticsubnet;
    props->staticgateway = properties->staticgateway;
    props->staticprimarydns = properties->staticprimarydns;
    props->staticsecondarydns = properties->staticsecondarydns;
    props->staticmtu = properties->staticmtu;
    props->lanip = properties->lanip;
    props->lansubnet = properties->lansubnet;
    props->dhcpenabled = properties->dhcpenabled;
    props->dhcpstartip = properties->dhcpstartip;
    props->dhcpendip = properties->dhcpendip;
    props->dhcpmanualdnsenabled = properties->dhcpmanualdnsenabled;
    props->dhcpmanualdnsprimary = properties->dhcpmanualdnsprimary;
    props->dhcpmanualdnssecondary = properties->dhcpmanualdnssecondary;
    props->dhcpleasetime = properties->dhcpleasetime;
    props->n_reserveip = properties->n_reserveip;
    props->reserveip = reserveip;
    props->n_staticroute = properties->n_staticroute;
    props->staticroute = staticroute;
    props->wlanenabled2p4g = properties->wlanenabled2p4g;
    props->ssid2p4g = properties->ssid2p4g;
    props->hidessidenabled2p4g = properties->hidessidenabled2p4g;
    props->sercuritymode2p4g = properties->sercuritymode2p4g;
    props->password2p4g = properties->password2p4g;
    props->transmitpower2p4g = properties->transmitpower2p4g;
    props->wlanenabled5g = properties->wlanenabled5g;
    props->ssid5g = properties->ssid5g;
    props->hidessidenabled5g = properties->hidessidenabled5g;
    props->sercuritymode5g = properties->sercuritymode5g;
    props->password5g = properties->password5g;
    props->transmitpower5g = properties->transmitpower5g;
    props->priorityenabled5g = properties->priorityenabled5g;
    props->combinedssid = properties->combinedssid;
    props->combinedsercuritymode = properties->combinedsercuritymode;
    props->combinedpassword = properties->combinedpassword;
    props->hidecombinedenabled = properties->hidecombinedenabled;
    props->guestwlanenabled = properties->guestwlanenabled;
    props->guestwlanssid = properties->guestwlanssid;
    props->guestwlantime = properties->guestwlantime;
    props->guestwlansercuritymode = properties->guestwlansercuritymode;
    props->guestwlanpassword = properties->guestwlanpassword;
    props->guestwlanbroadcastenabled = properties->guestwlanbroadcastenabled;
    props->wlanfilterenabled = properties->wlanfilterenabled;
    props->wlanfiltertype = properties->wlanfiltertype;
    props->n_wlanfilter = properties->n_wlanfilter;
    props->wlanfilter = wlanfilter;
    props->wpsenabled = properties->wpsenabled;
    props->n_client = properties->n_client;
    props->client = client;
    props->webpassword = properties->webpassword;
    props->firewallenabled = properties->firewallenabled;
    props->macfilterenabled = properties->macfilterenabled;
    props->macfiltertype = properties->macfiltertype;
    props->n_macfilter = properties->n_macfilter;
    props->macfilter = macfilter;
    props->ipfilterenabled = properties->ipfilterenabled;
    props->ipfiltertype = properties->ipfiltertype;
    props->n_ipfilter = properties->n_ipfilter;
    props->ipfilter = ipfilter;
    props->domainfilterenabled = properties->domainfilterenabled;
    props->n_domainfilter = properties->n_domainfilter;
    props->domainfilter = domainfilter;
    props->dmzenabled = properties->dmzenabled;
    props->dmzip = properties->dmzip;
    props->n_virtualserver = properties->n_virtualserver;
    props->virtualserver = virtualserver;
    props->upnpenabled = properties->upnpenabled;
    props->usbshareenabled = properties->usbshareenabled;
    props->usbshareaccount = usbshareaccount;
    props->prioritywifienabled5g = properties->prioritywifienabled5g;
    props->wifiquality = properties->wifiquality;
    props->wifimode = properties->wifimode;
    props->indicatorlightenabled = properties->indicatorlightenabled;

    size_t buf_len;
    buf_len = iot__service__router__properties__get_packed_size(props);
    if (buf_len > 0) {
        buf = malloc(buf_len);
        if (NULL == buf) {
            ret = ENOMEM;
            goto out;
        }
        iot__service__router__properties__pack(props, buf);
    }

    struct hey_properties_content content = {
        .n_iid = count,
        .iids = enumerate,
        .len = buf_len,
        .value = buf
    };
    ret = hey_properties_update(router_service, &content);

out:
    free(props);
    free(buf);
    free(ethwaninfo);
    if (reserveip) {
        for (int i = 0; i < properties->n_reserveip; i++) {
            free(reserveip[i]);
        }
        free(reserveip);
    }
    if (staticroute) {
        for (int i = 0; i < properties->n_staticroute; i++) {
            free(staticroute[i]);
        }
        free(staticroute);
    }
    if (wlanfilter) {
        for (int i = 0; i < properties->n_wlanfilter; i++) {
            free(wlanfilter[i]);
        }
        free(wlanfilter);
    }
    if (client) {
        for (int i = 0; i < properties->n_client; i++) {
            free(client[i]);
        }
        free(client);
    }
    if (macfilter) {
        for (int i = 0; i < properties->n_macfilter; i++) {
            free(macfilter[i]);
        }
        free(macfilter);
    }
    if (ipfilter) {
        for (int i = 0; i < properties->n_ipfilter; i++) {
            free(ipfilter[i]);
        }
        free(ipfilter);
    }
    if (domainfilter) {
        for (int i = 0; i < properties->n_domainfilter; i++) {
            free(domainfilter[i]);
        }
        free(domainfilter);
    }
    if (virtualserver) {
        for (int i = 0; i < properties->n_virtualserver; i++) {
            free(virtualserver[i]);
        }
        free(virtualserver);
    }
    free(usbshareaccount);
    return ret;
}

/**
 * @brief router service initialization
 * @param properties [router service properties]
 * @return int32_t   [initialize result]
*/
int32_t router_service_init(const struct router_properties *properties)
{
    int ret = 0;
    Iot__Service__Router__Properties *props = NULL;
    Iot__Service__Router__EthwanInfo *ethwaninfo = NULL;
    ArrayNode **reserveip = NULL;
    ArrayNode **staticroute = NULL;
    ArrayNode **wlanfilter = NULL;
    ArrayNode **client = NULL;
    ArrayNode **macfilter = NULL;
    ArrayNode **ipfilter = NULL;
    ArrayNode **domainfilter = NULL;
    ArrayNode **virtualserver = NULL;
    Iot__Service__Router__UsbShareAccount *usbshareaccount = NULL;
    props = malloc(sizeof(Iot__Service__Router__Properties));
    if (NULL == props) {
        ret = ENOMEM;
        goto out;
    }
    iot__service__router__properties__init(props);
    if (NULL != properties) {
        if (properties->ethwaninfo) {
            ethwaninfo = malloc(sizeof(Iot__Service__Router__EthwanInfo));
            if (NULL == ethwaninfo) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__router__ethwan_info__init(ethwaninfo);
            ethwaninfo->linkstatus = properties->ethwaninfo->linkstatus;
            ethwaninfo->uploadrate = properties->ethwaninfo->uploadrate;
            ethwaninfo->downloadrate = properties->ethwaninfo->downloadrate;
        }
        if (properties->n_reserveip) {
            reserveip = calloc(properties->n_reserveip, sizeof(ArrayNode *));
            if (NULL == reserveip) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_reserveip; i++) {
                reserveip[i] = malloc(sizeof(ArrayNode));
                if (NULL == reserveip[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(reserveip[i]);
                reserveip[i]->id = properties->reserveip[i]->id;
                reserveip[i]->data.data = properties->reserveip[i]->data.data;
                reserveip[i]->data.len = properties->reserveip[i]->data.len;
            }
        }
        if (properties->n_staticroute) {
            staticroute = calloc(properties->n_staticroute, sizeof(ArrayNode *));
            if (NULL == staticroute) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_staticroute; i++) {
                staticroute[i] = malloc(sizeof(ArrayNode));
                if (NULL == staticroute[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(staticroute[i]);
                staticroute[i]->id = properties->staticroute[i]->id;
                staticroute[i]->data.data = properties->staticroute[i]->data.data;
                staticroute[i]->data.len = properties->staticroute[i]->data.len;
            }
        }
        if (properties->n_wlanfilter) {
            wlanfilter = calloc(properties->n_wlanfilter, sizeof(ArrayNode *));
            if (NULL == wlanfilter) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_wlanfilter; i++) {
                wlanfilter[i] = malloc(sizeof(ArrayNode));
                if (NULL == wlanfilter[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(wlanfilter[i]);
                wlanfilter[i]->id = properties->wlanfilter[i]->id;
                wlanfilter[i]->data.data = properties->wlanfilter[i]->data.data;
                wlanfilter[i]->data.len = properties->wlanfilter[i]->data.len;
            }
        }
        if (properties->n_client) {
            client = calloc(properties->n_client, sizeof(ArrayNode *));
            if (NULL == client) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_client; i++) {
                client[i] = malloc(sizeof(ArrayNode));
                if (NULL == client[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(client[i]);
                client[i]->id = properties->client[i]->id;
                client[i]->data.data = properties->client[i]->data.data;
                client[i]->data.len = properties->client[i]->data.len;
            }
        }
        if (properties->n_macfilter) {
            macfilter = calloc(properties->n_macfilter, sizeof(ArrayNode *));
            if (NULL == macfilter) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_macfilter; i++) {
                macfilter[i] = malloc(sizeof(ArrayNode));
                if (NULL == macfilter[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(macfilter[i]);
                macfilter[i]->id = properties->macfilter[i]->id;
                macfilter[i]->data.data = properties->macfilter[i]->data.data;
                macfilter[i]->data.len = properties->macfilter[i]->data.len;
            }
        }
        if (properties->n_ipfilter) {
            ipfilter = calloc(properties->n_ipfilter, sizeof(ArrayNode *));
            if (NULL == ipfilter) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_ipfilter; i++) {
                ipfilter[i] = malloc(sizeof(ArrayNode));
                if (NULL == ipfilter[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(ipfilter[i]);
                ipfilter[i]->id = properties->ipfilter[i]->id;
                ipfilter[i]->data.data = properties->ipfilter[i]->data.data;
                ipfilter[i]->data.len = properties->ipfilter[i]->data.len;
            }
        }
        if (properties->n_domainfilter) {
            domainfilter = calloc(properties->n_domainfilter, sizeof(ArrayNode *));
            if (NULL == domainfilter) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_domainfilter; i++) {
                domainfilter[i] = malloc(sizeof(ArrayNode));
                if (NULL == domainfilter[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(domainfilter[i]);
                domainfilter[i]->id = properties->domainfilter[i]->id;
                domainfilter[i]->data.data = properties->domainfilter[i]->data.data;
                domainfilter[i]->data.len = properties->domainfilter[i]->data.len;
            }
        }
        if (properties->n_virtualserver) {
            virtualserver = calloc(properties->n_virtualserver, sizeof(ArrayNode *));
            if (NULL == virtualserver) {
                ret = ENOMEM;
                goto out;
            }
            for (int i = 0; i < properties->n_virtualserver; i++) {
                virtualserver[i] = malloc(sizeof(ArrayNode));
                if (NULL == virtualserver[i]) {
                    ret = ENOMEM;
                    goto out;
                }
                array_node__init(virtualserver[i]);
                virtualserver[i]->id = properties->virtualserver[i]->id;
                virtualserver[i]->data.data = properties->virtualserver[i]->data.data;
                virtualserver[i]->data.len = properties->virtualserver[i]->data.len;
            }
        }
        if (properties->usbshareaccount) {
            usbshareaccount = malloc(sizeof(Iot__Service__Router__UsbShareAccount));
            if (NULL == usbshareaccount) {
                ret = ENOMEM;
                goto out;
            }
            iot__service__router__usb_share_account__init(usbshareaccount);
            usbshareaccount->account = properties->usbshareaccount->account;
            usbshareaccount->password = properties->usbshareaccount->password;
        }
        props->ethwaninfo = ethwaninfo;
        props->ethwanmac = properties->ethwanmac;
        props->ethwanip = properties->ethwanip;
        props->ethwansubnet = properties->ethwansubnet;
        props->ethwangateway = properties->ethwangateway;
        props->ethwanprimarydns = properties->ethwanprimarydns;
        props->ethwansecondarydns = properties->ethwansecondarydns;
        props->onlineclientno = properties->onlineclientno;
        props->connectmode = properties->connectmode;
        props->pppoeaccount = properties->pppoeaccount;
        props->pppoepassword = properties->pppoepassword;
        props->pppoemtu = properties->pppoemtu;
        props->dynamicmanualdnsenabled = properties->dynamicmanualdnsenabled;
        props->dynamicmanualprimarydns = properties->dynamicmanualprimarydns;
        props->dynamicmanualsecondarydns = properties->dynamicmanualsecondarydns;
        props->dynamicmtu = properties->dynamicmtu;
        props->staticip = properties->staticip;
        props->staticsubnet = properties->staticsubnet;
        props->staticgateway = properties->staticgateway;
        props->staticprimarydns = properties->staticprimarydns;
        props->staticsecondarydns = properties->staticsecondarydns;
        props->staticmtu = properties->staticmtu;
        props->lanip = properties->lanip;
        props->lansubnet = properties->lansubnet;
        props->dhcpenabled = properties->dhcpenabled;
        props->dhcpstartip = properties->dhcpstartip;
        props->dhcpendip = properties->dhcpendip;
        props->dhcpmanualdnsenabled = properties->dhcpmanualdnsenabled;
        props->dhcpmanualdnsprimary = properties->dhcpmanualdnsprimary;
        props->dhcpmanualdnssecondary = properties->dhcpmanualdnssecondary;
        props->dhcpleasetime = properties->dhcpleasetime;
        props->n_reserveip = properties->n_reserveip;
        props->reserveip = reserveip;
        props->n_staticroute = properties->n_staticroute;
        props->staticroute = staticroute;
        props->wlanenabled2p4g = properties->wlanenabled2p4g;
        props->ssid2p4g = properties->ssid2p4g;
        props->hidessidenabled2p4g = properties->hidessidenabled2p4g;
        props->sercuritymode2p4g = properties->sercuritymode2p4g;
        props->password2p4g = properties->password2p4g;
        props->transmitpower2p4g = properties->transmitpower2p4g;
        props->wlanenabled5g = properties->wlanenabled5g;
        props->ssid5g = properties->ssid5g;
        props->hidessidenabled5g = properties->hidessidenabled5g;
        props->sercuritymode5g = properties->sercuritymode5g;
        props->password5g = properties->password5g;
        props->transmitpower5g = properties->transmitpower5g;
        props->priorityenabled5g = properties->priorityenabled5g;
        props->combinedssid = properties->combinedssid;
        props->combinedsercuritymode = properties->combinedsercuritymode;
        props->combinedpassword = properties->combinedpassword;
        props->hidecombinedenabled = properties->hidecombinedenabled;
        props->guestwlanenabled = properties->guestwlanenabled;
        props->guestwlanssid = properties->guestwlanssid;
        props->guestwlantime = properties->guestwlantime;
        props->guestwlansercuritymode = properties->guestwlansercuritymode;
        props->guestwlanpassword = properties->guestwlanpassword;
        props->guestwlanbroadcastenabled = properties->guestwlanbroadcastenabled;
        props->wlanfilterenabled = properties->wlanfilterenabled;
        props->wlanfiltertype = properties->wlanfiltertype;
        props->n_wlanfilter = properties->n_wlanfilter;
        props->wlanfilter = wlanfilter;
        props->wpsenabled = properties->wpsenabled;
        props->n_client = properties->n_client;
        props->client = client;
        props->webpassword = properties->webpassword;
        props->firewallenabled = properties->firewallenabled;
        props->macfilterenabled = properties->macfilterenabled;
        props->macfiltertype = properties->macfiltertype;
        props->n_macfilter = properties->n_macfilter;
        props->macfilter = macfilter;
        props->ipfilterenabled = properties->ipfilterenabled;
        props->ipfiltertype = properties->ipfiltertype;
        props->n_ipfilter = properties->n_ipfilter;
        props->ipfilter = ipfilter;
        props->domainfilterenabled = properties->domainfilterenabled;
        props->n_domainfilter = properties->n_domainfilter;
        props->domainfilter = domainfilter;
        props->dmzenabled = properties->dmzenabled;
        props->dmzip = properties->dmzip;
        props->n_virtualserver = properties->n_virtualserver;
        props->virtualserver = virtualserver;
        props->upnpenabled = properties->upnpenabled;
        props->usbshareenabled = properties->usbshareenabled;
        props->usbshareaccount = usbshareaccount;
        props->prioritywifienabled5g = properties->prioritywifienabled5g;
        props->wifiquality = properties->wifiquality;
        props->wifimode = properties->wifimode;
        props->indicatorlightenabled = properties->indicatorlightenabled;
    }

    ret = router_service_register(props);

out:
    free(props);
    free(ethwaninfo);
    if (reserveip) {
        for (int i = 0; i < properties->n_reserveip; i++) {
            free(reserveip[i]);
        }
        free(reserveip);
    }
    if (staticroute) {
        for (int i = 0; i < properties->n_staticroute; i++) {
            free(staticroute[i]);
        }
        free(staticroute);
    }
    if (wlanfilter) {
        for (int i = 0; i < properties->n_wlanfilter; i++) {
            free(wlanfilter[i]);
        }
        free(wlanfilter);
    }
    if (client) {
        for (int i = 0; i < properties->n_client; i++) {
            free(client[i]);
        }
        free(client);
    }
    if (macfilter) {
        for (int i = 0; i < properties->n_macfilter; i++) {
            free(macfilter[i]);
        }
        free(macfilter);
    }
    if (ipfilter) {
        for (int i = 0; i < properties->n_ipfilter; i++) {
            free(ipfilter[i]);
        }
        free(ipfilter);
    }
    if (domainfilter) {
        for (int i = 0; i < properties->n_domainfilter; i++) {
            free(domainfilter[i]);
        }
        free(domainfilter);
    }
    if (virtualserver) {
        for (int i = 0; i < properties->n_virtualserver; i++) {
            free(virtualserver[i]);
        }
        free(virtualserver);
    }
    free(usbshareaccount);
    return ret;
}
